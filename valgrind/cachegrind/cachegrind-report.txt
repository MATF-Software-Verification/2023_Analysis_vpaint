--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         12582912 B, 64 B, 12-way associative
Command:          ../../build/src/Gui/VPaint
Data file:        cachegrind.out.5884
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   cachegrind.out.9430
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr                ILmr               Dr                     D1mr                 DLmr                Dw                     D1mw                 DLmw                 
--------------------------------------------------------------------------------
7,426,696,543 (100.0%) 50,940,875 (100.0%) 8,016,607 (100.0%) 1,838,695,292 (100.0%) 128,787,326 (100.0%) 88,631,006 (100.0%) 1,335,308,173 (100.0%) 171,662,897 (100.0%) 115,399,152 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr                ILmr               Dr                   D1mr                 DLmr                Dw                   D1mw                 DLmw                  file:function
--------------------------------------------------------------------------------
3,573,546,057 (48.12%) 23,694,188 (46.51%) 4,605,407 (57.45%) 732,164,976 (39.82%)  11,574,933 ( 8.99%)  2,131,698 ( 2.41%) 470,965,153 (35.27%)  66,361,966 (38.66%)  11,837,330 (10.26%)  ???:???
  734,864,144 ( 9.89%)    120,350 ( 0.24%)    12,371 ( 0.15%) 213,946,342 (11.64%) 102,893,289 (79.89%) 83,860,129 (94.62%) 213,416,904 (15.98%) 102,985,522 (59.99%) 102,801,012 (89.08%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
   96,687,356 ( 1.30%)      7,679 ( 0.02%)       422 ( 0.01%)  34,435,565 ( 1.87%)   3,598,029 ( 2.79%)     37,602 ( 0.04%)   8,067,176 ( 0.60%)       5,277 ( 0.00%)         146 ( 0.00%)  ./elf/./elf/dl-lookup.c:do_lookup_x
   93,867,880 ( 1.26%)      1,866 ( 0.00%)     1,199 ( 0.01%)  22,086,560 ( 1.20%)           0                   0           24,847,380 ( 1.86%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 2, 1, 0, 2, 1>, 0>::coeff(long) const
   88,929,086 ( 1.20%)    180,923 ( 0.36%)     8,828 ( 0.11%)  15,316,588 ( 0.83%)       2,720 ( 0.00%)          0            6,582,332 ( 0.49%)     111,319 ( 0.06%)      10,136 ( 0.01%)  ???:QBezier::addToPolygon(QDataBuffer<QPointF>&, double) const
   76,734,888 ( 1.03%)      3,132 ( 0.01%)       743 ( 0.01%)  22,381,009 ( 1.22%)           0                   0           25,578,296 ( 1.92%)          61 ( 0.00%)          20 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > >::evaluator(Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > const&)
   73,576,717 ( 0.99%)    580,345 ( 1.14%)    14,311 ( 0.18%)  21,837,064 ( 1.19%)     172,456 ( 0.13%)     34,804 ( 0.04%)  10,229,092 ( 0.77%)      21,113 ( 0.01%)       2,750 ( 0.00%)  ./malloc/./malloc/malloc.c:_int_free
   63,109,053 ( 0.85%)      1,461 ( 0.00%)        41 ( 0.00%)  27,046,737 ( 1.47%)           0                   0           18,031,158 ( 1.35%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::derived() const
   62,050,300 ( 0.84%)    992,435 ( 1.95%)    40,797 ( 0.51%)  10,737,972 ( 0.58%)     315,989 ( 0.25%)     66,248 ( 0.07%)   9,650,836 ( 0.72%)     288,367 ( 0.17%)     127,703 ( 0.11%)  ./malloc/./malloc/malloc.c:_int_malloc
   52,455,580 ( 0.71%)      2,393 ( 0.00%)     1,806 ( 0.02%)  19,325,740 ( 1.05%)           0                   0           13,804,100 ( 1.03%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 2, 1, 0, 2, 1>, 0>::operator[](long) const
   51,323,918 ( 0.69%)      1,016 ( 0.00%)       351 ( 0.00%)  15,095,270 ( 0.82%)           0                   0           15,095,270 ( 1.13%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::size() const
   48,066,722 ( 0.65%)      2,515 ( 0.00%)       700 ( 0.01%)  13,109,106 ( 0.71%)           0                   0           13,109,106 ( 0.98%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/XprHelper.h:Eigen::internal::variable_if_dynamic<long, 0>::variable_if_dynamic(long)
   44,762,018 ( 0.60%)      1,177 ( 0.00%)       352 ( 0.00%)  12,789,148 ( 0.70%)           0                   0           12,789,148 ( 0.96%)          88 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::evaluator(Eigen::Matrix<double, 2, 1, 0, 2, 1> const&)
   42,831,177 ( 0.58%)    260,543 ( 0.51%)     6,529 ( 0.08%)  11,168,029 ( 0.61%)     252,354 ( 0.20%)     46,797 ( 0.05%)   4,999,416 ( 0.37%)       5,342 ( 0.00%)         218 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc
   41,055,480 ( 0.55%)        409 ( 0.00%)       260 ( 0.00%)  13,685,160 ( 0.74%)           0                   0            8,211,096 ( 0.61%)           0                    0           /usr/include/c++/11/bits/stl_vector.h:std::vector<VectorAnimationComplex::Triangle, Eigen::aligned_allocator<VectorAnimationComplex::Triangle> >::operator[](unsigned long) const
   37,938,118 ( 0.51%)      5,726 ( 0.01%)       390 ( 0.00%)   8,926,616 ( 0.49%)           0                   0           10,042,443 ( 0.75%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 3, 1, 0, 3, 1>, 0>::coeff(long) const
   36,404,832 ( 0.49%)      6,662 ( 0.01%)       708 ( 0.01%)   9,101,208 ( 0.49%)           0                   0           12,134,944 ( 0.91%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::rows() const
   36,404,832 ( 0.49%)         79 ( 0.00%)         0            9,101,208 ( 0.49%)           0                   0           12,134,944 ( 0.91%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::cols() const
   36,096,123 ( 0.49%)      2,889 ( 0.01%)     1,974 ( 0.02%)  10,960,853 ( 0.60%)     341,016 ( 0.26%)    338,129 ( 0.38%)   8,685,083 ( 0.65%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/Triangles.cpp:VectorAnimationComplex::Triangles::draw() const
   35,170,157 ( 0.47%)      1,365 ( 0.00%)       351 ( 0.00%)   9,591,861 ( 0.52%)           0                   0            9,591,861 ( 0.72%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::~evaluator()
   35,170,157 ( 0.47%)        879 ( 0.00%)         0            9,591,861 ( 0.52%)           0                   0            9,591,861 ( 0.72%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::~evaluator_base()
   35,170,157 ( 0.47%)          0                  0            9,591,861 ( 0.52%)           0                   0            9,591,861 ( 0.72%)         107 ( 0.00%)          10 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::evaluator_base()
   35,170,157 ( 0.47%)          0                  0            9,591,861 ( 0.52%)           0                   0            9,591,861 ( 0.72%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > >::~evaluator()
   33,129,840 ( 0.45%)        356 ( 0.00%)        38 ( 0.00%)  13,804,100 ( 0.75%)           0                   0            8,282,460 ( 0.62%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > >::coeff(long) const
   32,208,400 ( 0.43%)      1,580 ( 0.00%)       352 ( 0.00%)   9,202,400 ( 0.50%)           0                   0            9,202,400 ( 0.69%)         174 ( 0.00%)          20 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/Meta.h:Eigen::internal::noncopyable::noncopyable()
   32,208,400 ( 0.43%)          0                  0            9,202,400 ( 0.50%)           0                   0            9,202,400 ( 0.69%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/Meta.h:Eigen::internal::noncopyable::~noncopyable()
   31,972,870 ( 0.43%)        664 ( 0.00%)        11 ( 0.00%)   9,591,861 ( 0.52%)           0                   0            9,591,861 ( 0.72%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::data() const
   31,874,678 ( 0.43%)     95,286 ( 0.19%)     4,215 ( 0.05%)     214,458 ( 0.01%)         411 ( 0.00%)          0           29,650,173 ( 2.22%)     548,729 ( 0.32%)     254,777 ( 0.22%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
   31,846,473 ( 0.43%)     88,546 ( 0.17%)     3,411 ( 0.04%)  10,944,125 ( 0.60%)       7,984 ( 0.01%)        809 ( 0.00%)   2,970,173 ( 0.22%)       2,255 ( 0.00%)          22 ( 0.00%)  ???:QTransform::map(QPointF const&) const
   28,942,750 ( 0.39%)      5,732 ( 0.01%)       416 ( 0.01%)   4,134,640 ( 0.22%)       1,392 ( 0.00%)        688 ( 0.00%)           0                    0                    0           ./string/../sysdeps/x86_64/multiarch/strchr-avx2.S:__strchr_avx2
   27,808,152 ( 0.37%)      5,617 ( 0.01%)       693 ( 0.01%)   8,110,711 ( 0.44%)           0                   0            9,269,384 ( 0.69%)          41 ( 0.00%)          22 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >::evaluator(Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > const&)
   27,318,808 ( 0.37%)        884 ( 0.00%)        13 ( 0.00%)   6,829,702 ( 0.37%)           0                   0           10,244,553 ( 0.77%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::rows() const
   27,318,808 ( 0.37%)          0                  0            6,829,702 ( 0.37%)           0                   0           10,244,553 ( 0.77%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::cols() const
   24,361,113 ( 0.33%)      4,718 ( 0.01%)       257 ( 0.00%)   4,309,496 ( 0.23%)      95,838 ( 0.07%)     45,160 ( 0.05%)   1,585,587 ( 0.12%)       1,449 ( 0.00%)         113 ( 0.00%)  ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x
   23,888,438 ( 0.32%)      2,499 ( 0.00%)       691 ( 0.01%)  10,237,902 ( 0.56%)           0                   0            6,825,268 ( 0.51%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::derived() const
   22,381,009 ( 0.30%)        845 ( 0.00%)       351 ( 0.00%)   9,591,861 ( 0.52%)           0                   0            6,394,574 ( 0.48%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 2, 2, 1, 0>::data() const
   21,200,713 ( 0.29%)     14,439 ( 0.03%)       390 ( 0.00%)   7,810,789 ( 0.42%)           0                   0            5,579,135 ( 0.42%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 3, 1, 0, 3, 1>, 0>::operator[](long) const
   21,049,681 ( 0.28%)    150,012 ( 0.29%)     3,329 ( 0.04%)   7,576,216 ( 0.41%)     129,727 ( 0.10%)     28,512 ( 0.03%)   3,702,058 ( 0.28%)       8,617 ( 0.01%)          44 ( 0.00%)  ./malloc/./malloc/malloc.c:free
   20,489,106 ( 0.28%)        415 ( 0.00%)        41 ( 0.00%)   6,829,702 ( 0.37%)           0                   0            3,414,851 ( 0.26%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 2, 2, 1, 0>::rows()
   20,489,106 ( 0.28%)          0                  0            6,829,702 ( 0.37%)           0                   0            3,414,851 ( 0.26%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 2, 2, 1, 0>::cols()
   19,111,264 ( 0.26%)      6,150 ( 0.01%)       387 ( 0.00%)   5,620,960 ( 0.31%)           0                   0            5,620,960 ( 0.42%)           2 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::size() const
   19,063,907 ( 0.26%)     14,765 ( 0.03%)       982 ( 0.01%)   3,591,946 ( 0.20%)     205,926 ( 0.16%)     18,178 ( 0.02%)           0                    0                    0           ./string/../sysdeps/x86_64/strcmp.S:strcmp
   18,729,655 ( 0.25%)     39,768 ( 0.08%)     3,352 ( 0.04%)   7,416,230 ( 0.40%)     497,788 ( 0.39%)     74,170 ( 0.08%)     121,892 ( 0.01%)         258 ( 0.00%)           0           ???:QMetaObject::indexOfProperty(char const*) const
   16,727,297 ( 0.23%)    164,483 ( 0.32%)    19,175 ( 0.24%)   2,489,260 ( 0.14%)      33,057 ( 0.03%)      6,478 ( 0.01%)     687,614 ( 0.05%)      10,586 ( 0.01%)       2,094 ( 0.00%)  ???:QUnicodeTools::initCharAttributes(unsigned short const*, int, QUnicodeTools::ScriptItem const*, int, QCharAttributes*, QFlags<QUnicodeTools::CharAttributeOption>)
   16,251,040 ( 0.22%)         12 ( 0.00%)        12 ( 0.00%)   1,964,591 ( 0.11%)           6 ( 0.00%)          0               24,549 ( 0.00%)         257 ( 0.00%)         206 ( 0.00%)  ???:init_scan_orders()
   16,221,422 ( 0.22%)      4,079 ( 0.01%)       346 ( 0.00%)   4,634,692 ( 0.25%)           0                   0            4,634,692 ( 0.35%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::evaluator(Eigen::Matrix<double, 3, 1, 0, 3, 1> const&)
   16,119,092 ( 0.22%)     17,472 ( 0.03%)     2,569 ( 0.03%)   4,170,515 ( 0.23%)       5,613 ( 0.00%)        582 ( 0.00%)   3,614,097 ( 0.27%)          51 ( 0.00%)           0           ???:QWidgetPrivate::safeAreaMargins() const
   16,038,595 ( 0.22%)    408,224 ( 0.80%)    41,413 ( 0.52%)   4,287,646 ( 0.23%)      10,199 ( 0.01%)        643 ( 0.00%)   2,129,704 ( 0.16%)       5,962 ( 0.00%)         778 ( 0.00%)  ???:QTextLine::layout_helper(int)
   13,569,348 ( 0.18%)     10,196 ( 0.02%)       692 ( 0.01%)   3,392,337 ( 0.18%)           0                   0            4,523,116 ( 0.34%)          12 ( 0.00%)          12 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::rows() const
   13,569,348 ( 0.18%)          0                  0            3,392,337 ( 0.18%)           0                   0            4,523,116 ( 0.34%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::cols() const
   13,401,732 ( 0.18%)        563 ( 0.00%)       303 ( 0.00%)   5,584,055 ( 0.30%)           0                   0            3,350,433 ( 0.25%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >::coeff(long) const
   13,183,831 ( 0.18%)     26,534 ( 0.05%)     3,934 ( 0.05%)   3,129,517 ( 0.17%)      30,366 ( 0.02%)     14,454 ( 0.02%)     195,019 ( 0.01%)       1,468 ( 0.00%)           1 ( 0.00%)  ???:QPixmapIconEngine::tryMatch(QSize const&, QIcon::Mode, QIcon::State)
   12,745,403 ( 0.17%)      4,388 ( 0.01%)       346 ( 0.00%)   3,476,019 ( 0.19%)           0                   0            3,476,019 ( 0.26%)         313 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::evaluator_base()
   12,745,403 ( 0.17%)      3,853 ( 0.01%)       652 ( 0.01%)   3,476,019 ( 0.19%)           0                   0            3,476,019 ( 0.26%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::~evaluator()
   12,745,403 ( 0.17%)      2,109 ( 0.00%)       305 ( 0.00%)   3,476,019 ( 0.19%)           0                   0            3,476,019 ( 0.26%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::~evaluator_base()
   12,745,403 ( 0.17%)          0                  0            3,476,019 ( 0.19%)           0                   0            3,476,019 ( 0.26%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >::~evaluator()
   12,590,108 ( 0.17%)        899 ( 0.00%)       329 ( 0.00%)   1,879,189 ( 0.10%)         104 ( 0.00%)         24 ( 0.00%)   1,346,810 ( 0.10%)           0                    0           ???:QColor::toRgb() const
   12,522,311 ( 0.17%)     71,028 ( 0.14%)     4,130 ( 0.05%)   2,134,524 ( 0.12%)      12,606 ( 0.01%)        892 ( 0.00%)           0                    0                    0           ./math/../sysdeps/ieee754/dbl-64/e_hypot.c:hypot@@GLIBC_2.35
   12,235,916 ( 0.16%)    123,670 ( 0.24%)     3,307 ( 0.04%)   1,172,096 ( 0.06%)           1 ( 0.00%)          0            2,256,197 ( 0.17%)      26,167 ( 0.02%)       4,665 ( 0.00%)  ???:QArrayData::allocate(unsigned long, unsigned long, unsigned long, QFlags<QArrayData::AllocationOption>)
   11,873,397 ( 0.16%)     62,252 ( 0.12%)     5,497 ( 0.07%)   2,440,303 ( 0.13%)     305,085 ( 0.24%)     55,196 ( 0.06%)   1,837,102 ( 0.14%)       4,921 ( 0.00%)         233 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc_consolidate
   11,743,614 ( 0.16%)        341 ( 0.00%)       199 ( 0.00%)   1,995,832 ( 0.11%)     793,699 ( 0.62%)      6,893 ( 0.01%)      51,942 ( 0.00%)       3,772 ( 0.00%)           1 ( 0.00%)  ???:XGetVisualInfo
   11,590,010 ( 0.16%)      4,434 ( 0.01%)       347 ( 0.00%)   3,477,003 ( 0.19%)           0                   0            3,477,003 ( 0.26%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::data() const
   11,581,111 ( 0.16%)     24,200 ( 0.05%)     2,519 ( 0.03%)   2,549,753 ( 0.14%)      39,590 ( 0.03%)      9,684 ( 0.01%)           0                    0                    0           ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strcmp_avx2
   11,473,760 ( 0.15%)        458 ( 0.00%)        77 ( 0.00%)   2,855,851 ( 0.16%)     200,004 ( 0.16%)    179,998 ( 0.20%)   1,088,976 ( 0.08%)     215,850 ( 0.13%)     183,147 ( 0.16%)  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
   11,464,922 ( 0.15%)     95,525 ( 0.19%)     7,664 ( 0.10%)   2,303,370 ( 0.13%)      59,255 ( 0.05%)     24,600 ( 0.03%)           0                    0                    0           ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe
   11,234,621 ( 0.15%)    264,363 ( 0.52%)    22,775 ( 0.28%)   2,236,871 ( 0.12%)       2,867 ( 0.00%)        621 ( 0.00%)     578,074 ( 0.04%)       5,799 ( 0.00%)         729 ( 0.00%)  ???:QTextEngine::shapeText(int) const
   11,162,738 ( 0.15%)     92,495 ( 0.18%)     4,130 ( 0.05%)   4,516,213 ( 0.25%)     404,006 ( 0.31%)     29,339 ( 0.03%)     596,737 ( 0.04%)       2,188 ( 0.00%)         486 ( 0.00%)  ???:QCoreApplicationPrivate::sendThroughApplicationEventFilters(QObject*, QEvent*)
   10,521,152 ( 0.14%)     60,064 ( 0.12%)     1,999 ( 0.02%)   3,186,066 ( 0.17%)      55,638 ( 0.04%)     33,007 ( 0.04%)     649,115 ( 0.05%)           0                    0           ???:QWidgetPrivate::windowHandle(QWidgetPrivate::WindowHandleMode) const
   10,397,289 ( 0.14%)      2,308 ( 0.00%)       182 ( 0.00%)   3,796,079 ( 0.21%)       3,464 ( 0.00%)          1 ( 0.00%)   1,005,984 ( 0.08%)         303 ( 0.00%)           1 ( 0.00%)  ???:QCoreApplication::removePostedEvents(QObject*, int)
    9,963,485 ( 0.13%)    142,652 ( 0.28%)    11,993 ( 0.15%)   2,681,014 ( 0.15%)       1,956 ( 0.00%)        400 ( 0.00%)   1,731,307 ( 0.13%)       9,227 ( 0.01%)           0           ???:QStroker::joinPoints(double, double, QLineF const&, QStroker::LineJoinMode)
    9,583,569 ( 0.13%)        563 ( 0.00%)       280 ( 0.00%)   2,620,125 ( 0.14%)           0                   0            2,329,000 ( 0.17%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/SculptCurve.h:SculptCurve::Curve<VectorAnimationComplex::EdgeSample>::operator[](int) const
    9,562,280 ( 0.13%)          0                  0            2,390,570 ( 0.13%)           0                   0            3,585,855 ( 0.27%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::cols() const
    9,562,280 ( 0.13%)          0                  0            2,390,570 ( 0.13%)           0                   0            3,585,855 ( 0.27%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::rows() const
    9,315,999 ( 0.13%)      4,646 ( 0.01%)       445 ( 0.01%)   3,992,571 ( 0.22%)     112,813 ( 0.09%)     10,700 ( 0.01%)   1,330,857 ( 0.10%)         338 ( 0.00%)           0           ???:qstrcmp(QByteArray const&, QByteArray const&)
    9,200,520 ( 0.12%)        175 ( 0.00%)        50 ( 0.00%)   2,555,700 ( 0.14%)           0                   0            3,194,625 ( 0.24%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/SculptCurve.h:SculptCurve::Curve<VectorAnimationComplex::EdgeSample>::intersects(VectorAnimationComplex::EdgeSample&, VectorAnimationComplex::EdgeSample&, VectorAnimationComplex::EdgeSample&, VectorAnimationComplex::EdgeSample&, double&, double&, double)
    9,180,897 ( 0.12%)     14,175 ( 0.03%)     2,057 ( 0.03%)   2,782,090 ( 0.15%)       1,740 ( 0.00%)      1,332 ( 0.00%)   3,060,299 ( 0.23%)          11 ( 0.00%)           0           ???:QWidget::contentsMargins() const
    9,015,790 ( 0.12%)      2,156 ( 0.00%)       993 ( 0.01%)   2,060,752 ( 0.11%)           0                   0            2,318,346 ( 0.17%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 2, 1, 0, 2, 1>, 1>::coeffRef(long)
    9,015,314 ( 0.12%)     23,391 ( 0.05%)       826 ( 0.01%)   1,931,853 ( 0.11%)      48,624 ( 0.04%)      7,246 ( 0.01%)           0                    0                    0           ???:QWidget::testAttribute_helper(Qt::WidgetAttribute) const
    8,433,438 ( 0.11%)     40,711 ( 0.08%)     1,653 ( 0.02%)   4,856,771 ( 0.26%)     114,547 ( 0.09%)      4,185 ( 0.00%)           0                    0                    0           ???:QWidget::window() const
    8,390,002 ( 0.11%)     42,888 ( 0.08%)     4,314 ( 0.05%)   2,394,385 ( 0.13%)      56,067 ( 0.04%)      9,937 ( 0.01%)     485,787 ( 0.04%)           9 ( 0.00%)           0           ./nptl/./nptl/pthread_mutex_lock.c:pthread_mutex_lock@@GLIBC_2.2.5
    8,113,007 ( 0.11%)      2,226 ( 0.00%)       346 ( 0.00%)   3,477,003 ( 0.19%)           0                   0            2,318,002 ( 0.17%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 3, 3, 1, 0>::data() const
    8,000,509 ( 0.11%)    199,785 ( 0.39%)    18,569 ( 0.23%)   1,988,950 ( 0.11%)      10,406 ( 0.01%)      1,482 ( 0.00%)   1,095,086 ( 0.08%)      10,824 ( 0.01%)          73 ( 0.00%)  ???:QTextEngine::shapeTextWithHarfbuzzNG(QScriptItem const&, unsigned short const*, int, QFontEngine*, QVector<unsigned int> const&, bool, bool) const
    7,942,092 ( 0.11%)         84 ( 0.00%)        27 ( 0.00%)   2,019,168 ( 0.11%)           3 ( 0.00%)          0              807,648 ( 0.06%)           0                    0           ???:QColor::rgb() const
    7,561,232 ( 0.10%)        768 ( 0.00%)       142 ( 0.00%)   2,160,352 ( 0.12%)          55 ( 0.00%)         54 ( 0.00%)   1,620,264 ( 0.12%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/EdgeSample.h:VectorAnimationComplex::EdgeSample::y() const
    7,561,232 ( 0.10%)        517 ( 0.00%)       123 ( 0.00%)   2,160,352 ( 0.12%)          99 ( 0.00%)         93 ( 0.00%)   1,620,264 ( 0.12%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/EdgeSample.h:VectorAnimationComplex::EdgeSample::x() const

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/Triangles.cpp
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr         Dr                 D1mr             DLmr             Dw                 D1mw       DLmw       

-- line 18 ----------------------------------------
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           #include "../OpenGL.h"
         .            .            .                  .                .                .                  .          .          .           #include "../View3DSettings.h"
         .            .            .                  .                .                .                  .          .          .           #include <limits>
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           namespace VectorAnimationComplex
         .            .            .                  .                .                .                  .          .          .           {
         .            .            .                  .                .                .                  .          .          .           
       240 ( 0.00%)  47 ( 0.00%)  32 ( 0.00%)         0                0                0                 96 ( 0.00%) 0          0           Triangles::Triangles() :
       336 ( 0.00%)  48 ( 0.00%)  32 ( 0.00%)        96 ( 0.00%)       0                0                192 ( 0.00%) 1 ( 0.00%) 1 ( 0.00%)      triangles_()
         .            .            .                  .                .                .                  .          .          .           {
       144 ( 0.00%)   0            0                 96 ( 0.00%)       0                0                  0          0          0           }
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           bool Triangle::intersects(const Eigen::Vector2d & p) const
    16,380 ( 0.00%)  40 ( 0.00%)  20 ( 0.00%)     1,820 ( 0.00%)       0                0              7,280 ( 0.00%) 0          0           {
    54,600 ( 0.00%)  40 ( 0.00%)  40 ( 0.00%)     7,280 ( 0.00%)       0                0             10,920 ( 0.00%) 0          0               double a1 = cross(b-a,p-a);
    58,240 ( 0.00%)  40 ( 0.00%)  40 ( 0.00%)     7,280 ( 0.00%)       0                0             10,920 ( 0.00%) 0          0               double a2 = cross(c-b,p-b);
    56,420 ( 0.00%)  40 ( 0.00%)  40 ( 0.00%)     7,280 ( 0.00%)       0                0             10,920 ( 0.00%) 0          0               double a3 = cross(a-c,p-c);
         .            .            .                  .                .                .                  .          .          .           
    22,228 ( 0.00%)  20 ( 0.00%)  20 ( 0.00%)     5,972 ( 0.00%)       0                0                  0          0          0               return (a1 >= 0 && a2 >=0 && a3 >= 0) || (a1 <= 0 && a2 <=0 && a3 <= 0);
     9,100 ( 0.00%)  20 ( 0.00%)  20 ( 0.00%)     7,280 ( 0.00%)       0                0                  0          0          0           }
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           namespace
         .            .            .                  .                .                .                  .          .          .           {
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           void threeWayMinMax(double a, double b, double c, double & min, double & max)
         .            .            .                  .                .                .                  .          .          .           {
         .            .            .                  .                .                .                  .          .          .               if(a<b)
         .            .            .                  .                .                .                  .          .          .               {
-- line 46 ----------------------------------------
-- line 139 ----------------------------------------
         .            .            .                  .                .                .                  .          .          .                                        r_xMin-c[0], r_xMax-c[0], r_yMin-c[1], r_yMax-c[1],
         .            .            .                  .                .                .                  .          .          .                                        b[0]-c[0], b[1]-c[1])) return false;
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .               // In all other cases
         .            .            .                  .                .                .                  .          .          .               return true;
         .            .            .                  .                .                .                  .          .          .           }
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           bool Triangles::intersects(const Eigen::Vector2d & p) const
       360 ( 0.00%)  80 ( 0.00%)  40 ( 0.00%)        40 ( 0.00%)       0                0                160 ( 0.00%) 0          0           {
    26,200 ( 0.00%)  80 ( 0.00%)  40 ( 0.00%)       120 ( 0.00%)       0                0              7,520 ( 0.00%) 0          0               for (const Triangle & t : triangles_)
    12,740 ( 0.00%)   0            0              3,640 ( 0.00%)       0                0              1,820 ( 0.00%) 0          0                   if (t.intersects(p))
         .            .            .                  .                .                .                  .          .          .                       return true;
         .            .            .                  .                .                .                  .          .          .           
        40 ( 0.00%)   0            0                  0                0                0                  0          0          0               return false;
       200 ( 0.00%)   0            0                160 ( 0.00%)       0                0                  0          0          0           }
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           bool Triangles::intersects(const BoundingBox & bb) const
         .            .            .                  .                .                .                  .          .          .           {
         .            .            .                  .                .                .                  .          .          .               for (const Triangle & t : triangles_)
         .            .            .                  .                .                .                  .          .          .                   if (t.intersects(bb))
         .            .            .                  .                .                .                  .          .          .                       return true;
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .               return false;
-- line 161 ----------------------------------------
-- line 173 ----------------------------------------
         .            .            .                  .                .                .                  .          .          .           {
         .            .            .                  .                .                .                  .          .          .               BoundingBox bb;
         .            .            .                  .                .                .                  .          .          .               for (const Triangle & t : triangles_)
         .            .            .                  .                .                .                  .          .          .                   bb.unite(t.boundingBox());
         .            .            .                  .                .                .                  .          .          .               return bb;
         .            .            .                  .                .                .                  .          .          .           }
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           void Triangles::draw() const
    15,270 ( 0.00%) 760 ( 0.00%) 564 ( 0.01%)         0                0                0              7,635 ( 0.00%) 0          0           {
     5,090 ( 0.00%)   0            0                  0                0                0              2,545 ( 0.00%) 0          0               glBegin(GL_TRIANGLES);
 4,130,998 ( 0.06%) 435 ( 0.00%) 282 ( 0.00%) 1,373,606 ( 0.07%)       0                0            461,262 ( 0.03%) 0          0               for (unsigned int i=0; i<triangles_.size(); ++i)
         .            .            .                  .                .                .                  .          .          .               {
10,035,784 ( 0.14%) 458 ( 0.00%) 282 ( 0.00%) 3,193,204 ( 0.17%) 114,739 ( 0.09%) 113,723 ( 0.13%) 2,737,032 ( 0.20%) 0          0                   glVertex2d(triangles_[i].a[0], triangles_[i].a[1]);
10,948,128 ( 0.15%) 820 ( 0.00%) 564 ( 0.01%) 3,193,204 ( 0.17%) 113,204 ( 0.09%) 112,295 ( 0.13%) 2,737,032 ( 0.20%) 0          0                   glVertex2d(triangles_[i].b[0], triangles_[i].b[1]);
10,948,128 ( 0.15%) 416 ( 0.00%) 282 ( 0.00%) 3,193,204 ( 0.17%) 113,032 ( 0.09%) 112,111 ( 0.13%) 2,737,032 ( 0.20%) 0          0                   glVertex2d(triangles_[i].c[0], triangles_[i].c[1]);
         .            .            .                  .                .                .                  .          .          .               }
     2,545 ( 0.00%)   0            0                  0                0                0              2,545 ( 0.00%) 0          0               glEnd();
    10,180 ( 0.00%)   0            0              7,635 ( 0.00%)      41 ( 0.00%)       0                  0          0          0           }
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .           void Triangles::draw3D(Time t, View3DSettings & viewSettings) const
         .            .            .                  .                .                .                  .          .          .           {
         .            .            .                  .                .                .                  .          .          .               const double z = viewSettings.zFromT(t);
         .            .            .                  .                .                .                  .          .          .           
         .            .            .                  .                .                .                  .          .          .               glBegin (GL_TRIANGLES);
         .            .            .                  .                .                .                  .          .          .               for (unsigned int i=0; i<triangles_.size(); ++i)
         .            .            .                  .                .                .                  .          .          .               {
-- line 198 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h
--------------------------------------------------------------------------------
Ir                   I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw           DLmw        

-- line 82 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename T, typename Shape = typename evaluator_traits<T>::Shape >
          .               .              .                   .          .          .                   .              .           .           struct evaluator_assume_aliasing {
          .               .              .                   .          .          .                   .              .           .             static const bool value = false;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // By default, we assume a unary expression:
          .               .              .                   .          .          .                   .              .           .           template<typename T>
    154,407 ( 0.00%)  1,584 ( 0.00%)   872 ( 0.01%)     42,111 ( 0.00%) 0          0              42,111 ( 0.00%)     0           0           struct evaluator : public unary_evaluator<T>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef unary_evaluator<T> Base;
    196,518 ( 0.00%)  2,890 ( 0.01%) 1,634 ( 0.02%)     56,148 ( 0.00%) 0          0              56,148 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC explicit evaluator(const T& xpr) : Base(xpr) {}
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // TODO: Think about const-correctness
          .               .              .                   .          .          .                   .              .           .           template<typename T>
  2,927,903 ( 0.04%) 19,014 ( 0.04%) 2,250 ( 0.03%)    798,519 ( 0.04%) 0          0             798,519 ( 0.06%)     0           0           struct evaluator<const T>
          .               .              .                   .          .          .                   .              .           .             : evaluator<T>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC
  3,726,422 ( 0.05%) 16,587 ( 0.03%) 3,937 ( 0.05%)  1,064,692 ( 0.06%) 0          0           1,064,692 ( 0.08%)     0           0             explicit evaluator(const T& xpr) : evaluator<T>(xpr) {}
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // ---------- base class for all evaluators ----------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename ExpressionType>
101,216,456 ( 1.36%) 26,598 ( 0.05%) 4,179 ( 0.05%) 27,604,488 ( 1.50%) 0          0          27,604,488 ( 2.07%) 1,785 ( 0.00%) 51 ( 0.00%)  struct evaluator_base : public noncopyable
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             // TODO that's not very nice to have to propagate all these traits. They are currently only needed to handle outer,inner indices.
          .               .              .                   .          .          .                   .              .           .             typedef traits<ExpressionType> ExpressionTraits;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               Alignment = 0
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           };
-- line 117 ----------------------------------------
-- line 119 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .           // -------------------- Matrix and Array --------------------
          .               .              .                   .          .          .                   .              .           .           //
          .               .              .                   .          .          .                   .              .           .           // evaluator<PlainObjectBase> is a common base class for the
          .               .              .                   .          .          .                   .              .           .           // Matrix and Array evaluators.
          .               .              .                   .          .          .                   .              .           .           // Here we directly specialize evaluator. This is not really a unary expression, and it is, by definition, dense,
          .               .              .                   .          .          .                   .              .           .           // so no need for more sophisticated dispatching.
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename Derived>
 48,205,410 ( 0.65%)  1,387 ( 0.00%)   350 ( 0.00%) 13,146,930 ( 0.72%) 0          0          13,146,930 ( 0.98%)     0           0           struct evaluator<PlainObjectBase<Derived> >
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<Derived>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef PlainObjectBase<Derived> PlainObjectType;
          .               .              .                   .          .          .                   .              .           .             typedef typename PlainObjectType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .             typedef typename PlainObjectType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               IsRowMajor = PlainObjectType::IsRowMajor,
-- line 135 ----------------------------------------
-- line 146 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .               : m_data(0),
          .               .              .                   .          .          .                   .              .           .                 m_outerStride(IsVectorAtCompileTime  ? 0 
          .               .              .                   .          .          .                   .              .           .                                                      : int(IsRowMajor) ? ColsAtCompileTime 
          .               .              .                   .          .          .                   .              .           .                                                      : RowsAtCompileTime)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .             
 30,676,170 ( 0.41%)  8,632 ( 0.02%) 1,855 ( 0.02%)          0          0          0          17,529,240 ( 1.31%)    73 ( 0.00%) 34 ( 0.00%)    EIGEN_DEVICE_FUNC explicit evaluator(const PlainObjectType& m)
 57,042,510 ( 0.77%)  3,920 ( 0.01%) 1,194 ( 0.01%) 17,553,400 ( 0.95%) 0          0          17,553,400 ( 1.31%)    75 ( 0.00%) 10 ( 0.00%)      : m_data(m.data()), m_outerStride(IsVectorAtCompileTime ? 0 : m.outerStride()) 
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
 17,529,240 ( 0.24%)  1,003 ( 0.00%)   121 ( 0.00%) 13,146,930 ( 0.72%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    200,384 ( 0.00%)  1,767 ( 0.00%)   664 ( 0.01%)          0          0          0             125,240 ( 0.01%)     4 ( 0.00%)  0             CoeffReturnType coeff(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               if (IsRowMajor)
          .               .              .                   .          .          .                   .              .           .                 return m_data[row * m_outerStride.value() + col];
          .               .              .                   .          .          .                   .              .           .               else
    231,000 ( 0.00%)      0              0             102,048 ( 0.01%) 0          0              25,048 ( 0.00%)     0           0                 return m_data[row + col * m_outerStride.value()];
     75,144 ( 0.00%)      0              0              75,144 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 19,388,155 ( 0.26%)      0              0                   0          0          0          11,632,893 ( 0.87%)     0           0             CoeffReturnType coeff(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
 19,388,155 ( 0.26%)    919 ( 0.00%)   341 ( 0.00%) 11,632,893 ( 0.63%) 0          0                   0              0           0               return m_data[index];
  7,755,262 ( 0.10%)      0              0           7,755,262 ( 0.42%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
  1,229,600 ( 0.02%)  6,311 ( 0.01%)   700 ( 0.01%)          0          0          0             768,500 ( 0.06%)     0           0             Scalar& coeffRef(Index row, Index col)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               if (IsRowMajor)
          .               .              .                   .          .          .                   .              .           .                 return const_cast<Scalar*>(m_data)[row * m_outerStride.value() + col];
          .               .              .                   .          .          .                   .              .           .               else
  1,396,260 ( 0.02%)    473 ( 0.00%)   206 ( 0.00%)    619,120 ( 0.03%) 0          0             153,700 ( 0.01%)     0           0                 return const_cast<Scalar*>(m_data)[row + col * m_outerStride.value()];
    461,100 ( 0.01%)      0              0             461,100 ( 0.03%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
  1,356,475 ( 0.02%)    187 ( 0.00%)   148 ( 0.00%)          0          0          0             813,885 ( 0.06%)     0           0             Scalar& coeffRef(Index index)
          .               .              .                   .          .          .                   .              .           .             {
  1,356,475 ( 0.02%)     78 ( 0.00%)    39 ( 0.00%)    813,885 ( 0.04%) 0          0                   0              0           0               return const_cast<Scalar*>(m_data)[index];
    542,590 ( 0.01%)      0              0             542,590 ( 0.03%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
  1,896,800 ( 0.03%)  3,201 ( 0.01%)   559 ( 0.01%)          0          0          0           1,185,500 ( 0.09%)   264 ( 0.00%) 64 ( 0.00%)    PacketType packet(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               if (IsRowMajor)
          .               .              .                   .          .          .                   .              .           .                 return ploadt<PacketType, LoadMode>(m_data + row * m_outerStride.value() + col);
          .               .              .                   .          .          .                   .              .           .               else
  2,613,668 ( 0.04%)  3,780 ( 0.01%)   862 ( 0.01%)    950,256 ( 0.05%) 0          0             474,200 ( 0.04%)   123 ( 0.00%) 17 ( 0.00%)        return ploadt<PacketType, LoadMode>(m_data + row + col * m_outerStride.value());
    711,300 ( 0.01%)      0              0             711,300 ( 0.04%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
     16,992 ( 0.00%)     71 ( 0.00%)    35 ( 0.00%)          0          0          0               8,496 ( 0.00%)     0           0             PacketType packet(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
     16,992 ( 0.00%)      0              0               8,496 ( 0.00%) 0          0               2,832 ( 0.00%)     0           0               return ploadt<PacketType, LoadMode>(m_data + index);
      5,664 ( 0.00%)      0              0               5,664 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int StoreMode,typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
    272,052 ( 0.00%)  9,406 ( 0.02%)   318 ( 0.00%)          0          0          0             181,368 ( 0.01%)     0           0             void writePacket(Index row, Index col, const PacketType& x)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               if (IsRowMajor)
          .               .              .                   .          .          .                   .              .           .                 return pstoret<Scalar, PacketType, StoreMode>
          .               .              .                   .          .          .                   .              .           .           	            (const_cast<Scalar*>(m_data) + row * m_outerStride.value() + col, x);
          .               .              .                   .          .          .                   .              .           .               else
          .               .              .                   .          .          .                   .              .           .                 return pstoret<Scalar, PacketType, StoreMode>
    392,964 ( 0.01%)  4,988 ( 0.01%)   213 ( 0.00%)    151,140 ( 0.01%) 0          0              90,684 ( 0.01%)     0           0                               (const_cast<Scalar*>(m_data) + row + col * m_outerStride.value(), x);
     90,684 ( 0.00%)      0              0              90,684 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int StoreMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             void writePacket(Index index, const PacketType& x)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return pstoret<Scalar, PacketType, StoreMode>(const_cast<Scalar*>(m_data) + index, x);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
-- line 225 ----------------------------------------
-- line 228 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             // We do not need to know the outer stride for vectors
          .               .              .                   .          .          .                   .              .           .             variable_if_dynamic<Index, IsVectorAtCompileTime  ? 0 
          .               .              .                   .          .          .                   .              .           .                                                               : int(IsRowMajor) ? ColsAtCompileTime 
          .               .              .                   .          .          .                   .              .           .                                                               : RowsAtCompileTime> m_outerStride;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
 48,205,410 ( 0.65%)  6,776 ( 0.01%) 1,353 ( 0.02%) 13,146,930 ( 0.72%) 0          0          13,146,930 ( 0.98%)     0           0           struct evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
          .               .              .                   .          .          .                   .              .           .             : evaluator<PlainObjectBase<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC evaluator() {}
          .               .              .                   .          .          .                   .              .           .           
 26,293,860 ( 0.35%)  6,806 ( 0.01%) 1,123 ( 0.01%)          0          0          0          13,146,930 ( 0.98%)    25 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)
 21,911,550 ( 0.30%)      0              0           8,764,620 ( 0.48%) 0          0           4,382,310 ( 0.33%)    98 ( 0.00%)  0               : evaluator<PlainObjectBase<XprType> >(m) 
 13,146,930 ( 0.18%)      0              0           8,764,620 ( 0.48%) 0          0                   0              0           0             { }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
          .               .              .                   .          .          .                   .              .           .           struct evaluator<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
          .               .              .                   .          .          .                   .              .           .             : evaluator<PlainObjectBase<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
          .               .              .                   .          .          .                   .              .           .           
-- line 253 ----------------------------------------
-- line 256 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)
          .               .              .                   .          .          .                   .              .           .               : evaluator<PlainObjectBase<XprType> >(m) 
          .               .              .                   .          .          .                   .              .           .             { }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- Transpose --------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename ArgType>
     19,290 ( 0.00%)    691 ( 0.00%)   654 ( 0.01%)      5,144 ( 0.00%) 0          0               5,144 ( 0.00%)     0           0           struct unary_evaluator<Transpose<ArgType>, IndexBased>
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<Transpose<ArgType> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Transpose<ArgType> XprType;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               CoeffReadCost = evaluator<ArgType>::CoeffReadCost,    
          .               .              .                   .          .          .                   .              .           .               Flags = evaluator<ArgType>::Flags ^ RowMajorBit,
          .               .              .                   .          .          .                   .              .           .               Alignment = evaluator<ArgType>::Alignment
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           
     28,292 ( 0.00%)  1,850 ( 0.00%) 1,677 ( 0.02%)      7,716 ( 0.00%) 0          0               9,002 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression()) {}
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     19,880 ( 0.00%)     35 ( 0.00%)     0                   0          0          0              11,360 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
     20,864 ( 0.00%)      0              0               8,520 ( 0.00%) 0          0               2,840 ( 0.00%)     0           0               return m_argImpl.coeff(col, row);
      6,664 ( 0.00%)      0              0               5,680 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             CoeffReturnType coeff(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.coeff(index);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             Scalar& coeffRef(Index row, Index col)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.coeffRef(col, row);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      5,904 ( 0.00%)      0              0                   0          0          0               2,952 ( 0.00%)     0           0             typename XprType::Scalar& coeffRef(Index index)
          .               .              .                   .          .          .                   .              .           .             {
      5,904 ( 0.00%)      0              0               1,968 ( 0.00%) 0          0                 984 ( 0.00%)     0           0               return m_argImpl.coeffRef(index);
      1,968 ( 0.00%)      0              0               1,968 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             PacketType packet(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.template packet<LoadMode,PacketType>(col, row);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
     11,136 ( 0.00%)      0              0                   0          0          0               5,568 ( 0.00%)     0           0             PacketType packet(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
     11,136 ( 0.00%)      0              0               3,712 ( 0.00%) 0          0               1,856 ( 0.00%)     0           0               return m_argImpl.template packet<LoadMode,PacketType>(index);
      3,712 ( 0.00%)      0              0               3,712 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int StoreMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             void writePacket(Index row, Index col, const PacketType& x)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               m_argImpl.template writePacket<StoreMode,PacketType>(col, row, x);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
-- line 324 ----------------------------------------
-- line 351 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j) const { return op.template packetOp<T>(i,j); }
          .               .              .                   .          .          .                   .              .           .             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const { return op.template packetOp<T>(i); }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename Scalar,typename NullaryOp>
          .               .              .                   .          .          .                   .              .           .           struct nullary_wrapper<Scalar,NullaryOp,true,false,false>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             template <typename IndexType>
    237,390 ( 0.00%)  4,759 ( 0.01%)   346 ( 0.00%)     47,478 ( 0.00%) 0          0              94,956 ( 0.01%)    33 ( 0.00%)  0             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType=0, IndexType=0) const { return op(); }
    914,563 ( 0.01%)  6,383 ( 0.01%)    69 ( 0.00%)    211,053 ( 0.01%) 0          0             422,106 ( 0.03%)     0           0             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType=0, IndexType=0) const { return op.template packetOp<T>(); }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename Scalar,typename NullaryOp>
          .               .              .                   .          .          .                   .              .           .           struct nullary_wrapper<Scalar,NullaryOp,false,false,true>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             template <typename IndexType>
     21,312 ( 0.00%)    148 ( 0.00%)   148 ( 0.00%)      5,920 ( 0.00%) 0          0               7,104 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j=0) const { return op(i,j); }
          .               .              .                   .          .          .                   .              .           .             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j=0) const { return op.template packetOp<T>(i,j); }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // We need the following specialization for vector-only functors assigned to a runtime vector,
          .               .              .                   .          .          .                   .              .           .           // for instance, using linspace and assigning a RowVectorXd to a MatrixXd or even a row of a MatrixXd.
          .               .              .                   .          .          .                   .              .           .           // In this case, i==0 and j is used for the actual iteration.
          .               .              .                   .          .          .                   .              .           .           template<typename Scalar,typename NullaryOp>
          .               .              .                   .          .          .                   .              .           .           struct nullary_wrapper<Scalar,NullaryOp,false,true,false>
-- line 375 ----------------------------------------
-- line 447 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .               has_nullary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
          .               .              .                   .          .          .                   .              .           .               has_unary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
          .               .              .                   .          .          .                   .              .           .               has_binary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value>().template packetOp<T>(op,i);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           #endif // MSVC workaround
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename NullaryOp, typename PlainObjectType>
    754,204 ( 0.01%)  5,265 ( 0.01%)   601 ( 0.01%)    205,692 ( 0.01%) 0          0             205,692 ( 0.02%)     0           0           struct evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType> >
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<CwiseNullaryOp<NullaryOp,PlainObjectType> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef CwiseNullaryOp<NullaryOp,PlainObjectType> XprType;
          .               .              .                   .          .          .                   .              .           .             typedef typename internal::remove_all<PlainObjectType>::type PlainObjectTypeCleaned;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               CoeffReadCost = internal::functor_traits<NullaryOp>::Cost,
          .               .              .                   .          .          .                   .              .           .               
-- line 463 ----------------------------------------
-- line 464 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .               Flags = (evaluator<PlainObjectTypeCleaned>::Flags
          .               .              .                   .          .          .                   .              .           .                     &  (  HereditaryBits
          .               .              .                   .          .          .                   .              .           .                         | (functor_has_linear_access<NullaryOp>::ret  ? LinearAccessBit : 0)
          .               .              .                   .          .          .                   .              .           .                         | (functor_traits<NullaryOp>::PacketAccess    ? PacketAccessBit : 0)))
          .               .              .                   .          .          .                   .              .           .                     | (functor_traits<NullaryOp>::IsRepeatable ? 0 : EvalBeforeNestingBit),
          .               .              .                   .          .          .                   .              .           .               Alignment = AlignedMax
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           
    479,948 ( 0.01%) 12,713 ( 0.02%) 1,440 ( 0.02%)          0          0          0             274,256 ( 0.02%)    29 ( 0.00%) 12 ( 0.00%)    EIGEN_DEVICE_FUNC explicit evaluator(const XprType& n)
    685,640 ( 0.01%)  2,468 ( 0.00%) 1,322 ( 0.02%)    205,692 ( 0.01%) 0          0             205,692 ( 0.02%)    53 ( 0.00%)  0               : m_functor(n.functor()), m_wrapper()
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
    274,256 ( 0.00%)      0              0             205,692 ( 0.01%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template <typename IndexType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     79,380 ( 0.00%)    795 ( 0.00%)     0                   0          0          0              45,360 ( 0.00%)     0           0             CoeffReturnType coeff(IndexType row, IndexType col) const
          .               .              .                   .          .          .                   .              .           .             {
     90,720 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)     45,360 ( 0.00%) 0          0              11,340 ( 0.00%)     0           0               return m_wrapper(m_functor, row, col);
     34,020 ( 0.00%)      0              0              22,680 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template <typename IndexType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     34,020 ( 0.00%)  1,770 ( 0.00%) 1,069 ( 0.01%)          0          0          0              17,010 ( 0.00%)     0           0             CoeffReturnType coeff(IndexType index) const
          .               .              .                   .          .          .                   .              .           .             {
     45,360 ( 0.00%)  1,151 ( 0.00%)   391 ( 0.00%)     17,010 ( 0.00%) 0          0               5,670 ( 0.00%)     0           0               return m_wrapper(m_functor,index);
     17,010 ( 0.00%)    693 ( 0.00%)   648 ( 0.01%)     11,340 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType, typename IndexType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
    477,323 ( 0.01%)  6,306 ( 0.01%)   215 ( 0.00%)          0          0          0             272,756 ( 0.02%)     0           0             PacketType packet(IndexType row, IndexType col) const
          .               .              .                   .          .          .                   .              .           .             {
    477,323 ( 0.01%)  5,419 ( 0.01%)   454 ( 0.01%)    272,756 ( 0.01%) 0          0              68,189 ( 0.01%)     0           0               return m_wrapper.template packetOp<PacketType>(m_functor, row, col);
    136,378 ( 0.00%)      0              0             136,378 ( 0.01%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType, typename IndexType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
     12,972 ( 0.00%)    265 ( 0.00%)   152 ( 0.00%)          0          0          0               6,486 ( 0.00%)     0           0             PacketType packet(IndexType index) const
          .               .              .                   .          .          .                   .              .           .             {
     15,134 ( 0.00%)      0              0               6,486 ( 0.00%) 0          0               2,162 ( 0.00%)     0           0               return m_wrapper.template packetOp<PacketType>(m_functor, index);
      4,324 ( 0.00%)      0              0               4,324 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           protected:
          .               .              .                   .          .          .                   .              .           .             const NullaryOp m_functor;
          .               .              .                   .          .          .                   .              .           .             const internal::nullary_wrapper<CoeffReturnType,NullaryOp> m_wrapper;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- CwiseUnaryOp --------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename UnaryOp, typename ArgType>
    191,265 ( 0.00%)  5,099 ( 0.01%)   507 ( 0.01%)     51,004 ( 0.00%) 0          0              51,004 ( 0.00%)     0           0           struct unary_evaluator<CwiseUnaryOp<UnaryOp, ArgType>, IndexBased >
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<CwiseUnaryOp<UnaryOp, ArgType> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,
          .               .              .                   .          .          .                   .              .           .               
          .               .              .                   .          .          .                   .              .           .               Flags = evaluator<ArgType>::Flags
          .               .              .                   .          .          .                   .              .           .                     & (HereditaryBits | LinearAccessBit | (functor_traits<UnaryOp>::PacketAccess ? PacketAccessBit : 0)),
          .               .              .                   .          .          .                   .              .           .               Alignment = evaluator<ArgType>::Alignment
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     89,257 ( 0.00%)  2,463 ( 0.00%)   619 ( 0.01%)          0          0          0              51,004 ( 0.00%)   311 ( 0.00%)  0             explicit unary_evaluator(const XprType& op)
     89,257 ( 0.00%)    402 ( 0.00%)   380 ( 0.00%)     25,502 ( 0.00%) 0          0              25,502 ( 0.00%)     0           0               : m_functor(op.functor()), 
    140,261 ( 0.00%)  1,910 ( 0.00%)   324 ( 0.00%)     38,253 ( 0.00%) 0          0              38,253 ( 0.00%)     6 ( 0.00%)  0                 m_argImpl(op.nestedExpression()) 
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<UnaryOp>::Cost);
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     51,004 ( 0.00%)    402 ( 0.00%)   380 ( 0.00%)     38,253 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     13,792 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               8,620 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
     20,688 ( 0.00%)      0              0               6,896 ( 0.00%) 0          0               3,448 ( 0.00%)     0           0               return m_functor(m_argImpl.coeff(row, col));
      6,896 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      5,172 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             CoeffReturnType coeff(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return m_functor(m_argImpl.coeff(index));
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
    137,357 ( 0.00%)  6,434 ( 0.01%)   757 ( 0.01%)     12,487 ( 0.00%) 0          0              74,922 ( 0.01%)     0           0             PacketType packet(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
    162,331 ( 0.00%)    380 ( 0.00%)    20 ( 0.00%)     49,948 ( 0.00%) 0          0              37,461 ( 0.00%)     0           0               return m_functor.packetOp(m_argImpl.template packet<LoadMode, PacketType>(row, col));
     74,922 ( 0.00%)    828 ( 0.00%)    89 ( 0.00%)     62,435 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
      5,920 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        592 ( 0.00%) 0          0               2,960 ( 0.00%)     0           0             PacketType packet(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
      7,104 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      1,776 ( 0.00%) 0          0               1,776 ( 0.00%)     0           0               return m_functor.packetOp(m_argImpl.template packet<LoadMode, PacketType>(index));
      3,552 ( 0.00%)      0              0               2,960 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           protected:
          .               .              .                   .          .          .                   .              .           .             const UnaryOp m_functor;
          .               .              .                   .          .          .                   .              .           .             evaluator<ArgType> m_argImpl;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- CwiseTernaryOp --------------------
          .               .              .                   .          .          .                   .              .           .           
-- line 572 ----------------------------------------
-- line 657 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             evaluator<Arg2> m_arg2Impl;
          .               .              .                   .          .          .                   .              .           .             evaluator<Arg3> m_arg3Impl;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- CwiseBinaryOp --------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // this is a binary expression
          .               .              .                   .          .          .                   .              .           .           template<typename BinaryOp, typename Lhs, typename Rhs>
  1,383,877 ( 0.02%) 17,473 ( 0.03%) 1,473 ( 0.02%)    377,421 ( 0.02%) 0          0             377,421 ( 0.03%)     0           0           struct evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
          .               .              .                   .          .          .                   .              .           .             : public binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
          .               .              .                   .          .          .                   .              .           .             typedef binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> > Base;
          .               .              .                   .          .          .                   .              .           .             
  1,761,298 ( 0.02%) 35,107 ( 0.07%) 2,358 ( 0.03%)    503,228 ( 0.03%) 0          0             503,228 ( 0.04%)   127 ( 0.00%) 10 ( 0.00%)    EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr) : Base(xpr) {}
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename BinaryOp, typename Lhs, typename Rhs>
  2,390,333 ( 0.03%) 31,215 ( 0.06%) 1,815 ( 0.02%)    629,035 ( 0.03%) 0          0             629,035 ( 0.05%)     0           0           struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IndexBased>
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
          .               .              .                   .          .          .                   .              .           .               
          .               .              .                   .          .          .                   .              .           .               LhsFlags = evaluator<Lhs>::Flags,
-- line 683 ----------------------------------------
-- line 691 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .                      | (functor_traits<BinaryOp>::PacketAccess && StorageOrdersAgree && SameType ? PacketAccessBit : 0)
          .               .              .                   .          .          .                   .              .           .                      )
          .               .              .                   .          .          .                   .              .           .                   )
          .               .              .                   .          .          .                   .              .           .                ),
          .               .              .                   .          .          .                   .              .           .               Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),
          .               .              .                   .          .          .                   .              .           .               Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<Lhs>::Alignment,evaluator<Rhs>::Alignment)
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           
    880,649 ( 0.01%) 22,176 ( 0.04%) 2,127 ( 0.03%)          0          0          0             503,228 ( 0.04%)    10 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit binary_evaluator(const XprType& xpr)
    880,649 ( 0.01%)  4,584 ( 0.01%)   377 ( 0.00%)    251,614 ( 0.01%) 0          0             251,614 ( 0.02%)     0           0               : m_functor(xpr.functor()),
  1,006,456 ( 0.01%) 17,632 ( 0.03%) 1,835 ( 0.02%)    251,614 ( 0.01%) 0          0             251,614 ( 0.02%)     0           0                 m_lhsImpl(xpr.lhs()), 
  1,383,877 ( 0.02%) 15,525 ( 0.03%) 1,604 ( 0.02%)    377,421 ( 0.02%) 0          0             377,421 ( 0.03%)   113 ( 0.00%)  0                 m_rhsImpl(xpr.rhs())  
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<BinaryOp>::Cost);
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
    503,228 ( 0.01%) 13,544 ( 0.03%) 2,283 ( 0.03%)    377,421 ( 0.02%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    202,484 ( 0.00%)  1,352 ( 0.00%)   430 ( 0.01%)     16,541 ( 0.00%) 0          0             116,320 ( 0.01%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
    427,254 ( 0.01%)  4,155 ( 0.01%) 1,010 ( 0.01%)    123,858 ( 0.01%) 0          0              75,680 ( 0.01%)     0           0               return m_functor(m_lhsImpl.coeff(row, col), m_rhsImpl.coeff(row, col));
    143,017 ( 0.00%)    618 ( 0.00%)   418 ( 0.01%)     97,473 ( 0.01%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     13,096 ( 0.00%)    804 ( 0.00%)   686 ( 0.01%)      1,280 ( 0.00%) 0          0               6,696 ( 0.00%)     0           0             CoeffReturnType coeff(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
     28,160 ( 0.00%)    476 ( 0.00%)   380 ( 0.00%)      6,400 ( 0.00%) 0          0               5,120 ( 0.00%)     0           0               return m_functor(m_lhsImpl.coeff(index), m_rhsImpl.coeff(index));
      9,552 ( 0.00%)    148 ( 0.00%)    74 ( 0.00%)      6,696 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
  1,365,617 ( 0.02%) 15,613 ( 0.03%) 1,206 ( 0.02%)    124,147 ( 0.01%) 0          0             744,882 ( 0.06%)   206 ( 0.00%) 10 ( 0.00%)    PacketType packet(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
  1,738,058 ( 0.02%) 17,016 ( 0.03%) 1,031 ( 0.01%)    496,588 ( 0.03%) 0          0             372,441 ( 0.03%)     0           0               return m_functor.packetOp(m_lhsImpl.template packet<LoadMode,PacketType>(row, col),
    993,176 ( 0.01%) 21,585 ( 0.04%) 1,285 ( 0.02%)    372,441 ( 0.02%) 0          0             248,294 ( 0.02%)   112 ( 0.00%)  0                                         m_rhsImpl.template packet<LoadMode,PacketType>(row, col));
    744,882 ( 0.01%)  6,926 ( 0.01%)   266 ( 0.00%)    620,735 ( 0.03%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
     22,260 ( 0.00%)     35 ( 0.00%)    35 ( 0.00%)      2,226 ( 0.00%) 0          0              11,130 ( 0.00%)     0           0             PacketType packet(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
     28,938 ( 0.00%)     35 ( 0.00%)    35 ( 0.00%)      6,678 ( 0.00%) 0          0               6,678 ( 0.00%)     0           0               return m_functor.packetOp(m_lhsImpl.template packet<LoadMode,PacketType>(index),
     15,582 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      4,452 ( 0.00%) 0          0               4,452 ( 0.00%)     0           0                                         m_rhsImpl.template packet<LoadMode,PacketType>(index));
     13,356 ( 0.00%)    109 ( 0.00%)   109 ( 0.00%)     11,130 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           protected:
          .               .              .                   .          .          .                   .              .           .             const BinaryOp m_functor;
          .               .              .                   .          .          .                   .              .           .             evaluator<Lhs> m_lhsImpl;
          .               .              .                   .          .          .                   .              .           .             evaluator<Rhs> m_rhsImpl;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- CwiseUnaryView --------------------
-- line 744 ----------------------------------------
-- line 800 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .           // -------------------- Map --------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // FIXME perhaps the PlainObjectType could be provided by Derived::PlainObject ?
          .               .              .                   .          .          .                   .              .           .           // but that might complicate template specialization
          .               .              .                   .          .          .                   .              .           .           template<typename Derived, typename PlainObjectType>
          .               .              .                   .          .          .                   .              .           .           struct mapbase_evaluator;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename Derived, typename PlainObjectType>
     87,351 ( 0.00%)  1,842 ( 0.00%) 1,145 ( 0.01%)     23,823 ( 0.00%) 0          0              23,823 ( 0.00%)     0           0           struct mapbase_evaluator : evaluator_base<Derived>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Derived  XprType;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::PointerType PointerType;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               IsRowMajor = XprType::RowsAtCompileTime,
          .               .              .                   .          .          .                   .              .           .               ColsAtCompileTime = XprType::ColsAtCompileTime,
          .               .              .                   .          .          .                   .              .           .               CoeffReadCost = NumTraits<Scalar>::ReadCost
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           
     55,587 ( 0.00%)  5,458 ( 0.01%) 3,881 ( 0.05%)          0          0          0              31,764 ( 0.00%)    58 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit mapbase_evaluator(const XprType& map)
     39,705 ( 0.00%)  1,428 ( 0.00%) 1,333 ( 0.02%)     15,882 ( 0.00%) 0          0              15,882 ( 0.00%)     2 ( 0.00%)  0               : m_data(const_cast<PointerType>(map.data())),
     63,528 ( 0.00%)  1,282 ( 0.00%) 1,222 ( 0.02%)     15,882 ( 0.00%) 0          0              15,882 ( 0.00%)     0           0                 m_innerStride(map.innerStride()),
     87,351 ( 0.00%)  2,734 ( 0.01%) 1,072 ( 0.01%)     23,823 ( 0.00%) 0          0              23,823 ( 0.00%)    80 ( 0.00%)  0                 m_outerStride(map.outerStride())
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(evaluator<Derived>::Flags&PacketAccessBit, internal::inner_stride_at_compile_time<Derived>::ret==1),
          .               .              .                   .          .          .                   .              .           .                                   PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1);
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     31,764 ( 0.00%)    656 ( 0.00%)   615 ( 0.01%)     23,823 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     43,164 ( 0.00%)  1,714 ( 0.00%) 1,618 ( 0.02%)          0          0          0              28,776 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
     71,736 ( 0.00%)  1,136 ( 0.00%) 1,083 ( 0.01%)     31,072 ( 0.00%) 0          0               9,592 ( 0.00%)     0           0               return m_data[col * colStride() + row * rowStride()];
     26,276 ( 0.00%)      0              0              19,184 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      3,248 ( 0.00%)     21 ( 0.00%)    21 ( 0.00%)          0          0          0               1,856 ( 0.00%)     0           0             CoeffReturnType coeff(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
      3,288 ( 0.00%)      0              0               1,560 ( 0.00%) 0          0                 464 ( 0.00%)     0           0               return m_data[index * m_innerStride.value()];
      1,392 ( 0.00%)      0              0               1,392 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     28,305 ( 0.00%)  1,054 ( 0.00%)   650 ( 0.01%)          0          0          0              18,870 ( 0.00%)     0           0             Scalar& coeffRef(Index row, Index col)
          .               .              .                   .          .          .                   .              .           .             {
     44,030 ( 0.00%)    660 ( 0.00%)   616 ( 0.01%)     18,870 ( 0.00%) 0          0               6,290 ( 0.00%)     0           0               return m_data[col * colStride() + row * rowStride()];
     15,725 ( 0.00%)      0              0              12,580 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     45,115 ( 0.00%)    222 ( 0.00%)   222 ( 0.00%)          0          0          0              25,780 ( 0.00%)     0           0             Scalar& coeffRef(Index index)
          .               .              .                   .          .          .                   .              .           .             {
     42,726 ( 0.00%)      0              0              20,687 ( 0.00%) 0          0               6,445 ( 0.00%)     0           0               return m_data[index * m_innerStride.value()];
     19,335 ( 0.00%)    148 ( 0.00%)   148 ( 0.00%)     19,335 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
     14,796 ( 0.00%)    660 ( 0.00%)   621 ( 0.01%)          0          0          0               9,864 ( 0.00%)   322 ( 0.00%)  0             PacketType packet(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             {
     27,948 ( 0.00%)    988 ( 0.00%)   933 ( 0.01%)     11,508 ( 0.00%) 0          0               6,576 ( 0.00%)   298 ( 0.00%)  0               PointerType ptr = m_data + row * rowStride() + col * colStride();
          .               .              .                   .          .          .                   .              .           .               return internal::ploadt<PacketType, LoadMode>(ptr);
      8,220 ( 0.00%)      0              0               6,576 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
     28,574 ( 0.00%)    183 ( 0.00%)   109 ( 0.00%)          0          0          0              16,328 ( 0.00%)     0           0             PacketType packet(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
     28,574 ( 0.00%)     35 ( 0.00%)    35 ( 0.00%)     12,246 ( 0.00%) 0          0               8,164 ( 0.00%)     0           0               return internal::ploadt<PacketType, LoadMode>(m_data + index * m_innerStride.value());
     12,246 ( 0.00%)      0              0              12,246 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int StoreMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             void writePacket(Index row, Index col, const PacketType& x)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               PointerType ptr = m_data + row * rowStride() + col * colStride();
          .               .              .                   .          .          .                   .              .           .               return internal::pstoret<Scalar, PacketType, StoreMode>(ptr, x);
          .               .              .                   .          .          .                   .              .           .             }
-- line 876 ----------------------------------------
-- line 878 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             template<int StoreMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             void writePacket(Index index, const PacketType& x)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               internal::pstoret<Scalar, PacketType, StoreMode>(m_data + index * m_innerStride.value(), x);
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           protected:
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC
     76,680 ( 0.00%)  1,316 ( 0.00%) 1,223 ( 0.02%)     19,170 ( 0.00%) 0          0              28,755 ( 0.00%)   310 ( 0.00%)  0             inline Index rowStride() const { return XprType::IsRowMajor ? m_outerStride.value() : m_innerStride.value(); }
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC
     80,232 ( 0.00%)  1,789 ( 0.00%) 1,144 ( 0.01%)     20,354 ( 0.00%) 0          0              28,755 ( 0.00%)    12 ( 0.00%)  0             inline Index colStride() const { return XprType::IsRowMajor ? m_innerStride.value() : m_outerStride.value(); }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             PointerType m_data;
          .               .              .                   .          .          .                   .              .           .             const internal::variable_if_dynamic<Index, XprType::InnerStrideAtCompileTime> m_innerStride;
          .               .              .                   .          .          .                   .              .           .             const internal::variable_if_dynamic<Index, XprType::OuterStrideAtCompileTime> m_outerStride;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename PlainObjectType, int MapOptions, typename StrideType> 
          .               .              .                   .          .          .                   .              .           .           struct evaluator<Map<PlainObjectType, MapOptions, StrideType> >
-- line 896 ----------------------------------------
-- line 944 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- Block --------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel,
          .               .              .                   .          .          .                   .              .           .                    bool HasDirectAccess = internal::has_direct_access<ArgType>::ret> struct block_evaluator;
          .               .              .                   .          .          .                   .              .           .                    
          .               .              .                   .          .          .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel> 
     97,471 ( 0.00%)  4,168 ( 0.01%) 3,203 ( 0.04%)     26,583 ( 0.00%) 0          0              26,583 ( 0.00%)     0           0           struct evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
          .               .              .                   .          .          .                   .              .           .             : block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .             // TODO: should check for smaller packet types once we can handle multi-sized packet types
          .               .              .                   .          .          .                   .              .           .             typedef typename packet_traits<Scalar>::type PacketScalar;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
-- line 960 ----------------------------------------
-- line 988 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .               
          .               .              .                   .          .          .                   .              .           .               PacketAlignment = unpacket_traits<PacketScalar>::alignment,
          .               .              .                   .          .          .                   .              .           .               Alignment0 = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic)
          .               .              .                   .          .          .                   .              .           .                                        && (OuterStrideAtCompileTime!=0)
          .               .              .                   .          .          .                   .              .           .                                        && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % int(PacketAlignment)) == 0)) ? int(PacketAlignment) : 0,
          .               .              .                   .          .          .                   .              .           .               Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ArgType>::Alignment, Alignment0)
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .             typedef block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel> block_evaluator_type;
     97,471 ( 0.00%)  4,369 ( 0.01%) 3,557 ( 0.04%)     17,722 ( 0.00%) 0          0              35,444 ( 0.00%)    14 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& block) : block_evaluator_type(block)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     26,583 ( 0.00%)     95 ( 0.00%)    95 ( 0.00%)     17,722 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // no direct-access => dispatch to a unary evaluator
          .               .              .                   .          .          .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
     10,120 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      2,760 ( 0.00%) 0          0               2,760 ( 0.00%)     0           0           struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, /*HasDirectAccess*/ false>
          .               .              .                   .          .          .                   .              .           .             : unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .               .              .                   .          .          .                   .              .           .           
      5,520 ( 0.00%)    585 ( 0.00%)   570 ( 0.01%)          0          0          0               2,760 ( 0.00%)     6 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)
      4,600 ( 0.00%)    328 ( 0.00%)   313 ( 0.00%)      1,840 ( 0.00%) 0          0                 920 ( 0.00%)   294 ( 0.00%)  0               : unary_evaluator<XprType>(block) 
      2,760 ( 0.00%)      0              0               1,840 ( 0.00%) 0          0                   0              0           0             {}
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
     13,800 ( 0.00%)    402 ( 0.00%)   387 ( 0.00%)      3,680 ( 0.00%) 0          0               3,680 ( 0.00%)     0           0           struct unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>, IndexBased>
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .               .              .                   .          .          .                   .              .           .           
      6,736 ( 0.00%)    148 ( 0.00%)   148 ( 0.00%)          0          0          0               3,976 ( 0.00%)    22 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& block)
      7,360 ( 0.00%)    148 ( 0.00%)   148 ( 0.00%)      1,840 ( 0.00%) 0          0               1,840 ( 0.00%)     0           0               : m_argImpl(block.nestedExpression()), 
      7,360 ( 0.00%)    328 ( 0.00%)   306 ( 0.00%)      1,840 ( 0.00%) 0          0               1,840 ( 0.00%)     0           0                 m_startRow(block.startRow()), 
      7,360 ( 0.00%)    148 ( 0.00%)   148 ( 0.00%)      1,840 ( 0.00%) 0          0               1,840 ( 0.00%)     0           0                 m_startCol(block.startCol()),
      9,728 ( 0.00%)    328 ( 0.00%)   308 ( 0.00%)      2,432 ( 0.00%) 0          0               2,432 ( 0.00%)     6 ( 0.00%)  0                 m_linear_offset(InnerPanel?(XprType::IsRowMajor ? block.startRow()*block.cols() : block.startCol()*block.rows()):0)
      4,272 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      3,056 ( 0.00%) 0          0                   0              0           0             { }
          .               .              .                   .          .          .                   .              .           .            
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               RowsAtCompileTime = XprType::RowsAtCompileTime,
          .               .              .                   .          .          .                   .              .           .               ForwardLinearAccess = InnerPanel && bool(evaluator<ArgType>::Flags&LinearAccessBit)
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .            
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     19,512 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0              13,008 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .               .              .                   .          .          .                   .              .           .             { 
     41,192 ( 0.00%)    402 ( 0.00%)   387 ( 0.00%)     10,840 ( 0.00%) 0          0               6,504 ( 0.00%)     0           0               return m_argImpl.coeff(m_startRow.value() + row, m_startCol.value() + col); 
     13,008 ( 0.00%)      0              0               8,672 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      7,104 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               3,552 ( 0.00%)     0           0             CoeffReturnType coeff(Index index) const
          .               .              .                   .          .          .                   .              .           .             { 
          .               .              .                   .          .          .                   .              .           .               if (ForwardLinearAccess)
          .               .              .                   .          .          .                   .              .           .                 return m_argImpl.coeff(m_linear_offset.value() + index); 
          .               .              .                   .          .          .                   .              .           .               else
      8,288 ( 0.00%)      0              0               2,368 ( 0.00%) 0          0               1,184 ( 0.00%)     0           0                 return coeff(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
      3,552 ( 0.00%)      0              0               2,368 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             Scalar& coeffRef(Index row, Index col)
          .               .              .                   .          .          .                   .              .           .             { 
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.coeffRef(m_startRow.value() + row, m_startCol.value() + col); 
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
-- line 1056 ----------------------------------------
-- line 1066 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             PacketType packet(Index row, Index col) const 
          .               .              .                   .          .          .                   .              .           .             { 
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.template packet<LoadMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col); 
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             template<int LoadMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
      4,144 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               2,368 ( 0.00%)     0           0             PacketType packet(Index index) const 
          .               .              .                   .          .          .                   .              .           .             { 
          .               .              .                   .          .          .                   .              .           .               if (ForwardLinearAccess)
      7,104 ( 0.00%)      0              0               1,776 ( 0.00%) 0          0               1,184 ( 0.00%)     0           0                 return m_argImpl.template packet<LoadMode,PacketType>(m_linear_offset.value() + index);
          .               .              .                   .          .          .                   .              .           .               else
          .               .              .                   .          .          .                   .              .           .                 return packet<LoadMode,PacketType>(RowsAtCompileTime == 1 ? 0 : index,
          .               .              .                   .          .          .                   .              .           .                                                    RowsAtCompileTime == 1 ? index : 0);
      1,776 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      1,776 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             template<int StoreMode, typename PacketType>
          .               .              .                   .          .          .                   .              .           .             EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             void writePacket(Index row, Index col, const PacketType& x) 
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.template writePacket<StoreMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col, x); 
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .             
-- line 1089 ----------------------------------------
-- line 1105 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             const variable_if_dynamic<Index, (ArgType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;
          .               .              .                   .          .          .                   .              .           .             const variable_if_dynamic<Index, InnerPanel ? Dynamic : 0> m_linear_offset;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // TODO: This evaluator does not actually use the child evaluator; 
          .               .              .                   .          .          .                   .              .           .           // all action is via the data() as returned by the Block expression.
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel> 
     87,351 ( 0.00%)  1,532 ( 0.00%) 1,140 ( 0.01%)     23,823 ( 0.00%) 0          0              23,823 ( 0.00%)     0           0           struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, /* HasDirectAccess */ true>
          .               .              .                   .          .          .                   .              .           .             : mapbase_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>,
          .               .              .                   .          .          .                   .              .           .                                 typename Block<ArgType, BlockRows, BlockCols, InnerPanel>::PlainObject>
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .           
     47,646 ( 0.00%)  4,599 ( 0.01%) 2,817 ( 0.04%)          0          0          0              23,823 ( 0.00%)    40 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)
     39,705 ( 0.00%)    546 ( 0.00%)   524 ( 0.01%)     15,882 ( 0.00%) 0          0               7,941 ( 0.00%)   295 ( 0.00%)  0               : mapbase_evaluator<XprType, typename XprType::PlainObject>(block) 
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               // TODO: for the 3.3 release, this should be turned to an internal assertion, but let's keep it as is for the beta lifetime
     26,886 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)      7,941 ( 0.00%) 0          0               7,941 ( 0.00%)     0           0               eigen_assert(((internal::UIntPtr(block.data()) % EIGEN_PLAIN_ENUM_MAX(1,evaluator<XprType>::Alignment)) == 0) && "data is not aligned");
     23,823 ( 0.00%)    497 ( 0.00%)   408 ( 0.01%)     15,882 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- Select --------------------
          .               .              .                   .          .          .                   .              .           .           // NOTE shall we introduce a ternary_evaluator?
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // TODO enable vectorization for Select
          .               .              .                   .          .          .                   .              .           .           template<typename ConditionMatrixType, typename ThenMatrixType, typename ElseMatrixType>
-- line 1133 ----------------------------------------
-- line 1265 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             const variable_if_dynamic<Index, ArgType::RowsAtCompileTime> m_rows;
          .               .              .                   .          .          .                   .              .           .             const variable_if_dynamic<Index, ArgType::ColsAtCompileTime> m_cols;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- PartialReduxExpr --------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template< typename ArgType, typename MemberOp, int Direction>
        814 ( 0.00%)      0              0                 222 ( 0.00%) 0          0                 222 ( 0.00%)     0           0           struct evaluator<PartialReduxExpr<ArgType, MemberOp, Direction> >
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<PartialReduxExpr<ArgType, MemberOp, Direction> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef PartialReduxExpr<ArgType, MemberOp, Direction> XprType;
          .               .              .                   .          .          .                   .              .           .             typedef typename internal::nested_eval<ArgType,1>::type ArgTypeNested;
          .               .              .                   .          .          .                   .              .           .             typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;
          .               .              .                   .          .          .                   .              .           .             typedef typename ArgType::Scalar InputScalar;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .             enum {
-- line 1281 ----------------------------------------
-- line 1286 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .               CoeffReadCost = TraversalSize==Dynamic ? HugeCost
          .               .              .                   .          .          .                   .              .           .                             : TraversalSize * evaluator<ArgType>::CoeffReadCost + int(CostOpType::value),
          .               .              .                   .          .          .                   .              .           .               
          .               .              .                   .          .          .                   .              .           .               Flags = (traits<XprType>::Flags&RowMajorBit) | (evaluator<ArgType>::Flags&(HereditaryBits&(~RowMajorBit))) | LinearAccessBit,
          .               .              .                   .          .          .                   .              .           .               
          .               .              .                   .          .          .                   .              .           .               Alignment = 0 // FIXME this will need to be improved once PartialReduxExpr is vectorized
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           
        740 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)         74 ( 0.00%) 0          0                 370 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType xpr)
      1,184 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        370 ( 0.00%) 0          0                 296 ( 0.00%)     0           0               : m_arg(xpr.nestedExpression()), m_functor(xpr.functor())
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(TraversalSize==Dynamic ? HugeCost : int(CostOpType::value));
          .               .              .                   .          .          .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
        518 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        370 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      3,256 ( 0.00%)      0              0                 296 ( 0.00%) 0          0               1,776 ( 0.00%)     0           0             const Scalar coeff(Index i, Index j) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               if (Direction==Vertical)
      4,144 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        888 ( 0.00%) 0          0                 592 ( 0.00%)     0           0                 return m_functor(m_arg.col(j));
          .               .              .                   .          .          .                   .              .           .               else
          .               .              .                   .          .          .                   .              .           .                 return m_functor(m_arg.row(i));
      2,072 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      1,480 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             const Scalar coeff(Index index) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               if (Direction==Vertical)
          .               .              .                   .          .          .                   .              .           .                 return m_functor(m_arg.col(index));
          .               .              .                   .          .          .                   .              .           .               else
          .               .              .                   .          .          .                   .              .           .                 return m_functor(m_arg.row(index));
-- line 1318 ----------------------------------------
-- line 1549 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .             const variable_if_dynamic<Index, ReverseRow ? ArgType::RowsAtCompileTime : 1> m_rows;
          .               .              .                   .          .          .                   .              .           .             const variable_if_dynamic<Index, ReverseCol ? ArgType::ColsAtCompileTime : 1> m_cols;
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- Diagonal --------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           template<typename ArgType, int DiagIndex>
      5,475 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)      1,460 ( 0.00%) 0          0               1,460 ( 0.00%)     0           0           struct evaluator<Diagonal<ArgType, DiagIndex> >
          .               .              .                   .          .          .                   .              .           .             : evaluator_base<Diagonal<ArgType, DiagIndex> >
          .               .              .                   .          .          .                   .              .           .           {
          .               .              .                   .          .          .                   .              .           .             typedef Diagonal<ArgType, DiagIndex> XprType;
          .               .              .                   .          .          .                   .              .           .             
          .               .              .                   .          .          .                   .              .           .             enum {
          .               .              .                   .          .          .                   .              .           .               CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
          .               .              .                   .          .          .                   .              .           .               
          .               .              .                   .          .          .                   .              .           .               Flags = (unsigned int)(evaluator<ArgType>::Flags & (HereditaryBits | DirectAccessBit) & ~RowMajorBit) | LinearAccessBit,
          .               .              .                   .          .          .                   .              .           .               
          .               .              .                   .          .          .                   .              .           .               Alignment = 0
          .               .              .                   .          .          .                   .              .           .             };
          .               .              .                   .          .          .                   .              .           .           
      2,555 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)          0          0          0               1,460 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& diagonal)
      2,920 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)        730 ( 0.00%) 0          0                 730 ( 0.00%)     0           0               : m_argImpl(diagonal.nestedExpression()),
      4,015 ( 0.00%)      0              0               1,095 ( 0.00%) 0          0               1,095 ( 0.00%)     0           0                 m_index(diagonal.index())
      1,460 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)      1,095 ( 0.00%) 0          0                   0              0           0             { }
          .               .              .                   .          .          .                   .              .           .            
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .               .              .                   .          .          .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             CoeffReturnType coeff(Index row, Index) const
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.coeff(row + rowOffset(), row + colOffset());
-- line 1581 ----------------------------------------
-- line 1589 ----------------------------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .               .              .                   .          .          .                   .              .           .             Scalar& coeffRef(Index row, Index)
          .               .              .                   .          .          .                   .              .           .             {
          .               .              .                   .          .          .                   .              .           .               return m_argImpl.coeffRef(row + rowOffset(), row + colOffset());
          .               .              .                   .          .          .                   .              .           .             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      8,760 ( 0.00%)    365 ( 0.00%)   343 ( 0.00%)          0          0          0               5,475 ( 0.00%)     0           0             Scalar& coeffRef(Index index)
          .               .              .                   .          .          .                   .              .           .             {
     17,520 ( 0.00%)      0              0               5,475 ( 0.00%) 0          0               3,285 ( 0.00%)     0           0               return m_argImpl.coeffRef(index + rowOffset(), index + colOffset());
      5,475 ( 0.00%)      0              0               4,380 ( 0.00%) 0          0                   0              0           0             }
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           protected:
          .               .              .                   .          .          .                   .              .           .             evaluator<ArgType> m_argImpl;
          .               .              .                   .          .          .                   .              .           .             const internal::variable_if_dynamicindex<Index, XprType::DiagIndex> m_index;
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           private:
     14,235 ( 0.00%)      0              0               2,190 ( 0.00%) 0          0               4,380 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value() > 0 ? 0 : -m_index.value(); }
     12,045 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)      2,190 ( 0.00%) 0          0               3,285 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value() > 0 ? m_index.value() : 0; }
          .               .              .                   .          .          .                   .              .           .           };
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           //----------------------------------------------------------------------
          .               .              .                   .          .          .                   .              .           .           // deprecated code
          .               .              .                   .          .          .                   .              .           .           //----------------------------------------------------------------------
          .               .              .                   .          .          .                   .              .           .           
          .               .              .                   .          .          .                   .              .           .           // -------------------- EvalToTemp --------------------
-- line 1616 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/SculptCurve.h
--------------------------------------------------------------------------------
Ir                 I1mr            ILmr         Dr                 D1mr         DLmr         Dw                 D1mw         DLmw         

-- line 62 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           #include <Eigen/Core>
        .               .            .                  .            .            .                  .            .            .           #include <Eigen/LU>
        .               .            .                  .            .            .                  .            .            .           #include <Eigen/StdVector>
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           #ifndef DEFINE_STD_VECTOR_INSERTION_OPERATOR
        .               .            .                  .            .            .                  .            .            .           #define DEFINE_STD_VECTOR_INSERTION_OPERATOR
        .               .            .                  .            .            .                  .            .            .           // Defines insertion operator (<<) for std::vector, for convenience
    1,758 ( 0.00%)    122 ( 0.00%)  54 ( 0.00%)         0            0            0                879 ( 0.00%)   0            0           template<class T> std::vector<T> & operator<<(std::vector<T> & v, const T & x)
    2,344 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)     1,465 ( 0.00%)   0            0                293 ( 0.00%)   0            0           { v.push_back(x); return v; }
   18,450 ( 0.00%)      6 ( 0.00%)   0                  0            0            0              9,225 ( 0.00%)   0            0           template<class T> std::vector<T,Eigen::aligned_allocator<T> > & operator<<(std::vector<T,Eigen::aligned_allocator<T> > & v, const T & x)
   24,600 ( 0.00%)    158 ( 0.00%) 108 ( 0.00%)    15,375 ( 0.00%)   0            0              3,075 ( 0.00%)   0            0           { v.push_back(x); return v; }
        .               .            .                  .            .            .                  .            .            .           #endif
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           namespace SculptCurve
        .               .            .                  .            .            .                  .            .            .           {
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           inline bool isnan(double x)
   30,930 ( 0.00%)     32 ( 0.00%)  10 ( 0.00%)         0            0            0             12,372 ( 0.00%)   0            0           {
        .               .            .                  .            .            .                  .            .            .           #ifdef _WIN32
        .               .            .                  .            .            .                  .            .            .               return _isnan(x);
        .               .            .                  .            .            .                  .            .            .           #else
   18,558 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)     6,186 ( 0.00%)   0            0              6,186 ( 0.00%)   0            0               return std::isnan(x);
        .               .            .                  .            .            .                  .            .            .           #endif
   12,372 ( 0.00%)      0            0             12,372 ( 0.00%)   0            0                  0            0            0           }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           struct Intersection
        .               .            .                  .            .            .                  .            .            .           {
        .               .            .                  .            .            .                  .            .            .               double s, t;
      105 ( 0.00%)     14 ( 0.00%)  12 ( 0.00%)        42 ( 0.00%)   0            0                 42 ( 0.00%)   0            0               Intersection(double s, double t): s(s), t(t) {}
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               bool operator< (const Intersection & other) const
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   return s < other.s;
        .               .            .                  .            .            .                  .            .            .               }
        .               .            .                  .            .            .                  .            .            .           };
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           template<class T>
   32,218 ( 0.00%)  1,192 ( 0.00%) 188 ( 0.00%)    13,797 ( 0.00%) 187 ( 0.00%) 102 ( 0.00%)     7,349 ( 0.00%) 205 ( 0.00%) 179 ( 0.00%)  class Curve
        .               .            .                  .            .            .                  .            .            .           {
        .               .            .                  .            .            .                  .            .            .           public:
        .               .            .                  .            .            .                  .            .            .               // -------- Construction and Destruction --------
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Construct an empty curve. Optionally, specify a sampling rate
      840 ( 0.00%)    110 ( 0.00%)  22 ( 0.00%)         0            0            0                480 ( 0.00%)   0            0               Curve(double ds = 5.0) :
      720 ( 0.00%)    110 ( 0.00%)  22 ( 0.00%)       360 ( 0.00%)   0            0                360 ( 0.00%)  27 ( 0.00%)  17 ( 0.00%)          dirtyArclengths_(false), isClosed_(false), sketchInProgress_(false),
      480 ( 0.00%)      0            0                240 ( 0.00%)   0            0                240 ( 0.00%)   2 ( 0.00%)   1 ( 0.00%)          N_(10), fitterType_(QUARTIC_BEZIER_FITTER),
    4,080 ( 0.00%)    319 ( 0.00%)  58 ( 0.00%)     1,560 ( 0.00%)  29 ( 0.00%)  12 ( 0.00%)       960 ( 0.00%)  20 ( 0.00%)  13 ( 0.00%)          ds_(ds), lastDs_(-1) {}
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Construct a straight line
        .               .            .                  .            .            .                  .            .            .               Curve(const T & start, const T & end, double ds = 5.0) :
        .               .            .                  .            .            .                  .            .            .                   dirtyArclengths_(true), isClosed_(false), sketchInProgress_(false),
        .               .            .                  .            .            .                  .            .            .                   N_(20), fitterType_(QUARTIC_BEZIER_FITTER),
        .               .            .                  .            .            .                  .            .            .                   ds_(ds), lastDs_(-1)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   vertices_.push_back(start);
        .               .            .                  .            .            .                  .            .            .                   vertices_.push_back(end);
        .               .            .                  .            .            .                  .            .            .                   resample(true);
        .               .            .                  .            .            .                  .            .            .               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Reinitialize curve
       50 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)         0            0            0                 20 ( 0.00%)   0            0               void clear() {
      150 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        60 ( 0.00%)   0            0                 50 ( 0.00%)   0            0                   vertices_.clear(); arclengths_.clear(); lastDs_ = -1; dirtyArclengths_ = false; isClosed_ = false;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
       40 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   p_.clear(); // raw input from mouse
       40 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   qTemp_.clear(); // temp vertices
       30 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   clearFits_();
       30 ( 0.00%)      0            0                 20 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // must ensure that the first vertex is equal to the last
        .               .            .                  .            .            .                  .            .            .               // by default, sculpt curve never create a loop, it must be explicitly
        .               .            .                  .            .            .                  .            .            .               // created using the method below, so that it will behave as a loop
       32 ( 0.00%)      4 ( 0.00%)   0                  0            0            0                 16 ( 0.00%)   0            0               void makeLoop()
        .               .            .                  .            .            .                  .            .            .               {
       16 ( 0.00%)      0            0                  8 ( 0.00%)   0            0                  8 ( 0.00%)   0            0                   isClosed_ = true;
       24 ( 0.00%)      0            0                 16 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
      168 ( 0.00%)      0            0                  0            0            0                 84 ( 0.00%)   0            0               double epsilon() const
        .               .            .                  .            .            .                  .            .            .               {
       84 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)        42 ( 0.00%)   0            0                  0            0            0                   return 1e-6;
      126 ( 0.00%)      0            0                 84 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // -------- Sketching and Fitting --------
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               void beginSketch(double x, double y) { T v; v.setX(x); v.setY(y); beginSketch(v); }
      100 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 50 ( 0.00%)   0            0               void beginSketch(const T & vertex)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Initialization
       30 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   clear();
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // add first point
      130 ( 0.00%)      0            0                 30 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                   p_.push_back(Input(vertex,0));
       50 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        20 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   pushFirstVertex_(vertex);
        .               .            .                  .            .            .                  .            .            .           
       30 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   lastFinalS_ = 0;
       20 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   sketchInProgress_ = true;
       70 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        50 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               void continueSketch(double x, double y) { T v; v.setX(x); v.setY(y); continueSketch(v); }
    1,034 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)        94 ( 0.00%)   0            0                564 ( 0.00%)   0            0               void continueSketch(const T & vertex)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .           
      376 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       188 ( 0.00%)  94 ( 0.00%)  94 ( 0.00%)         0            0            0                   if(sketchInProgress_)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // add input point
        .               .            .                  .            .            .                  .            .            .                   //Eigen::Vector2d p(x,y);
    1,316 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       188 ( 0.00%)   0            0                376 ( 0.00%)   0            0                       double dx = vertex.x()-p_.back().p.x();
    1,316 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       188 ( 0.00%)   0            0                376 ( 0.00%)   0            0                       double dy = vertex.y()-p_.back().p.y();
      658 ( 0.00%)      0            0                188 ( 0.00%)   0            0                 94 ( 0.00%)   0            0                   double distSquared = dx*dx + dy*dy;
      658 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)        94 ( 0.00%)   0            0                  0            0            0                   if(!(distSquared>0))
        .               .            .                  .            .            .                  .            .            .                       return;
    2,162 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       564 ( 0.00%)  29 ( 0.00%)  25 ( 0.00%)       470 ( 0.00%)   0            0                   p_.push_back(Input( vertex, p_.back().s + std::sqrt(distSquared)));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // erase previous temporary data
      376 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)        94 ( 0.00%)   0            0                 94 ( 0.00%)   0            0                   qTemp_.clear();
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // compute new fit
    1,034 ( 0.00%)      0            0                282 ( 0.00%)   0            0                 94 ( 0.00%)   0            0                   if(p_.size() < (unsigned int) N_)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       // Compute fit
    1,105 ( 0.00%)    195 ( 0.00%) 130 ( 0.00%)       390 ( 0.00%)  25 ( 0.00%)  25 ( 0.00%)       195 ( 0.00%)   0            0                       Fitter * fit = fitter(fitterType_, p_, 0, static_cast<int>(p_.size()), ds_);
        .               .            .                  .            .            .                  .            .            .           
      585 ( 0.00%)      0            0                 65 ( 0.00%)   0            0                130 ( 0.00%)   0            0                       T q = vertices_.back(); // = q_[0]
      195 ( 0.00%)     65 ( 0.00%)  65 ( 0.00%)       130 ( 0.00%)   0            0                 65 ( 0.00%)   0            0                       double s = lastFinalS_;                 // = 0
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // sample from fit
        .               .            .                  .            .            .                  .            .            .                       // while we have not reached the end
   19,733 ( 0.00%)  1,704 ( 0.00%) 130 ( 0.00%)     8,195 ( 0.00%)   0            0              1,639 ( 0.00%)   0            0                       while(p_.back().s - s > ds_)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // add a new vertex
   11,018 ( 0.00%)    102 ( 0.00%)  55 ( 0.00%)     6,296 ( 0.00%)   0            0              1,574 ( 0.00%)   0            0                           s += 0.75*ds_;
   20,462 ( 0.00%)  1,574 ( 0.00%)   0              4,722 ( 0.00%)   0            0              3,148 ( 0.00%)   0            0                           q = phi_(s, fit);
    9,444 ( 0.00%)  1,574 ( 0.00%)   0              1,574 ( 0.00%)   0            0              1,574 ( 0.00%)   0            0                           qTemp_.push_back(q);
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                       // add last vertex
      585 ( 0.00%)      0            0                 65 ( 0.00%)   0            0                130 ( 0.00%)   0            0                       T lastP = p_.back().p;
      390 ( 0.00%)     65 ( 0.00%)  65 ( 0.00%)        65 ( 0.00%)   0            0                 65 ( 0.00%)   0            0                       qTemp_.push_back(lastP);
        .               .            .                  .            .            .                  .            .            .           
      585 ( 0.00%)      0            0                195 ( 0.00%)  10 ( 0.00%)  10 ( 0.00%)        65 ( 0.00%)   0            0                       delete fit;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       // compute new fitting
      609 ( 0.00%)    116 ( 0.00%)  87 ( 0.00%)       290 ( 0.00%)   2 ( 0.00%)   2 ( 0.00%)        87 ( 0.00%)   0            0                       Fitter * fit = fitter(fitterType_, p_,static_cast<int>(p_.size()) - N_, N_, ds_);
      174 ( 0.00%)     29 ( 0.00%)  29 ( 0.00%)        29 ( 0.00%)   0            0                 29 ( 0.00%)   0            0                       fits_ << fit;
        .               .            .                  .            .            .                  .            .            .           
      261 ( 0.00%)      0            0                 29 ( 0.00%)   0            0                 58 ( 0.00%)   0            0                       T q = vertices_.back();
        .               .            .                  .            .            .                  .            .            .                       //double qt = qt_.last();
       87 ( 0.00%)      0            0                 58 ( 0.00%)   0            0                 29 ( 0.00%)   0            0                       double s = lastFinalS_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // while we have not reached the end
   16,205 ( 0.00%)    274 ( 0.00%)  87 ( 0.00%)     6,740 ( 0.00%)   0            0              1,348 ( 0.00%)   0            0                       while(p_.back().s - s > ds_)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // add a new vertex
    9,233 ( 0.00%)     21 ( 0.00%)   0              5,276 ( 0.00%)   0            0              1,319 ( 0.00%)   0            0                           s += 0.75*ds_;
   17,147 ( 0.00%)  1,071 ( 0.00%)  29 ( 0.00%)     2,638 ( 0.00%)   0            0              2,638 ( 0.00%)   0            0                           q = phi_(s);
   25,061 ( 0.00%)  1,241 ( 0.00%)  58 ( 0.00%)     7,914 ( 0.00%)   0            0              2,638 ( 0.00%)   0            0                           if(s<=p_[p_.size()-N_+1].s)
        .               .            .                  .            .            .                  .            .            .                           {
      830 ( 0.00%)      0            0                166 ( 0.00%)   0            0                166 ( 0.00%)   0            0                               pushVertex_(q);
      664 ( 0.00%)      0            0                332 ( 0.00%)   0            0                166 ( 0.00%)   0            0                               lastFinalS_ = s;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                           else
        .               .            .                  .            .            .                  .            .            .                           {
    6,918 ( 0.00%)      0            0              1,153 ( 0.00%)   0            0              1,153 ( 0.00%)   0            0                               qTemp_.push_back(q);
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                           //viz_.addVertex(q[0],q[1]);
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // add last vertex
      261 ( 0.00%)      0            0                 29 ( 0.00%)   0            0                 58 ( 0.00%)   0            0                       T lastP = p_.back().p;
      174 ( 0.00%)     29 ( 0.00%)  29 ( 0.00%)        29 ( 0.00%)   0            0                 29 ( 0.00%)   0            0                       qTemp_.push_back(lastP);
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
      376 ( 0.00%)     65 ( 0.00%)  65 ( 0.00%)       188 ( 0.00%)  94 ( 0.00%)  94 ( 0.00%)        94 ( 0.00%)  17 ( 0.00%)  17 ( 0.00%)          lastDs_ = -1;
        .               .            .                  .            .            .                  .            .            .                   }
      752 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       564 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
       80 ( 0.00%)     10 ( 0.00%)   4 ( 0.00%)        10 ( 0.00%)   0            0                 30 ( 0.00%)   0            0               void endSketch()
        .               .            .                  .            .            .                  .            .            .               {
    6,058 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)        30 ( 0.00%)   0            0              1,364 ( 0.00%)   0            0                   for(T vertex : qTemp_)
    1,630 ( 0.00%)      0            0                326 ( 0.00%)   0            0                326 ( 0.00%)   0            0                       pushVertex_(vertex);
       40 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   qTemp_.clear();
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   //vertices_.insert(vertices_.end(), qTemp_.begin(), qTemp_.end());
       30 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   clearFits_();
        .               .            .                  .            .            .                  .            .            .                   //makeQuasiUniform_();
        .               .            .                  .            .            .                  .            .            .                   //computeQS_();
        .               .            .                  .            .            .                  .            .            .           
       40 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   p_.clear(); // clear raw input (used as a test to know is curve is being drawn)
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
       20 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   sketchInProgress_ = false;
       40 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   resample(true);
        .               .            .                  .            .            .                  .            .            .           
       60 ( 0.00%)     11 ( 0.00%)  10 ( 0.00%)        40 ( 0.00%)   1 ( 0.00%)   0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // -------- Sampling --------
        .               .            .                  .            .            .                  .            .            .           
   64,038 ( 0.00%)  3,761 ( 0.01%) 121 ( 0.00%)         0            0            0             32,019 ( 0.00%)   1 ( 0.00%)   0               int size() const
        .               .            .                  .            .            .                  .            .            .               {
  106,730 ( 0.00%)    243 ( 0.00%) 120 ( 0.00%)    21,346 ( 0.00%)   0            0             21,346 ( 0.00%)   0            0                   return static_cast<int>(vertices_.size() + qTemp_.size());
   32,019 ( 0.00%)      0            0             32,019 ( 0.00%)   0            0                  0            0            0               }
2,037,875 ( 0.03%)     20 ( 0.00%)  20 ( 0.00%)         0            0            0          1,164,500 ( 0.09%)   0            0               T operator[] (int i) const
        .               .            .                  .            .            .                  .            .            .               {
2,329,000 ( 0.03%)    306 ( 0.00%) 130 ( 0.00%)   582,250 ( 0.03%)   0            0            582,250 ( 0.04%)   0            0                   int k = i - static_cast<int>(vertices_.size());
  582,250 ( 0.01%)      0            0            291,125 ( 0.02%)   0            0                  0            0            0                   if(k<0)
3,478,397 ( 0.05%)      0            0            802,707 ( 0.04%)   0            0            535,138 ( 0.04%)   0            0                       return vertices_[i];
        .               .            .                  .            .            .                  .            .            .                   else
  282,672 ( 0.00%)     67 ( 0.00%)  66 ( 0.00%)    70,668 ( 0.00%)   0            0             47,112 ( 0.00%)   0            0                       return qTemp_[k];
  873,375 ( 0.01%)    170 ( 0.00%)  64 ( 0.00%)   873,375 ( 0.05%)   0            0                  0            0            0               }
      840 ( 0.00%)    160 ( 0.00%)  40 ( 0.00%)         0            0            0                420 ( 0.00%)   0            0               double arclength(int i) const
        .               .            .                  .            .            .                  .            .            .               {
      420 ( 0.00%)      0            0                140 ( 0.00%)   0            0                140 ( 0.00%)   0            0                   precomputeArclengths_();
    1,260 ( 0.00%)      0            0                420 ( 0.00%) 140 ( 0.00%) 131 ( 0.00%)       140 ( 0.00%)   0            0                   return arclengths_[i];
      420 ( 0.00%)      0            0                280 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
    2,691 ( 0.00%)    108 ( 0.00%)  88 ( 0.00%)       299 ( 0.00%)   0            0              1,196 ( 0.00%)   0            0               T start() const
        .               .            .                  .            .            .                  .            .            .               {
    2,093 ( 0.00%)    118 ( 0.00%)  98 ( 0.00%)       299 ( 0.00%)   0            0                299 ( 0.00%)   0            0                   if(size())
    2,093 ( 0.00%)      0            0                598 ( 0.00%)   0            0                299 ( 0.00%)   0            0                       return operator[](0);
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                       return T();
    1,794 ( 0.00%)    108 ( 0.00%)  98 ( 0.00%)     1,495 ( 0.00%)   0            0                  0            0            0               }
    2,709 ( 0.00%)    124 ( 0.00%)  98 ( 0.00%)       301 ( 0.00%)   0            0              1,204 ( 0.00%)   0            0               T end() const
        .               .            .                  .            .            .                  .            .            .               {
    2,107 ( 0.00%)      0            0                301 ( 0.00%)   0            0                301 ( 0.00%)   0            0                   if(size())
    3,010 ( 0.00%)      0            0                903 ( 0.00%)   0            0                602 ( 0.00%)   0            0                       return operator[](size()-1);
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                       return T();
    1,806 ( 0.00%)    112 ( 0.00%)   4 ( 0.00%)     1,505 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
   23,620 ( 0.00%)     62 ( 0.00%)  22 ( 0.00%)     9,448 ( 0.00%)  10 ( 0.00%)   7 ( 0.00%)     4,724 ( 0.00%)   0            0               double ds() const { return ds_; }
      187 ( 0.00%)      2 ( 0.00%)   1 ( 0.00%)        68 ( 0.00%)   0            0                 68 ( 0.00%)   7 ( 0.00%)   7 ( 0.00%)      void setDs(double ds) {  ds_ = ds; }
      306 ( 0.00%)     24 ( 0.00%)  22 ( 0.00%)        85 ( 0.00%)   0            0                 85 ( 0.00%)   0            0               void resample(double ds)    { setDs(ds); resample(); }
    1,375 ( 0.00%)    139 ( 0.00%)  26 ( 0.00%)       125 ( 0.00%)   0            0                625 ( 0.00%)   3 ( 0.00%)   0               void resample(bool force = false)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   // prevent resampling a curve already sampled at the same rate
      500 ( 0.00%)      0            0                125 ( 0.00%)   0            0                  0            0            0                   if(!force)
        .               .            .                  .            .            .                  .            .            .                   {
      840 ( 0.00%)     81 ( 0.00%)   3 ( 0.00%)       420 ( 0.00%)   3 ( 0.00%)   2 ( 0.00%)         0            0            0                       if(lastDs_ == ds_)
       83 ( 0.00%)     44 ( 0.00%)   3 ( 0.00%)         0            0            0                  0            0            0                           return;
        .               .            .                  .            .            .                  .            .            .                       else
       88 ( 0.00%)      0            0                 66 ( 0.00%)   0            0                 22 ( 0.00%)   0            0                           lastDs_ = ds_;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // We'll work on a linked list for fast insertion/deletion in the middle
        .               .            .                  .            .            .                  .            .            .                   typedef std::list<T,Eigen::aligned_allocator<T> > SampleList;
      126 ( 0.00%)     20 ( 0.00%)  10 ( 0.00%)         0            0            0                 42 ( 0.00%)   0            0                   SampleList samples;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // First pass: copy all non-NaN samples to the list
       84 ( 0.00%)     25 ( 0.00%)  10 ( 0.00%)        42 ( 0.00%)  12 ( 0.00%)   4 ( 0.00%)        42 ( 0.00%)   0            0                   double defaultWidth = 10;
       42 ( 0.00%)      0            0                  0            0            0                 42 ( 0.00%)   0            0                   int n = 0;
   16,874 ( 0.00%)     49 ( 0.00%)  20 ( 0.00%)     6,270 ( 0.00%)   0            0              2,146 ( 0.00%)   0            0                   for(int i=0; i<size(); ++i)
        .               .            .                  .            .            .                  .            .            .                   {
   12,372 ( 0.00%)      0            0              4,124 ( 0.00%)   0            0              2,062 ( 0.00%)   0            0                       T sample = operator[](i);
   16,496 ( 0.00%)     25 ( 0.00%)  10 ( 0.00%)         0            0            0              4,124 ( 0.00%)   0            0                       if(isnan(sample.width()))
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           sample.setWidth(defaultWidth);
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .           
   45,364 ( 0.00%)     25 ( 0.00%)  10 ( 0.00%)         0            0            0              8,248 ( 0.00%)   0            0                       if(!isnan(sample.x()) && !isnan(sample.y()))
        .               .            .                  .            .            .                  .            .            .                       {
   10,310 ( 0.00%)      0            0                  0            0            0              2,062 ( 0.00%)   0            0                           samples.push_back(sample);
    2,062 ( 0.00%)      0            0              2,062 ( 0.00%)   0            0                  0            0            0                           ++n;
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Step 1: While(n>4), Remove all (d < ds/2). Remove prelast if (dlast < ds/4)
        .               .            .                  .            .            .                  .            .            .                   //         While(n<=4), Remove all (d < eps/2), and push (eps/2 <= d < eps) to (d == eps). Remove prelast if (dlast < eps/2)
      252 ( 0.00%)      0            0                 84 ( 0.00%)   9 ( 0.00%)   4 ( 0.00%)        84 ( 0.00%)   0            0                   double halfDs = 0.5 * ds();
      252 ( 0.00%)     25 ( 0.00%)  10 ( 0.00%)        84 ( 0.00%)  12 ( 0.00%)   4 ( 0.00%)        84 ( 0.00%)   0            0                   double quarterDs = 0.25 * ds();
      210 ( 0.00%)      0            0                 42 ( 0.00%)   0            0                 84 ( 0.00%)   0            0                   double eps = epsilon();
      168 ( 0.00%)     25 ( 0.00%)  10 ( 0.00%)        84 ( 0.00%)   0            0                 42 ( 0.00%)   0            0                   double halfEps = 0.5*eps;
       84 ( 0.00%)      0            0                 42 ( 0.00%)   0            0                  0            0            0                   if(n >= 3)
        .               .            .                  .            .            .                  .            .            .                   {
      168 ( 0.00%)      0            0                  0            0            0                 84 ( 0.00%)   0            0                       typename SampleList::iterator it1 = samples.begin();
      210 ( 0.00%)     25 ( 0.00%)  10 ( 0.00%)        42 ( 0.00%)   0            0                 84 ( 0.00%)   0            0                       typename SampleList::iterator it2 = it1; ++it2;
      294 ( 0.00%)      0            0                  0            0            0                126 ( 0.00%)   0            0                       typename SampleList::iterator itLast = samples.end(); --itLast;
        .               .            .                  .            .            .                  .            .            .                       // Here is the current state of the linked list:
        .               .            .                  .            .            .                  .            .            .                       //  begin=it1  it2                          last       end
        .               .            .                  .            .            .                  .            .            .                       //        ()-->()-->()-->()-->()-->()-->()-->()------>(NULL)
   14,182 ( 0.00%)     49 ( 0.00%)  20 ( 0.00%)         0            0            0              2,020 ( 0.00%)   0            0                       while(it2 != itLast)
        .               .            .                  .            .            .                  .            .            .                       {
   23,736 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)         0            0            0              7,912 ( 0.00%)   0            0                           double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
    3,956 ( 0.00%)      0            0              1,978 ( 0.00%)   0            0                  0            0            0                           if(n<=4)
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               if(d<halfEps)
        .               .            .                  .            .            .                  .            .            .                               {
        .               .            .                  .            .            .                  .            .            .                                   it2 = samples.erase(it2);
        .               .            .                  .            .            .                  .            .            .                                   --n;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                               else
        .               .            .                  .            .            .                  .            .            .                               {
-- line 363 ----------------------------------------
-- line 366 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                                       *it2 = it1->lerp(eps/d,*it2);
        .               .            .                  .            .            .                  .            .            .                                   }
        .               .            .                  .            .            .                  .            .            .                                   ++it1;
        .               .            .                  .            .            .                  .            .            .                                   ++it2;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                           else
        .               .            .                  .            .            .                  .            .            .                           {
    5,934 ( 0.00%)     54 ( 0.00%)  20 ( 0.00%)     3,956 ( 0.00%)   0            0                  0            0            0                               if(d<halfDs)
        .               .            .                  .            .            .                  .            .            .                               {
       88 ( 0.00%)      0            0                  8 ( 0.00%)   0            0                 24 ( 0.00%)   0            0                                   it2 = samples.erase(it2);
       16 ( 0.00%)      0            0                  8 ( 0.00%)   0            0                  0            0            0                                   --n;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                               else
        .               .            .                  .            .            .                  .            .            .                               {
    5,910 ( 0.00%)      0            0                  0            0            0              1,970 ( 0.00%)   0            0                                   ++it1;
    5,910 ( 0.00%)      0            0                  0            0            0              1,970 ( 0.00%)   0            0                                   ++it2;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                       // Here is the current state of the linked list:
        .               .            .                  .            .            .                  .            .            .                       //       begin                     it1       it2=last  end
        .               .            .                  .            .            .                  .            .            .                       //        ()------->()------->()-->()------->()------>(NULL)
        .               .            .                  .            .            .                  .            .            .                       //
      462 ( 0.00%)      0            0                  0            0            0                126 ( 0.00%)   0            0                       if(it1 != samples.begin())
        .               .            .                  .            .            .                  .            .            .                       {
      504 ( 0.00%)     30 ( 0.00%)  10 ( 0.00%)         0            0            0                168 ( 0.00%)   0            0                           double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
       84 ( 0.00%)      0            0                 42 ( 0.00%)   0            0                  0            0            0                           if(n<=4)
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               if(d<halfEps)
        .               .            .                  .            .            .                  .            .            .                               {
        .               .            .                  .            .            .                  .            .            .                                   samples.erase(it1);
        .               .            .                  .            .            .                  .            .            .                                   --n;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                           else
        .               .            .                  .            .            .                  .            .            .                           {
      126 ( 0.00%)     29 ( 0.00%)  10 ( 0.00%)        84 ( 0.00%)   0            0                  0            0            0                               if(d<quarterDs)
        .               .            .                  .            .            .                  .            .            .                               {
       40 ( 0.00%)      4 ( 0.00%)   2 ( 0.00%)         4 ( 0.00%)   0            0                  8 ( 0.00%)   0            0                                   samples.erase(it1);
        4 ( 0.00%)      0            0                  4 ( 0.00%)   0            0                  0            0            0                                   --n;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Step 2: Handle trivial cases
       42 ( 0.00%)     24 ( 0.00%)   8 ( 0.00%)         0            0            0                 42 ( 0.00%)   0            0                   bool subdivide = false;
       84 ( 0.00%)      0            0                 42 ( 0.00%)   0            0                  0            0            0                   if(n<2)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       if(n == 0)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           T sample;
        .               .            .                  .            .            .                  .            .            .                           sample.setWidth(defaultWidth);
        .               .            .                  .            .            .                  .            .            .                           samples.push_back(sample);
        .               .            .                  .            .            .                  .            .            .                           ++n;
        .               .            .                  .            .            .                  .            .            .                       }
-- line 422 ----------------------------------------
-- line 428 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                       T sample3 = sample0;
        .               .            .                  .            .            .                  .            .            .                       samples.push_back(sample1);
        .               .            .                  .            .            .                  .            .            .                       ++n;
        .               .            .                  .            .            .                  .            .            .                       samples.push_back(sample2);
        .               .            .                  .            .            .                  .            .            .                       ++n;
        .               .            .                  .            .            .                  .            .            .                       samples.push_back(sample3);
        .               .            .                  .            .            .                  .            .            .                       ++n;
        .               .            .                  .            .            .                  .            .            .                   }
       84 ( 0.00%)     30 ( 0.00%)  10 ( 0.00%)        42 ( 0.00%)   0            0                  0            0            0                   else if(n == 2)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       typename SampleList::iterator it1 = samples.begin();
        .               .            .                  .            .            .                  .            .            .                       typename SampleList::iterator it2 = it1; ++it2;
        .               .            .                  .            .            .                  .            .            .                       double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
        .               .            .                  .            .            .                  .            .            .                       if(d<halfEps)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // same as n<2, we have guarantee that the last distance will be > halfEps
        .               .            .                  .            .            .                  .            .            .                           T sample0 = *it1;
-- line 444 ----------------------------------------
-- line 484 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                               {
        .               .            .                  .            .            .                  .            .            .                                   double u = (double) i / (double) (n-1);
        .               .            .                  .            .            .                  .            .            .                                   T sample = it1->lerp(u,*it2);
        .               .            .                  .            .            .                  .            .            .                                   samples.insert(it2,sample); // insert just before it2
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
       84 ( 0.00%)     66 ( 0.00%)  20 ( 0.00%)        42 ( 0.00%)   0            0                  0            0            0                   else if(n == 3)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       typename SampleList::iterator it1 = samples.begin();
        .               .            .                  .            .            .                  .            .            .                       typename SampleList::iterator it2 = it1; ++it2;
        .               .            .                  .            .            .                  .            .            .                       typename SampleList::iterator it3 = it2; ++it3;
        .               .            .                  .            .            .                  .            .            .                       // Since p1 has survived the cleaning, we know ||p1-p0|| > eps
        .               .            .                  .            .            .                  .            .            .                       double d = it1->distanceTo(*it3); // note: could use squared distance, would be more efficient
        .               .            .                  .            .            .                  .            .            .                       if(d<halfEps)
        .               .            .                  .            .            .                  .            .            .                       {
-- line 500 ----------------------------------------
-- line 517 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // we're good
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                       // In any case, since ||p1-p0|| or ||p2-p1|| can be arbitrarily large
        .               .            .                  .            .            .                  .            .            .                       subdivide = true;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                   {
       42 ( 0.00%)     25 ( 0.00%)  10 ( 0.00%)         0            0            0                 42 ( 0.00%)   0            0                       subdivide = true;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Step 3: Subdivision scheme
       84 ( 0.00%)      0            0                 42 ( 0.00%)   0            0                  0            0            0                   if(subdivide) // Note: this implies n>=3
        .               .            .                  .            .            .                  .            .            .                   {
      126 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)         0            0            0                 42 ( 0.00%)   0            0                       SampleList subdividedSamples;
       42 ( 0.00%)      0            0                  0            0            0                 42 ( 0.00%)   0            0                       bool subdivideAgain = true;
      216 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)        87 ( 0.00%)   0            0                  0            0            0                       while(subdivideAgain)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // Initialization
       45 ( 0.00%)      3 ( 0.00%)   0                  0            0            0                 45 ( 0.00%)   0            0                           subdivideAgain = false;
      180 ( 0.00%)      0            0                  0            0            0                 90 ( 0.00%)   0            0                           typename SampleList::iterator it1 = samples.begin();
      225 ( 0.00%)     23 ( 0.00%)  10 ( 0.00%)        45 ( 0.00%)   0            0                 90 ( 0.00%)   0            0                           typename SampleList::iterator it2 = it1; ++it2;
      180 ( 0.00%)      0            0                  0            0            0                 90 ( 0.00%)   0            0                           typename SampleList::iterator itEnd = samples.end();
       90 ( 0.00%)      0            0                 45 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                           typename SampleList::iterator itFirst = it1;
      225 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)        45 ( 0.00%)   0            0                 90 ( 0.00%)   0            0                           typename SampleList::iterator itLast = itEnd; --itLast;
      360 ( 0.00%)      0            0                  0            0            0                 90 ( 0.00%)   0            0                           subdividedSamples.push_back(*it1);
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                           // Main loop through list
   16,257 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)         0            0            0              2,316 ( 0.00%)   0            0                           while(it2 != itEnd)
        .               .            .                  .            .            .                  .            .            .                           {
   27,252 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)         0            0            0              9,084 ( 0.00%)   0            0                               double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
   18,168 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)     4,542 ( 0.00%)   0            0              2,271 ( 0.00%)   0            0                               if(d>ds()) // should subdivide
        .               .            .                  .            .            .                  .            .            .                               {
        .               .            .                  .            .            .                  .            .            .                                   // compute new sample using 4-point subdivision scheme [Dyn 1987]
       10 ( 0.00%)      0            0                  5 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                                   typename SampleList::iterator it0 = it1;
       35 ( 0.00%)      3 ( 0.00%)   2 ( 0.00%)        10 ( 0.00%)   0            0                  0            0            0                                   if (isClosed_ && it0 == itFirst) it0 = itLast;
       47 ( 0.00%)      3 ( 0.00%)   2 ( 0.00%)         0            0            0                  9 ( 0.00%)   0            0                                   if(it0 != itFirst) --it0;
       10 ( 0.00%)      0            0                  5 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                                   typename SampleList::iterator it3 = it2;
       35 ( 0.00%)      3 ( 0.00%)   2 ( 0.00%)        10 ( 0.00%)   0            0                  0            0            0                                   if (isClosed_ && it3 == itLast) it3 = itFirst;
       50 ( 0.00%)      3 ( 0.00%)   2 ( 0.00%)         0            0            0                 10 ( 0.00%)   0            0                                   if(it3 != itLast) ++it3;
       40 ( 0.00%)      3 ( 0.00%)   2 ( 0.00%)         0            0            0                 10 ( 0.00%)   0            0                                   T sample0 = *it0;
       40 ( 0.00%)      0            0                  0            0            0                 10 ( 0.00%)   0            0                                   T sample1 = *it1;
       40 ( 0.00%)      3 ( 0.00%)   2 ( 0.00%)         0            0            0                 10 ( 0.00%)   0            0                                   T sample2 = *it2;
       40 ( 0.00%)      0            0                  0            0            0                 10 ( 0.00%)   0            0                                   T sample3 = *it3;
        .               .            .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p0(sample0.x(),sample0.y());
        .               .            .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p1(sample1.x(),sample1.y());
        .               .            .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p2(sample2.x(),sample2.y());
        .               .            .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p3(sample3.x(),sample3.y());
       10 ( 0.00%)      3 ( 0.00%)   2 ( 0.00%)         5 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                                   double w = 0.0625; // i.e., 1/16
       10 ( 0.00%)      0            0                  5 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                                   double halfPlusW = 0.5625; // i.e., 1/2 + 1/16
        .               .            .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p = halfPlusW*(p1+p2) + w*(p0+p3);
      160 ( 0.00%)      6 ( 0.00%)   4 ( 0.00%)        10 ( 0.00%)   0            0                 25 ( 0.00%)   0            0                                   T newSample = (sample1+sample2)*halfPlusW - (sample0+sample3)*w;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                                   // insert
       25 ( 0.00%)      1 ( 0.00%)   0                  0            0            0                  5 ( 0.00%)   0            0                                   subdividedSamples.push_back(newSample);
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                                   // recurse
        5 ( 0.00%)      0            0                  0            0            0                  5 ( 0.00%)   0            0                                   subdivideAgain = true;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // insert it2 anyway
   18,168 ( 0.00%)     23 ( 0.00%)  10 ( 0.00%)         0            0            0              4,542 ( 0.00%)   0            0                               subdividedSamples.push_back(*it2);
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // advance in list
    6,813 ( 0.00%)      0            0                  0            0            0              2,271 ( 0.00%)   0            0                               ++it1;
    6,813 ( 0.00%)      0            0                  0            0            0              2,271 ( 0.00%)   0            0                               ++it2;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                           // What to do at the end
      225 ( 0.00%)      0            0                  0            0            0                 45 ( 0.00%)   0            0                           samples.swap(subdividedSamples);
      135 ( 0.00%)      0            0                  0            0            0                 45 ( 0.00%)   0            0                           subdividedSamples.clear();
        .               .            .                  .            .            .                  .            .            .                       }
      126 ( 0.00%)      0            0                  0            0            0                 42 ( 0.00%)   0            0                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Copy back the list to the vector
      168 ( 0.00%)     24 ( 0.00%)  10 ( 0.00%)        42 ( 0.00%)   0            0                 42 ( 0.00%)   0            0                   vertices_.clear();
      168 ( 0.00%)      0            0                  0            0            0                 84 ( 0.00%)   0            0                   typename SampleList::iterator itBegin = samples.begin();
      168 ( 0.00%)      0            0                  0            0            0                 84 ( 0.00%)   0            0                   typename SampleList::iterator itEnd = samples.end();
   20,970 ( 0.00%)     53 ( 0.00%)  20 ( 0.00%)        42 ( 0.00%)   0            0              4,194 ( 0.00%)   0            0                   for(typename SampleList::iterator it = itBegin; it != itEnd; ++it)
   16,440 ( 0.00%)      0            0              2,055 ( 0.00%)   0            0              4,110 ( 0.00%)   0            0                       vertices_.push_back(*it);
      126 ( 0.00%)      0            0                 42 ( 0.00%)   0            0                 42 ( 0.00%)   0            0                   setDirtyArclengths_();
      918 ( 0.00%)    140 ( 0.00%)  23 ( 0.00%)       625 ( 0.00%)   0            0                 42 ( 0.00%)   0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // directly set the curve to be the provided vertices, for instance
        .               .            .                  .            .            .                  .            .            .               // coming from another neatening algorithm or curve representation
        .               .            .                  .            .            .                  .            .            .               // keep the loopness it has before calling the function
        .               .            .                  .            .            .                  .            .            .               void setVertices(const std::vector<T,Eigen::aligned_allocator<T> > & newVertices)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   // clear but keep loopness
        .               .            .                  .            .            .                  .            .            .                   bool loopTmp = isClosed_;
-- line 606 ----------------------------------------
-- line 612 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                   setDirtyArclengths_();
        .               .            .                  .            .            .                  .            .            .               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // -------- Continuous curve --------
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Note: these functions ignore whatever is in qTemp
        .               .            .                  .            .            .                  .            .            .               //       so might be unexpected behaviour if called while drawing
        .               .            .                  .            .            .                  .            .            .           
    2,205 ( 0.00%)    406 ( 0.00%)  60 ( 0.00%)         0            0            0                882 ( 0.00%)   0            0               double length() const
        .               .            .                  .            .            .                  .            .            .               {
    1,323 ( 0.00%)      0            0                441 ( 0.00%)   0            0                441 ( 0.00%)   0            0                   precomputeArclengths_();
    2,646 ( 0.00%)      0            0                882 ( 0.00%)   8 ( 0.00%)   8 ( 0.00%)       441 ( 0.00%)   0            0                   return arclengths_.back();
    1,323 ( 0.00%)      0            0                882 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
   14,640 ( 0.00%)    682 ( 0.00%)  20 ( 0.00%)     1,464 ( 0.00%)   0            0              7,320 ( 0.00%)   0            0               T operator() (double s) const
        .               .            .                  .            .            .                  .            .            .               {
    7,320 ( 0.00%)    689 ( 0.00%)  30 ( 0.00%)     1,464 ( 0.00%)   0            0              2,928 ( 0.00%)   0            0                   std::size_t n = vertices_.size();
    2,928 ( 0.00%)      0            0              1,464 ( 0.00%)   0            0                  0            0            0                   assert(n>0);
    2,928 ( 0.00%)      0            0              1,464 ( 0.00%)   0            0                  0            0            0                   if(n == 1)
        .               .            .                  .            .            .                  .            .            .                       return vertices_.front();
        .               .            .                  .            .            .                  .            .            .                   else
   10,248 ( 0.00%)    489 ( 0.00%)  30 ( 0.00%)     4,392 ( 0.00%)   0            0              1,464 ( 0.00%)   0            0                       return interpolatedVertex_(s);
    8,784 ( 0.00%)    689 ( 0.00%)  30 ( 0.00%)     7,320 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // -------- Apply affine transform --------
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               Curve<T> transformed(const Eigen::Affine2d & xf)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   Curve<T> res(*this);
        .               .            .                  .            .            .                  .            .            .                   res.transform(xf);
-- line 642 ----------------------------------------
-- line 667 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       vertices_[i].setX(vertices_[i].x() + dx);
        .               .            .                  .            .            .                  .            .            .                       vertices_[i].setY(vertices_[i].y() + dy);
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // return -1 if no vertices
        .               .            .                  .            .            .                  .            .            .               struct ClosestVertex { int i; double d; };
    1,540 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)       140 ( 0.00%)   0            0                840 ( 0.00%)   0            0               ClosestVertex findClosestVertex(double x, double y) const
        .               .            .                  .            .            .                  .            .            .               {
      280 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)       140 ( 0.00%)  20 ( 0.00%)  20 ( 0.00%)       140 ( 0.00%)   0            0                   double minD2 = std::numeric_limits<double>::max();
      140 ( 0.00%)      0            0                  0            0            0                140 ( 0.00%)   0            0                   int i = -1;
      280 ( 0.00%)      0            0                140 ( 0.00%)   0            0                140 ( 0.00%)   0            0                   int minI = i;
  107,420 ( 0.00%)     60 ( 0.00%)  60 ( 0.00%)       420 ( 0.00%)   0            0             24,120 ( 0.00%)   0            0                   for(auto v: vertices_)
        .               .            .                  .            .            .                  .            .            .                   {
    5,820 ( 0.00%)      0            0              5,820 ( 0.00%)   0            0                  0            0            0                       ++i;
   40,740 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)     5,820 ( 0.00%)   0            0             11,640 ( 0.00%)   0            0                       double dx = x-v.x();
   40,740 ( 0.00%)      0            0              5,820 ( 0.00%)   0            0             11,640 ( 0.00%)   0            0                       double dy = y-v.y();
   40,740 ( 0.00%)      0            0             11,640 ( 0.00%)   0            0              5,820 ( 0.00%)   0            0                       double d2 = dx*dx + dy*dy;
   17,460 ( 0.00%)      0            0             11,640 ( 0.00%)   0            0                  0            0            0                       if(d2<minD2)
        .               .            .                  .            .            .                  .            .            .                       {
    2,918 ( 0.00%)      0            0              1,459 ( 0.00%)   0            0              1,459 ( 0.00%)   0            0                           minD2 = d2;
    2,918 ( 0.00%)      0            0              1,459 ( 0.00%)   0            0              1,459 ( 0.00%)   0            0                           minI = i;
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
      980 ( 0.00%)      0            0                280 ( 0.00%)   0            0                420 ( 0.00%)   0            0                   ClosestVertex res = { minI, sqrt(minD2) };
    1,120 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)       280 ( 0.00%)   0            0                  0            0            0                   return res;
      980 ( 0.00%)      0            0                700 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               double prepareSculpt(double x, double y, double radius)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   ClosestVertex v = findClosestVertex(x,y);
        .               .            .                  .            .            .                  .            .            .                   sculptIndex_ = v.i;
        .               .            .                  .            .            .                  .            .            .                   sculptRadius_ = radius;
        .               .            .                  .            .            .                  .            .            .                   return v.d;
        .               .            .                  .            .            .                  .            .            .               }
-- line 702 ----------------------------------------
-- line 1005 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               //void beginSculptDeform()
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // -------- Intersections --------
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // helper method: returns det(U,V)
      336 ( 0.00%)      5 ( 0.00%)   1 ( 0.00%)         0            0            0                240 ( 0.00%)   0            0               inline static double det(double ux, double uy,
        .               .            .                  .            .            .                  .            .            .                                        double vx, double vy)
        .               .            .                  .            .            .                  .            .            .               {
      288 ( 0.00%)      7 ( 0.00%)   6 ( 0.00%)       192 ( 0.00%)   0            0                  0            0            0                   return ux*vy - uy*vx;
      144 ( 0.00%)      0            0                 96 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // helper method: returns whether the segments [AB] and [CD] intersect, with a margin of error epsilon
        .               .            .                  .            .            .                  .            .            .               //                if yes, the intersection P is P = A + u * (B-A) = C + v * (D-C)
1,788,990 ( 0.02%)    118 ( 0.00%)  20 ( 0.00%)         0            0            0          1,405,635 ( 0.11%)   0            0               inline static bool intersects(
        .               .            .                  .            .            .                  .            .            .                       // input
        .               .            .                  .            .            .                  .            .            .                       double ax, double ay,
        .               .            .                  .            .            .                  .            .            .                       double bx, double by,
        .               .            .                  .            .            .                  .            .            .                       double cx, double cy,
        .               .            .                  .            .            .                  .            .            .                       double dx, double dy,
        .               .            .                  .            .            .                  .            .            .                       // output
        .               .            .                  .            .            .                  .            .            .                       double & u, double & v,
        .               .            .                  .            .            .                  .            .            .                       // parameters
        .               .            .                  .            .            .                  .            .            .                       double epsilon = 1e-10)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   // fast pruning. In if size screen > 100 * ds, then in > 98% of the time, 4 assignments and <= 4 comparisons
        .               .            .                  .            .            .                  .            .            .                   double minABx, maxABx;
  965,974 ( 0.01%)     28 ( 0.00%)   6 ( 0.00%)   511,140 ( 0.03%)   0            0            255,570 ( 0.02%)   0            0                   if(ax < bx)    { minABx = ax; maxABx = bx; } else { minABx = bx; maxABx = ax; }
        .               .            .                  .            .            .                  .            .            .                   double minCDx, maxCDx;
  957,970 ( 0.01%)     62 ( 0.00%)   9 ( 0.00%)   511,140 ( 0.03%)   0            0            255,570 ( 0.02%)   0            0                   if(cx < dx)    { minCDx = cx; maxCDx = dx; } else { minCDx = dx; maxCDx = cx; }
  497,271 ( 0.01%)     28 ( 0.00%)   5 ( 0.00%)   331,514 ( 0.02%)   0            0                  0            0            0                   if(minABx > maxCDx || minCDx > maxABx)
  252,426 ( 0.00%)      0            0                  0            0            0                  0            0            0                       return false;
        .               .            .                  .            .            .                  .            .            .                   // in > 99.98% of the time, <= 8 assignments and <= 8 comparisons
        .               .            .                  .            .            .                  .            .            .                   double minABy, maxABy;
   12,176 ( 0.00%)     23 ( 0.00%)  10 ( 0.00%)     6,288 ( 0.00%)   0            0              3,144 ( 0.00%)   0            0                   if(ay < by)    { minABy = ay; maxABy = by; } else { minABy = by; maxABy = ay; }
        .               .            .                  .            .            .                  .            .            .                   double minCDy, maxCDy;
   11,961 ( 0.00%)     23 ( 0.00%)  10 ( 0.00%)     6,288 ( 0.00%)   0            0              3,144 ( 0.00%)   0            0                   if(cy < dy)    { minCDy = cy; maxCDy = dy; } else { minCDy = dy; maxCDy = cy; }
    6,216 ( 0.00%)     14 ( 0.00%)   7 ( 0.00%)     4,144 ( 0.00%)   0            0                  0            0            0                   if(minABy > maxCDy || minCDy > maxABy)
    3,112 ( 0.00%)      9 ( 0.00%)   3 ( 0.00%)         0            0            0                  0            0            0                       return false;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // actual computation
      256 ( 0.00%)      7 ( 0.00%)   6 ( 0.00%)       128 ( 0.00%)   0            0                 32 ( 0.00%)   0            0                   double det_ = det(bx-ax, by-ay, dx-cx, dy-cy); // det(AB,CD)
      256 ( 0.00%)     14 ( 0.00%)  12 ( 0.00%)       128 ( 0.00%)   0            0                 32 ( 0.00%)   0            0                   double numU = det(dx-cx, dy-cy, ax-cx, ay-cy); // det(CD,AC)
      256 ( 0.00%)      7 ( 0.00%)   6 ( 0.00%)       128 ( 0.00%)   0            0                 32 ( 0.00%)   0            0                   double numV = det(bx-ax, by-ay, ax-cx, ay-cy); // det(AB,AC)
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // if parallel
      128 ( 0.00%)      0            0                 32 ( 0.00%)   0            0                 16 ( 0.00%)   0            0                   if(std::abs(det_) < epsilon)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       return false; // consider not intersecting if nearly parallel, by design.
        .               .            .                  .            .            .                  .            .            .                                     // if you consider changing this, make sure to think about it
        .               .            .                  .            .            .                  .            .            .                                     // full-time during at least one month. If you still think
        .               .            .                  .            .            .                  .            .            .                                     // it is a good idea, then implement it. Then revert your changes
        .               .            .                  .            .            .                  .            .            .                                     // when you realize how big this mistake was. Trust me, you will.
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                   {
       48 ( 0.00%)      7 ( 0.00%)   6 ( 0.00%)        32 ( 0.00%)   6 ( 0.00%)   6 ( 0.00%)        16 ( 0.00%)   0            0                       double invDet = 1/det_;
       64 ( 0.00%)      0            0                 48 ( 0.00%)   0            0                 16 ( 0.00%)   0            0                       u = numU * invDet;
       64 ( 0.00%)      0            0                 48 ( 0.00%)   0            0                 16 ( 0.00%)   0            0                       v = numV * invDet;
      406 ( 0.00%)     14 ( 0.00%)  12 ( 0.00%)       232 ( 0.00%)   0            0                  0            0            0                       if(u>=-epsilon && u<1+epsilon && v>=-epsilon && v<1+epsilon)
       14 ( 0.00%)      0            0                  0            0            0                  0            0            0                          return true;
        .               .            .                  .            .            .                  .            .            .                       else
        9 ( 0.00%)      0            0                  0            0            0                  0            0            0                          return false;
        .               .            .                  .            .            .                  .            .            .                   }
  255,570 ( 0.00%)     57 ( 0.00%)  10 ( 0.00%)   255,570 ( 0.01%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .               // helper method provided for convenience:
        .               .            .                  .            .            .                  .            .            .               //                returns whether the segments [AB] and [CD] intersect, with a margin of error epsilon
        .               .            .                  .            .            .                  .            .            .               //                if yes, the intersection P is P = A + u * (B-A) = C + v * (D-C)
2,044,560 ( 0.03%)     38 ( 0.00%)  20 ( 0.00%)         0            0            0          1,661,205 ( 0.12%)   0            0               inline static bool intersects(
        .               .            .                  .            .            .                  .            .            .                       // input
        .               .            .                  .            .            .                  .            .            .                       T & a, T & b,
        .               .            .                  .            .            .                  .            .            .                       T & c, T & d,
        .               .            .                  .            .            .                  .            .            .                       // output
        .               .            .                  .            .            .                  .            .            .                       double & u, double & v,
        .               .            .                  .            .            .                  .            .            .                       // parameters
        .               .            .                  .            .            .                  .            .            .                       double epsilon = 1e-10)
        .               .            .                  .            .            .                  .            .            .               {
6,133,680 ( 0.08%)    137 ( 0.00%)  30 ( 0.00%) 1,661,205 ( 0.09%)   0            0          1,533,420 ( 0.11%)   0            0                   return intersects(a.x(), a.y(),
        .               .            .                  .            .            .                  .            .            .                                     b.x(), b.y(),
        .               .            .                  .            .            .                  .            .            .                                     c.x(), c.y(),
        .               .            .                  .            .            .                  .            .            .                                     d.x(), d.y(),
        .               .            .                  .            .            .                  .            .            .                                     u, v,
        .               .            .                  .            .            .                  .            .            .                                     epsilon);
1,022,280 ( 0.01%)      0            0            894,495 ( 0.05%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Compute unclean intersections.
        .               .            .                  .            .            .                  .            .            .               // May have duplicates. May miss some if segments nearly parallel.
        .               .            .                  .            .            .                  .            .            .               // Includes "virtual intersections": when extending the end of the curve by tolerance would create a new intersection.
        .               .            .                  .            .            .                  .            .            .               // Return value not sorted.
      588 ( 0.00%)     98 ( 0.00%)  18 ( 0.00%)        49 ( 0.00%)   0            0                343 ( 0.00%)   0            0               std::vector<Intersection> intersections(const SculptCurve::Curve<T> & other, double tolerance = 15.0) const
        .               .            .                  .            .            .                  .            .            .               {
      147 ( 0.00%)      0            0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   precomputeArclengths_();
      147 ( 0.00%)      0            0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   other.precomputeArclengths_();
        .               .            .                  .            .            .                  .            .            .           
      147 ( 0.00%)      0            0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   std::vector<Intersection> res;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Returns in trivial cases
      196 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)        49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   int n = size();
      196 ( 0.00%)      0            0                 49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   int nOther = other.size();
      196 ( 0.00%)      0            0                 98 ( 0.00%)   0            0                  0            0            0                   if(n<2 || nOther<2)
        .               .            .                  .            .            .                  .            .            .                       return res;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // store min/max
      245 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)        49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   double l = length();
      245 ( 0.00%)      0            0                 49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   double lOther = other.length();
       98 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)        49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   double minS = l;
       98 ( 0.00%)      0            0                  0            0            0                 49 ( 0.00%)   0            0                   double maxS = 0;
       98 ( 0.00%)      0            0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   double minT = lOther;
       98 ( 0.00%)      0            0                  0            0            0                 49 ( 0.00%)   0            0                   double maxT = 0;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   double u, v;
   11,679 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)     6,929 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   for(int i=0; i<n-1; ++i)
        .               .            .                  .            .            .                  .            .            .                   {
   13,662 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)     4,554 ( 0.00%)   0            0              2,277 ( 0.00%)   0            0                       T va = (*this)[i];
   15,939 ( 0.00%)      0            0              4,554 ( 0.00%)   0            0              2,277 ( 0.00%)   0            0                       T vb = (*this)[i+1];
  529,007 ( 0.01%)     98 ( 0.00%)  18 ( 0.00%)   313,761 ( 0.02%)   0            0              2,277 ( 0.00%)   0            0                       for(int j=0; j<nOther-1; ++j)
        .               .            .                  .            .            .                  .            .            .                       {
  618,414 ( 0.01%)      0            0            206,138 ( 0.01%)   0            0            103,069 ( 0.01%)   0            0                           T vc = other[j];
  721,483 ( 0.01%)     49 ( 0.00%)   9 ( 0.00%)   206,138 ( 0.01%)   0            0            103,069 ( 0.01%)   0            0                           T vd = other[j+1];
        .               .            .                  .            .            .                  .            .            .           
1,133,759 ( 0.02%)      0            0            103,069 ( 0.01%)   0            0            206,138 ( 0.02%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
  206,138 ( 0.00%)     42 ( 0.00%)   9 ( 0.00%)   103,069 ( 0.01%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
       84 ( 0.00%)      6 ( 0.00%)   6 ( 0.00%)        33 ( 0.00%)   0            0                 15 ( 0.00%)   0            0                               double s = (1-u)*arclengths_[i] + u*arclengths_[i+1];
       84 ( 0.00%)      6 ( 0.00%)   6 ( 0.00%)        33 ( 0.00%)   0            0                 15 ( 0.00%)   0            0                               double t = (1-v)*other.arclengths_[j] + v*other.arclengths_[j+1];
       36 ( 0.00%)      3 ( 0.00%)   3 ( 0.00%)         9 ( 0.00%)   0            0                  6 ( 0.00%)   0            0                               res.push_back(Intersection(s,t));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // update min/max
        9 ( 0.00%)      3 ( 0.00%)   3 ( 0.00%)         6 ( 0.00%)   0            0                  0            0            0                               if(s<minS)
        6 ( 0.00%)      0            0                  3 ( 0.00%)   0            0                  3 ( 0.00%)   0            0                                   minS = s;
        9 ( 0.00%)      0            0                  6 ( 0.00%)   0            0                  0            0            0                               if(s>maxS)
        6 ( 0.00%)      0            0                  3 ( 0.00%)   0            0                  3 ( 0.00%)   0            0                                   maxS = s;
        9 ( 0.00%)      0            0                  6 ( 0.00%)   0            0                  0            0            0                               if(t<minT)
        6 ( 0.00%)      0            0                  3 ( 0.00%)   0            0                  3 ( 0.00%)   0            0                                   minT = t;
        9 ( 0.00%)      0            0                  6 ( 0.00%)   0            0                  0            0            0                               if(t>maxT)
        6 ( 0.00%)      0            0                  3 ( 0.00%)   0            0                  3 ( 0.00%)   0            0                                   maxT = t;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Compute endpoints intersections
      377 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)       190 ( 0.00%)   0            0                  0            0            0                   if(minS > tolerance && !isClosed_) // start of this
        .               .            .                  .            .            .                  .            .            .                   {
      414 ( 0.00%)     46 ( 0.00%)   8 ( 0.00%)        46 ( 0.00%)   0            0                 92 ( 0.00%)   0            0                       T va = vertices_.front();
      322 ( 0.00%)      0            0                 92 ( 0.00%)   0            0                 46 ( 0.00%)   0            0                       T ve = (*this)(tolerance);
      368 ( 0.00%)     46 ( 0.00%)   8 ( 0.00%)        46 ( 0.00%)   0            0                 46 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
   10,741 ( 0.00%)     16 ( 0.00%)   8 ( 0.00%)     6,371 ( 0.00%)   0            0                 46 ( 0.00%)   0            0                       for(int j=0; j<nOther-1; ++j)
        .               .            .                  .            .            .                  .            .            .                       {
   12,558 ( 0.00%)      0            0              4,186 ( 0.00%)   0            0              2,093 ( 0.00%)   0            0                           T vc = other[j];
   14,651 ( 0.00%)     46 ( 0.00%)   8 ( 0.00%)     4,186 ( 0.00%)   0            0              2,093 ( 0.00%)   0            0                           T vd = other[j+1];
        .               .            .                  .            .            .                  .            .            .           
   23,023 ( 0.00%)     46 ( 0.00%)   8 ( 0.00%)     2,093 ( 0.00%)   0            0              4,186 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
    4,186 ( 0.00%)      0            0              2,093 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
        4 ( 0.00%)      0            0                  0            0            0                  2 ( 0.00%)   0            0                               double s = 0;
       56 ( 0.00%)      6 ( 0.00%)   6 ( 0.00%)        22 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                               double t = (1-v)*other.arclengths_[j] + v*other.arclengths_[j+1];
       24 ( 0.00%)      2 ( 0.00%)   2 ( 0.00%)         6 ( 0.00%)   0            0                  4 ( 0.00%)   0            0                               res.push_back(Intersection(s,t));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // update min/max
        6 ( 0.00%)      0            0                  4 ( 0.00%)   0            0                  0            0            0                               if(s<minS)
        4 ( 0.00%)      0            0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   minS = s;
        6 ( 0.00%)      0            0                  4 ( 0.00%)   0            0                  0            0            0                               if(s>maxS)
        .               .            .                  .            .            .                  .            .            .                                   maxS = s;
        6 ( 0.00%)      2 ( 0.00%)   2 ( 0.00%)         4 ( 0.00%)   0            0                  0            0            0                               if(t<minT)
        4 ( 0.00%)      0            0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   minT = t;
        6 ( 0.00%)      0            0                  4 ( 0.00%)   0            0                  0            0            0                               if(t>maxT)
        4 ( 0.00%)      0            0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   maxT = t;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
      441 ( 0.00%)     43 ( 0.00%)  10 ( 0.00%)       245 ( 0.00%)   0            0                  0            0            0                   if(maxS < l-tolerance && !isClosed_) // end of this
        .               .            .                  .            .            .                  .            .            .                   {
      441 ( 0.00%)     46 ( 0.00%)   9 ( 0.00%)        49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                       T va = vertices_.back();
      441 ( 0.00%)      0            0                147 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                       T ve = (*this)(l-tolerance);
      392 ( 0.00%)     31 ( 0.00%)   9 ( 0.00%)        49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
   11,889 ( 0.00%)     43 ( 0.00%)   9 ( 0.00%)     7,055 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                       for(int j=0; j<nOther-1; ++j)
        .               .            .                  .            .            .                  .            .            .                       {
   13,914 ( 0.00%)      9 ( 0.00%)   9 ( 0.00%)     4,638 ( 0.00%)   0            0              2,319 ( 0.00%)   0            0                           T vc = other[j];
   16,233 ( 0.00%)      0            0              4,638 ( 0.00%)   0            0              2,319 ( 0.00%)   0            0                           T vd = other[j+1];
        .               .            .                  .            .            .                  .            .            .           
   25,509 ( 0.00%)     36 ( 0.00%)   9 ( 0.00%)     2,319 ( 0.00%)   0            0              4,638 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
    4,638 ( 0.00%)      0            0              2,319 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               double s = l;
        .               .            .                  .            .            .                  .            .            .                               double t = (1-v)*other.arclengths_[j] + v*other.arclengths_[j+1];
        .               .            .                  .            .            .                  .            .            .                               res.push_back(Intersection(s,t));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // update min/max
        .               .            .                  .            .            .                  .            .            .                               if(s<minS)
        .               .            .                  .            .            .                  .            .            .                                   minS = s;
-- line 1198 ----------------------------------------
-- line 1200 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                                   maxS = s;
        .               .            .                  .            .            .                  .            .            .                               if(t<minT)
        .               .            .                  .            .            .                  .            .            .                                   minT = t;
        .               .            .                  .            .            .                  .            .            .                               if(t>maxT)
        .               .            .                  .            .            .                  .            .            .                                   maxT = t;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
      392 ( 0.00%)     49 ( 0.00%)   9 ( 0.00%)       196 ( 0.00%)   0            0                  0            0            0                   if(minT > tolerance && !other.isClosed_) // start of other
        .               .            .                  .            .            .                  .            .            .                   {
      405 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)        45 ( 0.00%)   0            0                 90 ( 0.00%)   0            0                       T va = other.vertices_.front();
      315 ( 0.00%)      0            0                 90 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                       T ve = other(tolerance);
      360 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)        45 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
   10,690 ( 0.00%)     85 ( 0.00%)  16 ( 0.00%)     6,342 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                       for(int i=0; i<n-1; ++i)
        .               .            .                  .            .            .                  .            .            .                       {
   25,008 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)     4,168 ( 0.00%)   0            0              4,168 ( 0.00%)   0            0                           T vc = vertices_[i];
   27,092 ( 0.00%)     41 ( 0.00%)   8 ( 0.00%)     4,168 ( 0.00%)   0            0              4,168 ( 0.00%)   0            0                           T vd = vertices_[i+1];
        .               .            .                  .            .            .                  .            .            .           
   22,924 ( 0.00%)     29 ( 0.00%)   8 ( 0.00%)     2,084 ( 0.00%)   0            0              4,168 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
    4,168 ( 0.00%)      0            0              2,084 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
        2 ( 0.00%)      0            0                  0            0            0                  1 ( 0.00%)   0            0                               double t = 0;
       28 ( 0.00%)      2 ( 0.00%)   2 ( 0.00%)        11 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                               double s = (1-v)*arclengths_[i] + v*arclengths_[i+1];
       12 ( 0.00%)      1 ( 0.00%)   1 ( 0.00%)         3 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                               res.push_back(Intersection(s,t));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // update min/max
        3 ( 0.00%)      1 ( 0.00%)   1 ( 0.00%)         2 ( 0.00%)   0            0                  0            0            0                               if(s<minS)
        2 ( 0.00%)      0            0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   minS = s;
        3 ( 0.00%)      0            0                  2 ( 0.00%)   0            0                  0            0            0                               if(s>maxS)
        2 ( 0.00%)      0            0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   maxS = s;
        3 ( 0.00%)      0            0                  2 ( 0.00%)   0            0                  0            0            0                               if(t<minT)
        2 ( 0.00%)      0            0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   minT = t;
        3 ( 0.00%)      0            0                  2 ( 0.00%)   0            0                  0            0            0                               if(t>maxT)
        .               .            .                  .            .            .                  .            .            .                                   maxT = t;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
      441 ( 0.00%)     53 ( 0.00%)  10 ( 0.00%)       245 ( 0.00%)   0            0                  0            0            0                   if(maxS < l-tolerance && !other.isClosed_) // end of this
        .               .            .                  .            .            .                  .            .            .                   {
      405 ( 0.00%)      0            0                 45 ( 0.00%)   0            0                 90 ( 0.00%)   0            0                       T va = other.vertices_.back();
      405 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)       135 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                       T ve = other(lOther-tolerance);
      360 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)        45 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
   10,690 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)     6,342 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                       for(int i=0; i<n-1; ++i)
        .               .            .                  .            .            .                  .            .            .                       {
   25,008 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)     4,168 ( 0.00%)   0            0              4,168 ( 0.00%)   0            0                           T vc = vertices_[i];
   27,092 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)     4,168 ( 0.00%)   0            0              4,168 ( 0.00%)   0            0                           T vd = vertices_[i+1];
        .               .            .                  .            .            .                  .            .            .           
   22,924 ( 0.00%)      0            0              2,084 ( 0.00%)   0            0              4,168 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
    4,168 ( 0.00%)     45 ( 0.00%)   8 ( 0.00%)     2,084 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               double t = lOther;
        .               .            .                  .            .            .                  .            .            .                               double s = (1-v)*arclengths_[i] + v*arclengths_[i+1];
        .               .            .                  .            .            .                  .            .            .                               res.push_back(Intersection(s,t));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // update min/max
        .               .            .                  .            .            .                  .            .            .                               if(s<minS)
        .               .            .                  .            .            .                  .            .            .                                   minS = s;
-- line 1256 ----------------------------------------
-- line 1259 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                               if(t<minT)
        .               .            .                  .            .            .                  .            .            .                                   minT = t;
        .               .            .                  .            .            .                  .            .            .                               if(t>maxT)
        .               .            .                  .            .            .                  .            .            .                                   maxT = t;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
       94 ( 0.00%)      4 ( 0.00%)   1 ( 0.00%)         0            0            0                  0            0            0                   return res;
      343 ( 0.00%)     43 ( 0.00%)   8 ( 0.00%)       294 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Compute unclean self-intersections.
        .               .            .                  .            .            .                  .            .            .               // May have duplicates. May miss some if segments nearly parallel.
        .               .            .                  .            .            .                  .            .            .               // Includes "virtual intersections": when extending the end of the curve by tolerance would create a new intersection.
        .               .            .                  .            .            .                  .            .            .               // Return value not sorted.
      110 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 60 ( 0.00%)   0            0               std::vector<Intersection> selfIntersections(double tolerance = 15.0) const
        .               .            .                  .            .            .                  .            .            .               {
       30 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   precomputeArclengths_();
        .               .            .                  .            .            .                  .            .            .           
       30 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   std::vector<Intersection> res;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Returns in trivial cases
       40 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                   int n = size();
       20 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                  0            0            0                   if(n<4)
        .               .            .                  .            .            .                  .            .            .                       return res;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // store min/max
       50 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                   double l = length();
       20 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   double minS = l;
       20 ( 0.00%)      0            0                  0            0            0                 10 ( 0.00%)   0            0                   double maxS = 0;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   double u, v;
    2,400 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)     1,424 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   for(int i=0; i<n-3; ++i)
        .               .            .                  .            .            .                  .            .            .                   {
    2,808 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)       936 ( 0.00%)   0            0                468 ( 0.00%)   0            0                       T va = (*this)[i];
    3,276 ( 0.00%)      0            0                936 ( 0.00%)   0            0                468 ( 0.00%)   0            0                       T vb = (*this)[i+1];
   80,149 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)    47,247 ( 0.00%)   0            0                468 ( 0.00%)   0            0                       for(int j=i+2; j<n-1; ++j)
        .               .            .                  .            .            .                  .            .            .                       {
   91,686 ( 0.00%)      0            0             30,562 ( 0.00%)   0            0             15,281 ( 0.00%)   0            0                           T vc = (*this)[j];
  106,967 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)    30,562 ( 0.00%)   0            0             15,281 ( 0.00%)   0            0                           T vd = (*this)[j+1];
        .               .            .                  .            .            .                  .            .            .           
  168,091 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)    15,281 ( 0.00%)  10 ( 0.00%)  10 ( 0.00%)    30,562 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
   30,562 ( 0.00%)      0            0             15,281 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               double s = (1-u)*arclengths_[i] + u*arclengths_[i+1];
        .               .            .                  .            .            .                  .            .            .                               double t = (1-v)*arclengths_[j] + v*arclengths_[j+1];
        .               .            .                  .            .            .                  .            .            .                               res.push_back(Intersection(s,t));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // update min/max
        .               .            .                  .            .            .                  .            .            .                               if(s<minS)
        .               .            .                  .            .            .                  .            .            .                                   minS = s;
        .               .            .                  .            .            .                  .            .            .                               if(t>maxS)
        .               .            .                  .            .            .                  .            .            .                                   maxS = t;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Compute endpoints intersections
       80 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        40 ( 0.00%)   0            0                  0            0            0                   if(minS > tolerance && !isClosed_) // start
        .               .            .                  .            .            .                  .            .            .                   {
       90 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                       T va = vertices_.front();
       70 ( 0.00%)      0            0                 20 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                       T ve = (*this)(tolerance);
       80 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
    2,450 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)     1,454 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                       for(int j=1; j<n-1; ++j)
        .               .            .                  .            .            .                  .            .            .                       {
    2,868 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)       956 ( 0.00%)   0            0                478 ( 0.00%)   0            0                           T vc = (*this)[j];
    3,346 ( 0.00%)      0            0                956 ( 0.00%)   0            0                478 ( 0.00%)   0            0                           T vd = (*this)[j+1];
        .               .            .                  .            .            .                  .            .            .           
    5,258 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)       478 ( 0.00%)   0            0                956 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
      956 ( 0.00%)      0            0                478 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
       28 ( 0.00%)      2 ( 0.00%)   2 ( 0.00%)        11 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                               double t = (1-v)*arclengths_[j] + v*arclengths_[j+1];
       12 ( 0.00%)      1 ( 0.00%)   1 ( 0.00%)         3 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                               res.push_back(Intersection(0,t));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // update min/max
        3 ( 0.00%)      0            0                  2 ( 0.00%)   0            0                  0            0            0                               if(t>maxS)
        2 ( 0.00%)      0            0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   maxS = t;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
       85 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        48 ( 0.00%)   0            0                  0            0            0                   if(maxS < l-tolerance && !isClosed_) // end
        .               .            .                  .            .            .                  .            .            .                   {
       81 ( 0.00%)      9 ( 0.00%)   9 ( 0.00%)         9 ( 0.00%)   0            0                 18 ( 0.00%)   0            0                       T va = vertices_.back();
       81 ( 0.00%)      9 ( 0.00%)   9 ( 0.00%)        27 ( 0.00%)   0            0                  9 ( 0.00%)   0            0                       T ve = (*this)(l-tolerance);
       72 ( 0.00%)      0            0                  9 ( 0.00%)   0            0                  9 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
    1,939 ( 0.00%)     18 ( 0.00%)  18 ( 0.00%)     1,149 ( 0.00%)   0            0                  9 ( 0.00%)   0            0                       for(int j=0; j<n-3; ++j)
        .               .            .                  .            .            .                  .            .            .                       {
    2,262 ( 0.00%)      0            0                754 ( 0.00%)   0            0                377 ( 0.00%)   0            0                           T vc = (*this)[j];
    2,639 ( 0.00%)      0            0                754 ( 0.00%)   0            0                377 ( 0.00%)   0            0                           T vd = (*this)[j+1];
        .               .            .                  .            .            .                  .            .            .           
    4,147 ( 0.00%)      9 ( 0.00%)   9 ( 0.00%)       377 ( 0.00%)   0            0                754 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
      754 ( 0.00%)      9 ( 0.00%)   9 ( 0.00%)       377 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               double t = (1-v)*arclengths_[j] + v*arclengths_[j+1];
        .               .            .                  .            .            .                  .            .            .                               res.push_back(Intersection(t,l));
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
       20 ( 0.00%)      1 ( 0.00%)   1 ( 0.00%)         0            0            0                  0            0            0                   return res;
       70 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        60 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Split the curve: guarantees that res.size() = splitValues.size() - 1
        .               .            .                  .            .            .                  .            .            .               // Input: split values. e.g : [0, 230, l]
        .               .            .                  .            .            .                  .            .            .               // Output: a list of curves: [subcurve(0->230) , subcurve(230->l)]
        .               .            .                  .            .            .                  .            .            .               // splitValues must have a size>=2 to return a non-empty vector
        .               .            .                  .            .            .                  .            .            .               // if the curve is a loop, the values are expected to be in the range 0..l except the last one
        .               .            .                  .            .            .                  .            .            .               // and be like: [ s1 s2 s3 ... sn s1+l ]
      121 ( 0.00%)     22 ( 0.00%)  16 ( 0.00%)        11 ( 0.00%)   0            0                 66 ( 0.00%)   0            0               std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  > split(const std::vector<double> & splitValues) const
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   using std::cout;
        .               .            .                  .            .            .                  .            .            .                   using std::endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   //cout << "\n\n\n ########### Entering split #########" << endl;
        .               .            .                  .            .            .                  .            .            .                   //cout << "Split values:";
        .               .            .                  .            .            .                  .            .            .                   //for(auto s: splitValues)
        .               .            .                  .            .            .                  .            .            .                   //    std::cout << " " << s;
        .               .            .                  .            .            .                  .            .            .                   //cout << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // for numerical corner cases: when one split value is exactly a vertex
        .               .            .                  .            .            .                  .            .            .                   //double epsilon = 1e-5;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // get number of split required.
       44 ( 0.00%)      0            0                 11 ( 0.00%)   0            0                 22 ( 0.00%)   0            0                   const int nSplitValues = static_cast<int>(splitValues.size());
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // trivial cases
       22 ( 0.00%)      0            0                 11 ( 0.00%)   0            0                  0            0            0                   if(nSplitValues < 2)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       //cout << "not enough split values" << endl;
        .               .            .                  .            .            .                  .            .            .                       return std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  >();
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
       44 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)        11 ( 0.00%)   0            0                 22 ( 0.00%)   0            0                   int n = size();
       22 ( 0.00%)      0            0                 11 ( 0.00%)   0            0                  0            0            0                   if(n == 0)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       //cout << "curve is null" << endl;
        .               .            .                  .            .            .                  .            .            .                       return std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  >(nSplitValues+1);
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Now, we know the curve is non-null, and that there is at least one split
       33 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)        11 ( 0.00%)   0            0                 11 ( 0.00%)   0            0                   precomputeArclengths_();
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   //cout << "Curve to split:";
        .               .            .                  .            .            .                  .            .            .                   //for(auto s: vertices_)
        .               .            .                  .            .            .                  .            .            .                   //    std::cout << " (" << s.x() << "," << s.y() << "," << s.width() << ") ";
        .               .            .                  .            .            .                  .            .            .                   //cout << endl;
        .               .            .                  .            .            .                  .            .            .                   //cout << "arclengths:";
        .               .            .                  .            .            .                  .            .            .                   //for(auto s: arclengths_)
        .               .            .                  .            .            .                  .            .            .                   //    std::cout << " " << s;
        .               .            .                  .            .            .                  .            .            .                   //cout << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
       11 ( 0.00%)      0            0                  0            0            0                 11 ( 0.00%)   0            0                   int i = 0;
       77 ( 0.00%)      0            0                 11 ( 0.00%)   9 ( 0.00%)   0                 11 ( 0.00%)   0            0                   T lastVertexOfLastCurve;
        .               .            .                  .            .            .                  .            .            .                   // find first vertex
        .               .            .                  .            .            .                  .            .            .                   // skip all vertices 0, 1, .., i, i+1, i+2, ...., i+k with an arclength strictly less than splitValues.front()
        .               .            .                  .            .            .                  .            .            .                   //cout << "arclengths_[i] to be tested = arclength[" << 0 << "] = " << arclengths_[0] << endl;
    1,958 ( 0.00%)     22 ( 0.00%)  16 ( 0.00%)       712 ( 0.00%)   4 ( 0.00%)   0                267 ( 0.00%)   0            0                   while(i<n && arclengths_[i] < splitValues.front() /*+ epsilon*/)
        .               .            .                  .            .            .                  .            .            .                   {
       78 ( 0.00%)      0            0                 78 ( 0.00%)   0            0                  0            0            0                       i++;
        .               .            .                  .            .            .                  .            .            .                       //cout << "arclengths_[i] to be tested = arclength[" << i << "] = " << arclengths_[i] << endl;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   //cout << "now, i = " << i << endl;
        .               .            .                  .            .            .                  .            .            .                   // compute first vertex
       22 ( 0.00%)      0            0                 11 ( 0.00%)   0            0                  0            0            0                   if(i == 0)
        .               .            .                  .            .            .                  .            .            .                   {
       90 ( 0.00%)      9 ( 0.00%)   6 ( 0.00%)         9 ( 0.00%)   0            0                 18 ( 0.00%)   0            0                       lastVertexOfLastCurve = start();
       18 ( 0.00%)      0            0                  9 ( 0.00%)   0            0                  0            0            0                       i++;
        .               .            .                  .            .            .                  .            .            .                       //cout << "we had i=0, hence lastvertex is first vertex" << endl;
        .               .            .                  .            .            .                  .            .            .                   }
        6 ( 0.00%)      2 ( 0.00%)   2 ( 0.00%)         4 ( 0.00%)   0            0                  0            0            0                   else if(i<n)
        .               .            .                  .            .            .                  .            .            .                   {
       80 ( 0.00%)      6 ( 0.00%)   6 ( 0.00%)        28 ( 0.00%)   0            0                 16 ( 0.00%)   0            0                       double  u = (splitValues.front() - arclengths_[i-1]) / (arclengths_[i] - arclengths_[i-1]);
       56 ( 0.00%)      4 ( 0.00%)   4 ( 0.00%)        10 ( 0.00%)   0            0                  8 ( 0.00%)   0            0                       lastVertexOfLastCurve = vertices_[i-1].lerp(u, vertices_[i]);
        .               .            .                  .            .            .                  .            .            .                       //cout << "we had i!=0, so we computed an interpolated vertex : ("
        .               .            .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.x() << ","
        .               .            .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.y() << ","
        .               .            .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.width() << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // special case when created vertex too close from next one: skip next one
        .               .            .                  .            .            .                  .            .            .                       // this case happens when the requested splitValue is exactly the arclength of one of
        .               .            .                  .            .            .                  .            .            .                       // the vertex
        6 ( 0.00%)      0            0                  4 ( 0.00%)   2 ( 0.00%)   0                  0            0            0                       if(u>0.99)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           i++;
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       lastVertexOfLastCurve = end();
        .               .            .                  .            .            .                  .            .            .                       //cout << "i was >= n, hence lastvertex is last vertex" << endl;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // to handle loop
       11 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)         0            0            0                 11 ( 0.00%)   0            0                   bool hasLooped = false;
        .               .            .                  .            .            .                  .            .            .           
       11 ( 0.00%)      0            0                  0            0            0                 11 ( 0.00%)   0            0                   int splitIndex = 1;
       33 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)         0            0            0                 11 ( 0.00%)   0            0                   std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  > res;
        .               .            .                  .            .            .                  .            .            .                   // loop invariant: splitIndex-1 == res.size()
        .               .            .                  .            .            .                  .            .            .                   //cout << "entering loop over split values" << endl;
      116 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)        46 ( 0.00%)   0            0                 12 ( 0.00%)   0            0                   while(splitIndex < nSplitValues)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       //cout << "\n ## starting a new sub-curve ##" << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       //cout << "starting a new sub-curve" << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       //cout << "splitIndex = " << splitIndex << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // extract a sub-curve from vertex i included to arclength "splitValue"
       96 ( 0.00%)      0            0                 36 ( 0.00%)   0            0                 24 ( 0.00%)   0            0                       double splitValue = splitValues[splitIndex];
        .               .            .                  .            .            .                  .            .            .                       //cout << "splitValue = " << splitValue << endl;
        .               .            .                  .            .            .                  .            .            .           
       72 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)        24 ( 0.00%)   7 ( 0.00%)   0                 12 ( 0.00%)   0            0                       Curve curve(ds_);
       24 ( 0.00%)      0            0                 12 ( 0.00%)   0            0                  0            0            0                       if(hasLooped)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           splitValue -= length();
        .               .            .                  .            .            .                  .            .            .                           //cout << "but we've looped so splitValue = " << splitIndex << endl;
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // add last vertex of previous sub-curve, if any
       72 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)         0            0            0                 12 ( 0.00%)   0            0                       curve.vertices_.push_back(lastVertexOfLastCurve);
       96 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)         0            0            0                 24 ( 0.00%)   0            0                       curve.arclengths_.push_back(0);
        .               .            .                  .            .            .                  .            .            .                       //cout << "adding the first vertex: ("
        .               .            .                  .            .            .                  .            .            .                       //     << curve.vertices_.back().x() << ","
        .               .            .                  .            .            .                  .            .            .                       //     << curve.vertices_.back().y() << ","
        .               .            .                  .            .            .                  .            .            .                       //     << curve.vertices_.back().width() << ")  with arclength = "
        .               .            .                  .            .            .                  .            .            .                       //     << curve.arclengths_.back() << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       //cout << "entering loop to add all vertices" << endl;
        .               .            .                  .            .            .                  .            .            .                       // add all vertices i, i+1, i+2, ...., i+k with an arclength strictly less than splitValue
    9,950 ( 0.00%)     24 ( 0.00%)  16 ( 0.00%)     3,316 ( 0.00%)  29 ( 0.00%)   0                552 ( 0.00%)   0            0                       while( (i>=n) || (arclengths_[i] < splitValue/* - epsilon*/) ) // basically: while(arclengths_[i] < splitValue)
        .               .            .                  .            .            .                  .            .            .                                                                        // but we do not want to leave the loop when arclengths_[i]
        .               .            .                  .            .            .                  .            .            .                                                                        // is ill-defined, and instead handle it, correct it, and resume the loop
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           //cout << "new loop body execution: i = " << i << " and n = " << n << endl;
    1,626 ( 0.00%)      0            0              1,084 ( 0.00%)   0            0                  0            0            0                           if(i<n) // normal case
        .               .            .                  .            .            .                  .            .            .                           {
    7,020 ( 0.00%)     11 ( 0.00%)   8 ( 0.00%)     1,080 ( 0.00%)   0            0              1,080 ( 0.00%)   0            0                               curve.vertices_.push_back(vertices_[i]);
   14,040 ( 0.00%)     22 ( 0.00%)  16 ( 0.00%)     3,780 ( 0.00%)   0            0              2,700 ( 0.00%)   0            0                               curve.arclengths_.push_back(arclengths_[i]-splitValues[splitIndex-1]);
        .               .            .                  .            .            .                  .            .            .                               //cout << "added vertex: ("
        .               .            .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().x() << ","
        .               .            .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().y() << ","
        .               .            .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().width() << ")  with arclength = "
        .               .            .                  .            .            .                  .            .            .                               //     << curve.arclengths_.back() << endl;
    1,080 ( 0.00%)      0            0                540 ( 0.00%)   0            0                  0            0            0                               i++;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                           else // case where arclengths_[i] is ill-defined because we reached end of loop
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               //cout << "woops, we've reached i = n" << endl;
       16 ( 0.00%)      0            0                  6 ( 0.00%)   0            0                  0            0            0                               if(isClosed_ && !hasLooped)
        .               .            .                  .            .            .                  .            .            .                               {
        .               .            .                  .            .            .                  .            .            .                                   //cout << "that's because this curve is a loop!" << endl;
        2 ( 0.00%)      0            0                  0            0            0                  2 ( 0.00%)   0            0                                   hasLooped = true;
        2 ( 0.00%)      0            0                  0            0            0                  2 ( 0.00%)   0            0                                   i = 1; // not 0 because the last vertex is equal to the first, we don't want to add it twice
       14 ( 0.00%)      0            0                  4 ( 0.00%)   0            0                  4 ( 0.00%)   0            0                                   splitValue -= length();
        .               .            .                  .            .            .                  .            .            .                                   //cout << "the new split value is: " << splitValue << endl;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                               else
        .               .            .                  .            .            .                  .            .            .                               {
        .               .            .                  .            .            .                  .            .            .                                   //cout << "well, then we just leave the loop :-)" << endl;
        .               .            .                  .            .            .                  .            .            .                                   break;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                       //cout << "leaving loop iterating over vertices" << endl;
        .               .            .                  .            .            .                  .            .            .                       //cout << "i = " << i << endl;
        .               .            .                  .            .            .                  .            .            .                       // here, (arclengths_[i-1] < splitValue and arclengths_[i] >= splitValue) or (i==n)
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // add new vertex inbetween i-1 and i
       60 ( 0.00%)      0            0                 36 ( 0.00%)   0            0                  0            0            0                       if( (0<i-1) && (i<n) ) // question: why not i-1 >= 0 instead ?
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // here, maybe should check if that's necessary or not
        .               .            .                  .            .            .                  .            .            .                           // I think I must check that u is > eps
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                           //cout << "let's add one more vertex" << endl;
        .               .            .                  .            .            .                  .            .            .           
      420 ( 0.00%)     36 ( 0.00%)  24 ( 0.00%)       144 ( 0.00%)   0            0                 72 ( 0.00%)   0            0                           double  u = (splitValue - arclengths_[i-1]) / (arclengths_[i] - arclengths_[i-1]);
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                           // same precaution the other way around:
        .               .            .                  .            .            .                  .            .            .                           // special case when created vertex too close from previous one:then don't add it
       36 ( 0.00%)      0            0                 24 ( 0.00%)   7 ( 0.00%)   0                  0            0            0                           if(u>0.01)
        .               .            .                  .            .            .                  .            .            .                           {
      348 ( 0.00%)     23 ( 0.00%)  16 ( 0.00%)        60 ( 0.00%)   0            0                 48 ( 0.00%)   0            0                               curve.vertices_.push_back(vertices_[i-1].lerp(u, vertices_[i]));
      204 ( 0.00%)     12 ( 0.00%)   8 ( 0.00%)        48 ( 0.00%)   0            0                 36 ( 0.00%)   0            0                               curve.arclengths_.push_back(splitValue-splitValues[splitIndex-1]);
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               //cout << "splitValue = " << splitValue
        .               .            .                  .            .            .                  .            .            .                               //     << "    arclengths_[i-1] = " << arclengths_[i-1]
        .               .            .                  .            .            .                  .            .            .                               //     << "    arclengths_[i] = " << arclengths_[i]
        .               .            .                  .            .            .                  .            .            .                               //     << "    u = " << u
        .               .            .                  .            .            .                  .            .            .                               //     << "    vertex = ("
        .               .            .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().x() << ","
        .               .            .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().y() << ","
        .               .            .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().width() << ")  with arclength = "
        .               .            .                  .            .            .                  .            .            .                               //     << curve.arclengths_.back() << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                               // special case when created vertex too close from next one: skip next one
        .               .            .                  .            .            .                  .            .            .                               // this case happens when the requested splitValue is exactly the arclength of one of
        .               .            .                  .            .            .                  .            .            .                               // the vertex
       36 ( 0.00%)     12 ( 0.00%)   8 ( 0.00%)        24 ( 0.00%)   0            0                  0            0            0                               if(u>0.99)
        .               .            .                  .            .            .                  .            .            .                               {
        9 ( 0.00%)      0            0                  9 ( 0.00%)   0            0                  0            0            0                                   i++;
        .               .            .                  .            .            .                  .            .            .                               }
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                           else
        .               .            .                  .            .            .                  .            .            .                           {
        .               .            .                  .            .            .                  .            .            .                               // nothing to do, the next vertex will naturally be added
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // handle special case
       48 ( 0.00%)      0            0                 24 ( 0.00%)   0            0                  0            0            0                       if(isClosed_)
        6 ( 0.00%)      0            0                  0            0            0                  2 ( 0.00%)   0            0                           curve.setDirtyArclengths_();
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // add the curve to the result
       60 ( 0.00%)     12 ( 0.00%)   8 ( 0.00%)         0            0            0                 12 ( 0.00%)   0            0                       res.push_back(curve);
      156 ( 0.00%)      1 ( 0.00%)   0                  0            0            0                 36 ( 0.00%)   0            0                       lastVertexOfLastCurve = res.back().end();
        .               .            .                  .            .            .                  .            .            .                       //cout << "added the new curve to split curve list, its last vertex is: "
        .               .            .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.x() << ","
        .               .            .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.y() << ","
        .               .            .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.width() << endl;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // increment split index
       12 ( 0.00%)     12 ( 0.00%)   0                 12 ( 0.00%)   0            0                  0            0            0                       splitIndex++;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   // here:  splitIndex == nSplitValues && splitIndex-1 == res.size()
        .               .            .                  .            .            .                  .            .            .                   // hence  res.size() == nSplitValues - 1
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   //returns
       55 ( 0.00%)      0            0                 11 ( 0.00%)   0            0                 11 ( 0.00%)   0            0                   return res;
      121 ( 0.00%)     22 ( 0.00%)  16 ( 0.00%)        66 ( 0.00%)   0            0                 11 ( 0.00%)   0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // ----- Curve geometry editing -----
        .               .            .                  .            .            .                  .            .            .           
      100 ( 0.00%)     10 ( 0.00%)   0                 10 ( 0.00%)   0            0                 50 ( 0.00%)   0            0               void setEndPoints(const T & newStart, const T & newEnd)
        .               .            .                  .            .            .                  .            .            .               {
       40 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                   int n = size();
       20 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                  0            0            0                   if(n < 3)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       vertices_.clear();
        .               .            .                  .            .            .                  .            .            .                       vertices_.push_back(newStart);
        .               .            .                  .            .            .                  .            .            .                       vertices_.push_back(newEnd);
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                   {
       30 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                       precomputeArclengths_();
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // this method could be replaced using lerp only, but it would make it
        .               .            .                  .            .            .                  .            .            .                       // much much less efficient and readable
      100 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        20 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                       T dStart = newStart - vertices_.front();
      100 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        20 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                       T dEnd = newEnd - vertices_.back();
        .               .            .                  .            .            .                  .            .            .           
       50 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                       double l = length();
       40 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                  0            0            0                       assert(l>0);
    2,042 ( 0.00%)    518 ( 0.00%)  20 ( 0.00%)     1,514 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                       for(int i=0; i<n; ++i)
        .               .            .                  .            .            .                  .            .            .                       {
    4,980 ( 0.00%)    986 ( 0.00%)  10 ( 0.00%)     1,992 ( 0.00%)   2 ( 0.00%)   0                996 ( 0.00%)   0            0                           double a = arclengths_[i] / l;
   16,434 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)     2,490 ( 0.00%)   0            0              2,490 ( 0.00%)   0            0                           vertices_[i] = vertices_[i] + dStart.lerp(a, dEnd);
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
       40 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   resample(true);
       60 ( 0.00%)      0            0                 40 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           private:
        .               .            .                  .            .            .                  .            .            .               // Sampled curve: the one that is exposed to the user
        .               .            .                  .            .            .                  .            .            .               std::vector<T,Eigen::aligned_allocator<T> > vertices_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Arc-length precomputation
        .               .            .                  .            .            .                  .            .            .               mutable std::vector<double> arclengths_;
        .               .            .                  .            .            .                  .            .            .               mutable bool dirtyArclengths_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // If treated as a loop
        .               .            .                  .            .            .                  .            .            .               bool isClosed_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // ---- Sketching: curve neatening algorithm  ----
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               bool sketchInProgress_;
       90 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        10 ( 0.00%)   0            0                 40 ( 0.00%)   0            0               void pushFirstVertex_(const T & vertex)
        .               .            .                  .            .            .                  .            .            .               {
       80 ( 0.00%)      0            0                 10 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                   arclengths_.push_back(0);
       60 ( 0.00%)      0            0                 20 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                   vertices_.push_back(vertex);
       60 ( 0.00%)      0            0                 40 ( 0.00%)   0            0                  0            0            0               }
    4,920 ( 0.00%)     10 ( 0.00%)   4 ( 0.00%)       492 ( 0.00%)   0            0              2,460 ( 0.00%)   0            0               void pushVertex_(const T & vertex)
        .               .            .                  .            .            .                  .            .            .               {
    5,412 ( 0.00%)     50 ( 0.00%)  31 ( 0.00%)       984 ( 0.00%)   0            0              1,476 ( 0.00%)   0            0                   double d = vertices_.back().distanceTo(vertex);
    1,968 ( 0.00%)      0            0                492 ( 0.00%)   0            0                  0            0            0                   if(d>0)
        .               .            .                  .            .            .                  .            .            .                   {
    6,396 ( 0.00%)    176 ( 0.00%)  31 ( 0.00%)     1,968 ( 0.00%)  33 ( 0.00%)  31 ( 0.00%)     1,476 ( 0.00%)   0            0                       arclengths_.push_back(arclengths_.back() + d);
    2,952 ( 0.00%)      0            0                984 ( 0.00%)   0            0                492 ( 0.00%)   0            0                       vertices_.push_back(vertex);
        .               .            .                  .            .            .                  .            .            .                   }
    3,444 ( 0.00%)    167 ( 0.00%)  24 ( 0.00%)     2,460 ( 0.00%)   0            0                  0            0            0               }
   16,104 ( 0.00%)    632 ( 0.00%)  20 ( 0.00%)     1,464 ( 0.00%)   0            0              8,784 ( 0.00%)   0            0               T interpolatedVertex_(double s) const // size must be > 1
        .               .            .                  .            .            .                  .            .            .               {
    4,392 ( 0.00%)    689 ( 0.00%)  30 ( 0.00%)     1,464 ( 0.00%)   0            0              1,464 ( 0.00%)   0            0                   precomputeArclengths_();
        .               .            .                  .            .            .                  .            .            .           
    1,464 ( 0.00%)      0            0                  0            0            0              1,464 ( 0.00%)   0            0                   int i = 0;
    8,784 ( 0.00%)      0            0              1,464 ( 0.00%)   0            0              2,928 ( 0.00%)   0            0                   int j = static_cast<int>(vertices_.size()) - 1;
   13,176 ( 0.00%)    671 ( 0.00%)  30 ( 0.00%)     4,392 ( 0.00%)  63 ( 0.00%)  54 ( 0.00%)     2,928 ( 0.00%)   0            0                   double si = arclengths_[i];
   13,176 ( 0.00%)      0            0              4,392 ( 0.00%) 122 ( 0.00%) 103 ( 0.00%)     2,928 ( 0.00%)   0            0                   double sj = arclengths_[j];
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   int k;
        .               .            .                  .            .            .                  .            .            .                   double sk, u;
        .               .            .                  .            .            .                  .            .            .           
   14,388 ( 0.00%)    642 ( 0.00%)  30 ( 0.00%)     6,462 ( 0.00%)   0            0                  0            0            0                   while( j-i > 1)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       // compute an index hopefully close to s
   10,602 ( 0.00%)    496 ( 0.00%)  30 ( 0.00%)     7,068 ( 0.00%)   0            0              1,767 ( 0.00%)   0            0                       u = (s - si) / (sj - si);
   26,505 ( 0.00%)    480 ( 0.00%)  30 ( 0.00%)     8,835 ( 0.00%)  10 ( 0.00%)   4 ( 0.00%)     3,534 ( 0.00%)   0            0                       k = std::floor( (1-u)*i + u*j );
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // make sure i < k < j
   31,806 ( 0.00%)    649 ( 0.00%)  30 ( 0.00%)     5,301 ( 0.00%)   0            0              8,835 ( 0.00%)   0            0                       k = std::min(j-1, std::max(i+1, k));
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // recurse
   15,903 ( 0.00%)      0            0              5,301 ( 0.00%)  39 ( 0.00%)  32 ( 0.00%)     3,534 ( 0.00%)   0            0                       sk = arclengths_[k];
    5,301 ( 0.00%)      0            0              3,534 ( 0.00%)   0            0                  0            0            0                       if(sk > s)
        .               .            .                  .            .            .                  .            .            .                       {
    1,924 ( 0.00%)      0            0                962 ( 0.00%)   0            0                962 ( 0.00%)   0            0                           j = k;
    2,886 ( 0.00%)      0            0                962 ( 0.00%)   0            0                962 ( 0.00%)   0            0                           sj = sk;
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                       else
        .               .            .                  .            .            .                  .            .            .                       {
    1,610 ( 0.00%)      0            0                805 ( 0.00%)   0            0                805 ( 0.00%)   0            0                           i = k;
    1,610 ( 0.00%)      0            0                805 ( 0.00%)   0            0                805 ( 0.00%)   0            0                           si = sk;
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // Now: j = i+1
    8,784 ( 0.00%)    506 ( 0.00%)  30 ( 0.00%)     5,856 ( 0.00%)   0            0              1,464 ( 0.00%)   0            0                   u = (s - si) / (sj - si);
   32,208 ( 0.00%)     74 ( 0.00%)  30 ( 0.00%)     8,784 ( 0.00%)   0            0              4,392 ( 0.00%)   0            0                   return vertices_[i].lerp(u,vertices_[j]);
   10,248 ( 0.00%)      0            0              8,784 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // parameters
        .               .            .                  .            .            .                  .            .            .               int N_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // temp variables
        .               .            .                  .            .            .                  .            .            .               std::vector<T,Eigen::aligned_allocator<T> > qTemp_; // vertices only valid until next mouse sample
        .               .            .                  .            .            .                  .            .            .                                              // the ones before are final and stored in q_
        .               .            .                  .            .            .                  .            .            .               //QList<double> qtTemp_; // same but for time information // NOT needed now: part of T
        .               .            .                  .            .            .                  .            .            .               double lastFinalS_; // value s such that phi(s) = q_.last()
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // raw input from mouse
    4,284 ( 0.00%)    104 ( 0.00%) 104 ( 0.00%)     1,666 ( 0.00%)   0            0              1,190 ( 0.00%)   0            0               struct Input
        .               .            .                  .            .            .                  .            .            .               {
    1,872 ( 0.00%)    208 ( 0.00%) 208 ( 0.00%)       624 ( 0.00%)   0            0                624 ( 0.00%)   0            0                   Input(const T & p, double s) : p(p), s(s) {}
        .               .            .                  .            .            .                  .            .            .                   T p;
        .               .            .                  .            .            .                  .            .            .                   double s;
        .               .            .                  .            .            .                  .            .            .                   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
        .               .            .                  .            .            .                  .            .            .               };
        .               .            .                  .            .            .                  .            .            .               std::vector<Input,Eigen::aligned_allocator<Input> > p_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // fit a smooth curve to a subpart of the raw mouse input
        .               .            .                  .            .            .                  .            .            .               class Fitter
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .               public:
        .               .            .                  .            .            .                  .            .            .                   // the fitting computation must be implemented in derived constructors.
        .               .            .                  .            .            .                  .            .            .                   //
        .               .            .                  .            .            .                  .            .            .                   // the N input points from p[j] to p[j+N-1] (guaranteed to exist)
        .               .            .                  .            .            .                  .            .            .                   // is the local part of the curve that should be fit.
        .               .            .                  .            .            .                  .            .            .                   //
      752 ( 0.00%)     58 ( 0.00%)  58 ( 0.00%)         0            0            0                564 ( 0.00%)   0            0                   Fitter(const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds) :
    1,786 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)     1,034 ( 0.00%)   0            0                470 ( 0.00%)  20 ( 0.00%)  19 ( 0.00%)              p_(p), j_(j), N_(N), ds_(ds) {}
    1,034 ( 0.00%)     83 ( 0.00%)  80 ( 0.00%)       282 ( 0.00%)   0            0                282 ( 0.00%)   0            0                   virtual ~Fitter() {}
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // eval() must be implemented in derived classes
        .               .            .                  .            .            .                  .            .            .                   //
        .               .            .                  .            .            .                  .            .            .                   // the fitting curve C must:
        .               .            .                  .            .            .                  .            .            .                   //    - be a continuous curve parameterized from startS to endS
        .               .            .                  .            .            .                  .            .            .                   //    - verify C(startS) = startP and C(endS) = endP
        .               .            .                  .            .            .                  .            .            .                   //    - have a precision of at least ds
        .               .            .                  .            .            .                  .            .            .                   //
-- line 1734 ----------------------------------------
-- line 1743 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                   //
        .               .            .                  .            .            .                  .            .            .                   virtual Eigen::Vector2d eval(double s) const=0;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // weight that should be use for this curve at this parameter to
        .               .            .                  .            .            .                  .            .            .                   // blend the different overlapping local fits together
        .               .            .                  .            .            .                  .            .            .                   //
        .               .            .                  .            .            .                  .            .            .                   // this method can be overriden in derived class if custom blending
        .               .            .                  .            .            .                  .            .            .                   // weights are desired (but the default ones should be fine)
   25,980 ( 0.00%)  1,042 ( 0.00%)  25 ( 0.00%)         0            0            0             12,990 ( 0.00%)   0            0                   virtual double w(double s) const
        .               .            .                  .            .            .                  .            .            .                   {
   30,310 ( 0.00%)      0            0              8,660 ( 0.00%)   0            0              8,660 ( 0.00%)   0            0                       double u = u_(s);
   43,300 ( 0.00%)     46 ( 0.00%)  25 ( 0.00%)    21,650 ( 0.00%)   0            0                  0            0            0                       return u*u*(1-u)*(1-u);
   12,990 ( 0.00%)      0            0              8,660 ( 0.00%)   0            0                  0            0            0                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // convenient inline methods to make code easier to write and read
   58,432 ( 0.00%)    282 ( 0.00%) 282 ( 0.00%)    17,264 ( 0.00%)   0            0             15,936 ( 0.00%)   0            0                   inline Eigen::Vector2d p(int i) const {return Eigen::Vector2d(p_[i].p.x(), p_[i].p.y()) ;}
  597,258 ( 0.01%)     84 ( 0.00%)  84 ( 0.00%)   199,086 ( 0.01%) 125 ( 0.00%) 124 ( 0.00%)   132,724 ( 0.01%)   0            0                   inline double s(int i) const {return p_[i].s;}
  327,690 ( 0.00%)  3,055 ( 0.01%)  94 ( 0.00%)   109,230 ( 0.01%)  18 ( 0.00%)  18 ( 0.00%)    65,538 ( 0.00%)   0            0                   inline double startS() const {return s(j_);}
  207,537 ( 0.00%)    124 ( 0.00%)  84 ( 0.00%)    76,461 ( 0.00%)   0            0             32,769 ( 0.00%)   0            0                   inline double endS() const {return s(j_+N_-1);}
    5,324 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)     2,420 ( 0.00%)   0            0              1,210 ( 0.00%)   0            0                   inline Eigen::Vector2d startP() const {return p(j_);}
    6,292 ( 0.00%)    188 ( 0.00%) 188 ( 0.00%)     2,904 ( 0.00%)   0            0              1,210 ( 0.00%)   0            0                   inline Eigen::Vector2d endP() const {return p(j_+N_-1);}
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               protected:
        .               .            .                  .            .            .                  .            .            .                   // maps [startS, endS] to [0,1]
  327,690 ( 0.00%)  2,636 ( 0.01%) 178 ( 0.00%)    87,384 ( 0.00%)   0            0             87,384 ( 0.01%)   0            0                   double u_(double s) const {return (s-startS())/(endS()-startS());}
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // reference to the whole raw mouse input
        .               .            .                  .            .            .                  .            .            .                   const std::vector<Input,Eigen::aligned_allocator<Input> > & p_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // local range of vertices to fit: the N points p_[j] to p_[j+N-1]
        .               .            .                  .            .            .                  .            .            .                   int j_;
        .               .            .                  .            .            .                  .            .            .                   int N_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // required precision, to be used if derived classes need sampling
        .               .            .                  .            .            .                  .            .            .                   double ds_;
        .               .            .                  .            .            .                  .            .            .               };
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // List storing all the local fitting
        .               .            .                  .            .            .                  .            .            .               std::vector<Fitter*> fits_;
      160 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        20 ( 0.00%)   0            0                 60 ( 0.00%)   0            0               void clearFits_()
        .               .            .                  .            .            .                  .            .            .               {
      815 ( 0.00%)     40 ( 0.00%)  40 ( 0.00%)        89 ( 0.00%)   6 ( 0.00%)   1 ( 0.00%)       236 ( 0.00%)   0            0                   for(Fitter * f : fits_)
      232 ( 0.00%)      0            0                 87 ( 0.00%)  26 ( 0.00%)  10 ( 0.00%)        29 ( 0.00%)   0            0                       delete f;
       80 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)        20 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                   fits_.clear();
      120 ( 0.00%)      0            0                 80 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Blend overlapping fitting together
        .               .            .                  .            .            .                  .            .            .               int lastFittingInvolved_i; // not initialized, but it's ok
    9,233 ( 0.00%)  1,319 ( 0.00%)  29 ( 0.00%)         0            0            0              5,276 ( 0.00%)   0            0               int lastFittingInvolved_(double s)
        .               .            .                  .            .            .                  .            .            .               {
    3,957 ( 0.00%)    195 ( 0.00%)  29 ( 0.00%)     2,638 ( 0.00%)   0            0              1,319 ( 0.00%)   0            0                   int i = lastFittingInvolved_i; // make it more readable
   18,466 ( 0.00%)      0            0              3,957 ( 0.00%)   0            0              1,319 ( 0.00%)   0            0                   if(i<0 || (unsigned int) i >= p_.size())
    1,319 ( 0.00%)      0            0                  0            0            0              1,319 ( 0.00%)   0            0                       i = 0;
    7,914 ( 0.00%)     50 ( 0.00%)  29 ( 0.00%)     1,319 ( 0.00%)   0            0                  0            0            0                   while(i-1>=0 && s<p_[i-1].s)
        .               .            .                  .            .            .                  .            .            .                       i--;
  275,050 ( 0.00%)  2,132 ( 0.00%)  58 ( 0.00%)    66,012 ( 0.00%)  31 ( 0.00%)  31 ( 0.00%)    22,004 ( 0.00%)   0            0                   while((unsigned int)i+1<p_.size() && s>=p_[i+1].s)
    9,683 ( 0.00%)      0            0              9,683 ( 0.00%)   0            0                  0            0            0                       i++;
    1,319 ( 0.00%)      0            0              1,319 ( 0.00%)   0            0                  0            0            0                   return i;
    3,957 ( 0.00%)      0            0              3,957 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
   34,716 ( 0.00%)  5,786 ( 0.01%) 168 ( 0.00%)     2,893 ( 0.00%)   0            0             20,251 ( 0.00%)   0            0               T phi_(double s, Fitter * useSingleFit = 0)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   // compute pos
   23,144 ( 0.00%)  2,893 ( 0.01%)  84 ( 0.00%)         0            0            0              8,679 ( 0.00%)   0            0                   Eigen::Vector2d pos(0,0);
    5,786 ( 0.00%)      0            0              2,893 ( 0.00%)   0            0                  0            0            0                   if(useSingleFit)
        .               .            .                  .            .            .                  .            .            .                   {
   26,758 ( 0.00%)    102 ( 0.00%)  55 ( 0.00%)     7,870 ( 0.00%)  55 ( 0.00%)  55 ( 0.00%)     3,148 ( 0.00%)   0            0                       pos = useSingleFit->eval(s);
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                   {
    7,914 ( 0.00%)  2,638 ( 0.01%)  58 ( 0.00%)     2,638 ( 0.00%)   0            0              2,638 ( 0.00%)   0            0                       int i=lastFittingInvolved_(s);
   19,785 ( 0.00%)  1,319 ( 0.00%)  29 ( 0.00%)     5,276 ( 0.00%)   0            0              5,276 ( 0.00%)   0            0                       int startJ = std::max(0,i-N_+2);
   22,423 ( 0.00%)  1,319 ( 0.00%)  29 ( 0.00%)     5,276 ( 0.00%)   0            0              5,276 ( 0.00%)   0            0                       int endJ = std::min(i,(int)p_.size()-N_);
    3,957 ( 0.00%)      0            0              2,638 ( 0.00%)   0            0                  0            0            0                       if(startJ==endJ)
        .               .            .                  .            .            .                  .            .            .                       {
    6,371 ( 0.00%)    277 ( 0.00%)   4 ( 0.00%)     1,662 ( 0.00%)   4 ( 0.00%)   4 ( 0.00%)       831 ( 0.00%)   0            0                           pos = fits_[startJ]->eval(s);
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                       else
        .               .            .                  .            .            .                  .            .            .                       {
    2,084 ( 0.00%)  2,084 ( 0.00%)  50 ( 0.00%)         0            0            0              1,042 ( 0.00%)   0            0                           double sumW = 0;
   23,572 ( 0.00%)     46 ( 0.00%)  25 ( 0.00%)    16,116 ( 0.00%)   0            0              1,042 ( 0.00%)   0            0                           for(int j=startJ; j<=endJ; j++)
        .               .            .                  .            .            .                  .            .            .                           {
   73,610 ( 0.00%)  1,042 ( 0.00%)  25 ( 0.00%)    25,980 ( 0.00%) 131 ( 0.00%) 106 ( 0.00%)    12,990 ( 0.00%)   0            0                               double w = fits_[j]->w(s);
   73,610 ( 0.00%)    191 ( 0.00%)  25 ( 0.00%)    25,980 ( 0.00%)  25 ( 0.00%)  25 ( 0.00%)     8,660 ( 0.00%)   0            0                               Eigen::Vector2d q = fits_[j]->eval(s);
   73,610 ( 0.00%)     25 ( 0.00%)  25 ( 0.00%)         0            0            0             12,990 ( 0.00%)   0            0                               pos = pos + w * q;
   17,320 ( 0.00%)      0            0              8,660 ( 0.00%)   0            0              4,330 ( 0.00%)   0            0                               sumW += w;
        .               .            .                  .            .            .                  .            .            .                           }
   14,588 ( 0.00%)  1,042 ( 0.00%)  25 ( 0.00%)     2,084 ( 0.00%)   0            0              3,126 ( 0.00%)   0            0                           pos = (1/sumW) * pos;
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // get other data as linear interpolation of raw mouse input (no smoothing)
   20,251 ( 0.00%)  2,999 ( 0.01%) 143 ( 0.00%)     5,786 ( 0.00%)  84 ( 0.00%)  84 ( 0.00%)     2,893 ( 0.00%)   0            0                   T res;
   23,144 ( 0.00%)      0            0              2,893 ( 0.00%)   0            0              2,893 ( 0.00%)   0            0                   if(p_.size() == 0)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       // nothing, keep default-constructed data
        .               .            .                  .            .            .                  .            .            .                   }
   23,144 ( 0.00%)  2,893 ( 0.01%)  84 ( 0.00%)     2,893 ( 0.00%)   0            0              2,893 ( 0.00%)   0            0                   else if(p_.size() == 1)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                       res = p_[0].p;
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   else
        .               .            .                  .            .            .                  .            .            .                   {
   17,358 ( 0.00%)     88 ( 0.00%)  84 ( 0.00%)     2,893 ( 0.00%)   0            0              5,786 ( 0.00%)   0            0                       int i = static_cast<int>(p_.size()) - 1;
  197,075 ( 0.00%)     91 ( 0.00%)  84 ( 0.00%)    56,772 ( 0.00%)   0            0             11,933 ( 0.00%)   0            0                       while(p_[i-1].s > s && i>1)
    9,040 ( 0.00%)      0            0              9,040 ( 0.00%)   0            0                  0            0            0                           i--;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // now, we have p_[i-1].s <= s < p_[i]
        .               .            .                  .            .            .                  .            .            .                       // note: we know that s2 - s1 > 0 since we rejected before
        .               .            .                  .            .            .                  .            .            .                       // the input that did not satisfy this condition
   28,930 ( 0.00%)     84 ( 0.00%)  84 ( 0.00%)     8,679 ( 0.00%)   0            0              5,786 ( 0.00%)   0            0                       double s1 = p_[i-1].s;
   26,037 ( 0.00%)     87 ( 0.00%)  84 ( 0.00%)     8,679 ( 0.00%)   0            0              5,786 ( 0.00%)   0            0                       double s2 = p_[i].s;
   17,358 ( 0.00%)     87 ( 0.00%)  84 ( 0.00%)    11,572 ( 0.00%)   0            0              2,893 ( 0.00%)   0            0                       double u = (s-s1)/(s2-s1);
   81,004 ( 0.00%)     84 ( 0.00%)  84 ( 0.00%)    17,358 ( 0.00%)   0            0             11,572 ( 0.00%)   0            0                       res = p_[i-1].p.lerp(u, p_[i].p);
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   // change position
   26,037 ( 0.00%)     84 ( 0.00%)  84 ( 0.00%)     5,786 ( 0.00%)   0            0              5,786 ( 0.00%)   0            0                   res.setX(pos[0]);
   26,037 ( 0.00%)    152 ( 0.00%)  84 ( 0.00%)     5,786 ( 0.00%)   0            0              5,786 ( 0.00%)   0            0                   res.setY(pos[1]);
        .               .            .                  .            .            .                  .            .            .           
    2,893 ( 0.00%)      0            0                  0            0            0                  0            0            0                   return res;
   20,251 ( 0.00%)      0            0             17,358 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               //double phit_(double s); // useless now, part of T
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Different fitting algorithms that can be used
        .               .            .                  .            .            .                  .            .            .               // Note: only smooth the x and y coordinates. Could use higher dimensional
        .               .            .                  .            .            .                  .            .            .               //       bezier to also smooth other data, but not done by design
    3,008 ( 0.00%)    138 ( 0.00%)  80 ( 0.00%)       846 ( 0.00%)   0            0                846 ( 0.00%)   0            0               class CubicBezierFitter: public Fitter
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .               public:
    1,222 ( 0.00%)    188 ( 0.00%) 188 ( 0.00%)        94 ( 0.00%)   0            0                752 ( 0.00%)   0            0                   CubicBezierFitter(const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds) :
    3,008 ( 0.00%)    282 ( 0.00%) 282 ( 0.00%)     1,034 ( 0.00%)   0            0                658 ( 0.00%)   0            0                       Fitter(p,j,N, ds)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .           
      188 ( 0.00%)      0            0                 94 ( 0.00%)   0            0                  0            0            0                       assert(N>=2);
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // --- Fit a bezier curve to the input points ---
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // end points
    1,034 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       188 ( 0.00%)   0            0                188 ( 0.00%)   0            0                       P0_ = this->startP();
    1,034 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       188 ( 0.00%)   0            0                188 ( 0.00%)   0            0                       P3_ = this->endP();
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // handle special cases:
      188 ( 0.00%)      0            0                 94 ( 0.00%)   0            0                  0            0            0                       if(N==2)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // linear:
      300 ( 0.00%)     30 ( 0.00%)  30 ( 0.00%)        50 ( 0.00%)  10 ( 0.00%)  10 ( 0.00%)        60 ( 0.00%)   0            0                           P1_ = 2./3. *  P0_ + 1./3. * P3_;
      310 ( 0.00%)     20 ( 0.00%)  20 ( 0.00%)        50 ( 0.00%)   0            0                 60 ( 0.00%)   0            0                           P2_ = 1./3. *  P0_ + 2./3. * P3_;
        .               .            .                  .            .            .                  .            .            .                       }
      168 ( 0.00%)     84 ( 0.00%)  84 ( 0.00%)        84 ( 0.00%)   0            0                  0            0            0                       else if(N==3)
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .                           // At*A is also singular in this case
        .               .            .                  .            .            .                  .            .            .                           // fit a dum quadratic (todo: smth better)
      130 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        30 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                           P1_ = this->p(j+1);
      140 ( 0.00%)     10 ( 0.00%)  10 ( 0.00%)        30 ( 0.00%)   0            0                 20 ( 0.00%)   0            0                           P2_ = this->p(j+1);
        .               .            .                  .            .            .                  .            .            .                       }
        .               .            .                  .            .            .                  .            .            .                       else
        .               .            .                  .            .            .                  .            .            .                       {
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                           // create linear system
      888 ( 0.00%)    148 ( 0.00%) 148 ( 0.00%)       148 ( 0.00%)   0            0                222 ( 0.00%)   0            0                           Eigen::MatrixXd A(2*(this->N_-2),4);
      740 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)       148 ( 0.00%)   0            0                148 ( 0.00%)   0            0                           Eigen::VectorXd B(2*(this->N_-2));
      814 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)       148 ( 0.00%)   0            0                222 ( 0.00%)   0            0                           double Ax = this->startP()[0];
      814 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)       148 ( 0.00%)   0            0                222 ( 0.00%)   0            0                           double Ay = this->startP()[1];
      814 ( 0.00%)      0            0                148 ( 0.00%)   0            0                222 ( 0.00%)   0            0                           double Dx = this->endP()[0];
      814 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)       148 ( 0.00%)   0            0                222 ( 0.00%)   0            0                           double Dy = this->endP()[1];
    2,990 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     1,870 ( 0.00%)   0            0                 74 ( 0.00%)   0            0                           for(int i=1; i<this->N_-1; i++)
        .               .            .                  .            .            .                  .            .            .                           {
    6,180 ( 0.00%)    148 ( 0.00%) 148 ( 0.00%)     2,060 ( 0.00%)   0            0              1,236 ( 0.00%)   0            0                               double Ui = this->u_(this->s(i+this->j_));
    1,236 ( 0.00%)      0            0                824 ( 0.00%)  74 ( 0.00%)  74 ( 0.00%)       412 ( 0.00%)   0            0                               double OneMinusUi = 1-Ui;
    1,236 ( 0.00%)      0            0                412 ( 0.00%)   0            0                412 ( 0.00%)   0            0                               double Ui2 = Ui*Ui;
    1,236 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)       412 ( 0.00%)   0            0                412 ( 0.00%)   0            0                               double OneMinusUi2 = OneMinusUi*OneMinusUi;
    1,236 ( 0.00%)      0            0                824 ( 0.00%)   0            0                412 ( 0.00%)   0            0                               double Ui3 = Ui2*Ui;
    1,236 ( 0.00%)      0            0                824 ( 0.00%)   0            0                412 ( 0.00%)   0            0                               double OneMinusUi3 = OneMinusUi2*OneMinusUi;
    2,472 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     1,236 ( 0.00%)  74 ( 0.00%)  74 ( 0.00%)       412 ( 0.00%)   0            0                               double ThreeOneMinusUi2Ui = 3 * OneMinusUi2 * Ui;
    2,472 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     1,236 ( 0.00%)   0            0                412 ( 0.00%)   0            0                               double ThreeOneMinusUiUi2 = 3 * OneMinusUi * Ui2;
        .               .            .                  .            .            .                  .            .            .           
    1,648 ( 0.00%)      0            0                412 ( 0.00%)   0            0                412 ( 0.00%)   0            0                               int TwoTimesIMinus1 = 2*(i-1);
    2,060 ( 0.00%)      0            0                412 ( 0.00%)   0            0                412 ( 0.00%)   0            0                               int TwoTimesIMinus1Plus1 = 2*(i-1)+1;
        .               .            .                  .            .            .                  .            .            .           
    4,532 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     1,236 ( 0.00%)   0            0              1,236 ( 0.00%)  32 ( 0.00%)  32 ( 0.00%)                      A(TwoTimesIMinus1, 0) = ThreeOneMinusUi2Ui;
    3,708 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)       412 ( 0.00%)   0            0                824 ( 0.00%)  98 ( 0.00%)  96 ( 0.00%)                      A(TwoTimesIMinus1, 1) = 0;
    4,532 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     1,236 ( 0.00%)   0            0              1,236 ( 0.00%) 100 ( 0.00%)  98 ( 0.00%)                      A(TwoTimesIMinus1, 2) = ThreeOneMinusUiUi2;
    3,708 ( 0.00%)      0            0                412 ( 0.00%)   0            0                824 ( 0.00%) 147 ( 0.00%) 142 ( 0.00%)                      A(TwoTimesIMinus1, 3) = 0;
        .               .            .                  .            .            .                  .            .            .           
    3,708 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)       412 ( 0.00%)   0            0                824 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 0) = 0;
    4,532 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     1,236 ( 0.00%)   0            0              1,236 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 1) = ThreeOneMinusUi2Ui;
    3,708 ( 0.00%)      0            0                412 ( 0.00%)   0            0                824 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 2) = 0;
    4,532 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     1,236 ( 0.00%)   0            0              1,236 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 3) = ThreeOneMinusUiUi2;
        .               .            .                  .            .            .                  .            .            .           
   11,948 ( 0.00%)    222 ( 0.00%) 222 ( 0.00%)     4,532 ( 0.00%)   0            0              2,060 ( 0.00%)  82 ( 0.00%)  71 ( 0.00%)                      B(TwoTimesIMinus1) = this->p(i+this->j_)[0] - OneMinusUi3 * Ax - Ui3 * Dx;
   11,948 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)     4,532 ( 0.00%)   0            0              2,060 ( 0.00%)   0            0                               B(TwoTimesIMinus1Plus1) = this->p(i+this->j_)[1] - OneMinusUi3 * Ay - Ui3 * Dy;
        .               .            .                  .            .            .                  .            .            .                           }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                           // solve it
        .               .            .                  .            .            .                  .            .            .                           //Eigen::VectorXd X = (A.transpose() * A).inverse() * A.transpose() * B;
        .               .            .                  .            .            .                  .            .            .                           // For some reason above code breaks with Eigen 3.2, need to split it
    1,554 ( 0.00%)    148 ( 0.00%) 148 ( 0.00%)         0            0            0                666 ( 0.00%)   0            0                           Eigen::MatrixXd M = (A.transpose() * A).inverse();
      666 ( 0.00%)    148 ( 0.00%)  74 ( 0.00%)         0            0            0                222 ( 0.00%)   0            0                           M *= A.transpose();
      888 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)         0            0            0                296 ( 0.00%)   0            0                           Eigen::VectorXd X = M * B;
        .               .            .                  .            .            .                  .            .            .           
    1,554 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)        74 ( 0.00%)   0            0                296 ( 0.00%)   0            0                           P1_ = Eigen::Vector2d(X(0),X(1));
    1,554 ( 0.00%)    148 ( 0.00%) 148 ( 0.00%)        74 ( 0.00%)   0            0                296 ( 0.00%)   0            0                           P2_ = Eigen::Vector2d(X(2),X(3));
      888 ( 0.00%)     74 ( 0.00%)  74 ( 0.00%)         0            0            0                296 ( 0.00%)   0            0                       }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // --- Compute an approximate uniform parameterization ---
        .               .            .                  .            .            .                  .            .            .           
   67,701 ( 0.00%)  3,127 ( 0.01%) 208 ( 0.00%)    26,459 ( 0.00%) 114 ( 0.00%) 114 ( 0.00%)    11,770 ( 0.00%)   0            0                       for(double u=0; u<1; u+=0.75*this->ds_/der(u).norm())
        .               .            .                  .            .            .                  .            .            .                       {
   37,947 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)     8,757 ( 0.00%)   0            0              5,838 ( 0.00%)   0            0                           sampling_ << this->pos(u);
        .               .            .                  .            .            .                  .            .            .                       }
      658 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       188 ( 0.00%)   0            0                 94 ( 0.00%)   0            0                           sampling_ << P3_;
        .               .            .                  .            .            .                  .            .            .                       // => sampling_.size() >= 2
      658 ( 0.00%)     94 ( 0.00%)  94 ( 0.00%)       470 ( 0.00%)   0            0                  0            0            0                   }
        .               .            .                  .            .            .                  .            .            .           
   67,991 ( 0.00%)  5,786 ( 0.01%) 168 ( 0.00%)     6,181 ( 0.00%)   0            0             37,086 ( 0.00%)   0            0                   Eigen::Vector2d eval(double s) const
        .               .            .                  .            .            .                  .            .            .                   {
   43,267 ( 0.00%)    250 ( 0.00%)  84 ( 0.00%)    12,362 ( 0.00%)   0            0             12,362 ( 0.00%)   0            0                       double u = this->u_(s);
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                       // i = iQ + iR with iQ \in N and iR \in [0,1)
   80,353 ( 0.00%)    105 ( 0.00%)  84 ( 0.00%)    12,362 ( 0.00%)   0            0             12,362 ( 0.00%)   0            0                       double i = u * (sampling_.size()-1);
   30,905 ( 0.00%)      0            0              6,181 ( 0.00%)   0            0             12,362 ( 0.00%)   0            0                       int iQ = std::floor(i);
   30,905 ( 0.00%)  1,121 ( 0.00%)  84 ( 0.00%)    12,362 ( 0.00%)   0            0              6,181 ( 0.00%)   0            0                       double iR = i - iQ;
   12,362 ( 0.00%)      0            0              6,181 ( 0.00%)   0            0                  0            0            0                       if(iQ<0)
        .               .            .                  .            .            .                  .            .            .                           iQ = 0;
   61,810 ( 0.00%)  1,125 ( 0.00%)  84 ( 0.00%)    12,362 ( 0.00%)   0            0              6,181 ( 0.00%)   0            0                       else if( (unsigned int) iQ >= sampling_.size())
        .               .            .                  .            .            .                  .            .            .                           iQ = static_cast<int>(sampling_.size()) - 1;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           
   67,991 ( 0.00%)    105 ( 0.00%)  84 ( 0.00%)    12,362 ( 0.00%)   0            0              6,181 ( 0.00%)   0            0                       if( (unsigned int) iQ == sampling_.size()-1)
        .               .            .                  .            .            .                  .            .            .                           return sampling_.back(); // = D_
        .               .            .                  .            .            .                  .            .            .                       else
  259,602 ( 0.00%)  2,722 ( 0.01%) 336 ( 0.00%)    43,267 ( 0.00%)   0            0             43,267 ( 0.00%)   0            0                           return (1-iR)*sampling_[iQ] + iR*sampling_[iQ+1];
   43,267 ( 0.00%)      0            0             37,086 ( 0.00%)   0            0                  0            0            0                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               private:
   29,190 ( 0.00%)  3,013 ( 0.01%) 188 ( 0.00%)     2,919 ( 0.00%)   0            0             14,595 ( 0.00%)   0            0                   Eigen::Vector2d pos(double u)
        .               .            .                  .            .            .                  .            .            .                   {
  242,277 ( 0.00%) 17,608 ( 0.03%) 658 ( 0.01%)    70,056 ( 0.00%)  10 ( 0.00%)  10 ( 0.00%)    35,028 ( 0.00%)   0            0                       return (1-u)*(1-u)*(1-u)*P0_ + 3*(1-u)*(1-u)*u*P1_ + 3*(1-u)*u*u*P2_ + u*u*u*P3_;
   17,514 ( 0.00%)  2,919 ( 0.01%)  94 ( 0.00%)    14,595 ( 0.00%)   0            0                  0            0            0                   }
        .               .            .                  .            .            .                  .            .            .           
   29,190 ( 0.00%)    114 ( 0.00%) 114 ( 0.00%)     2,919 ( 0.00%)   0            0             14,595 ( 0.00%)   0            0                   Eigen::Vector2d der(double u)
        .               .            .                  .            .            .                  .            .            .                   {
  236,439 ( 0.00%)  6,662 ( 0.01%) 564 ( 0.01%)    43,785 ( 0.00%)   0            0             40,866 ( 0.00%)   0            0                       return 3*( (1-u)*(1-u)*(P1_-P0_) + 2*(1-u)*u*(P2_-P1_) + u*u*(P3_-P2_) );
   17,514 ( 0.00%)      0            0             14,595 ( 0.00%)   0            0                  0            0            0                   }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .                   Eigen::Vector2d P0_, P1_, P2_, P3_;
        .               .            .                  .            .            .                  .            .            .                   std::vector<Eigen::Vector2d,Eigen::aligned_allocator<Eigen::Vector2d> > sampling_;
        .               .            .                  .            .            .                  .            .            .               public:
    1,880 ( 0.00%)     69 ( 0.00%)  66 ( 0.00%)       564 ( 0.00%)   0            0                564 ( 0.00%)   0            0                   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
        .               .            .                  .            .            .                  .            .            .               };
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               class QuarticBezierFitter: public Fitter
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .               public:
        .               .            .                  .            .            .                  .            .            .                   QuarticBezierFitter(const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds) :
        .               .            .                  .            .            .                  .            .            .                       Fitter(p,j,N, ds)
        .               .            .                  .            .            .                  .            .            .                   {
-- line 2001 ----------------------------------------
-- line 2116 ----------------------------------------
        .               .            .                  .            .            .                  .            .            .                   CUBIC_BEZIER_FITTER,
        .               .            .                  .            .            .                  .            .            .                   QUARTIC_BEZIER_FITTER,
        .               .            .                  .            .            .                  .            .            .                   CLOTHOID_FITTER
        .               .            .                  .            .            .                  .            .            .               };
        .               .            .                  .            .            .                  .            .            .               FitterType fitterType_;
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Create a new Fitter object (call the appropriate derived constructor)
        .               .            .                  .            .            .                  .            .            .               // It is caller's responsability to call "delete" to free the memory
    1,034 ( 0.00%)      0            0                  0            0            0                752 ( 0.00%)   0            0               static Fitter * fitter(FitterType /*type*/, const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds)
        .               .            .                  .            .            .                  .            .            .               {
        .               .            .                  .            .            .                  .            .            .                   /*
        .               .            .                  .            .            .                  .            .            .                   switch(type)
        .               .            .                  .            .            .                  .            .            .                   {
        .               .            .                  .            .            .                  .            .            .                   case CUBIC_BEZIER_FITTER:
        .               .            .                  .            .            .                  .            .            .                       return new CubicBezierFitter(p, j, N, ds);
        .               .            .                  .            .            .                  .            .            .                   case QUARTIC_BEZIER_FITTER:
        .               .            .                  .            .            .                  .            .            .                       return new QuarticBezierFitter(p, j, N, ds);
        .               .            .                  .            .            .                  .            .            .                   }
        .               .            .                  .            .            .                  .            .            .                   */
    1,222 ( 0.00%)    188 ( 0.00%)  94 ( 0.00%)       376 ( 0.00%)   0            0                188 ( 0.00%)   0            0                   return new CubicBezierFitter(p, j, N, ds);
      470 ( 0.00%)      0            0                376 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .               // Sampling
        .               .            .                  .            .            .                  .            .            .               double ds_;
        .               .            .                  .            .            .                  .            .            .               double lastDs_;
      396 ( 0.00%)      5 ( 0.00%)   0                132 ( 0.00%)   0            0                132 ( 0.00%)   0            0               void setDirtyArclengths_()   const { dirtyArclengths_ = true; }
   13,044 ( 0.00%)    559 ( 0.00%)  80 ( 0.00%)         0            0            0              6,522 ( 0.00%)   0            0               void precomputeArclengths_() const
        .               .            .                  .            .            .                  .            .            .               {
   10,870 ( 0.00%)      0            0              4,348 ( 0.00%)  95 ( 0.00%)  74 ( 0.00%)         0            0            0                   if(!dirtyArclengths_)
    2,150 ( 0.00%)    385 ( 0.00%)  25 ( 0.00%)         0            0            0                  0            0            0                       return;
        .               .            .                  .            .            .                  .            .            .           
       96 ( 0.00%)      0            0                 24 ( 0.00%)   0            0                 48 ( 0.00%)   0            0                   int n = size();
       48 ( 0.00%)      0            0                 24 ( 0.00%)   0            0                  0            0            0                   assert(n>0);
        .               .            .                  .            .            .                  .            .            .           
      168 ( 0.00%)     24 ( 0.00%)  15 ( 0.00%)        48 ( 0.00%)   0            0                 24 ( 0.00%)   0            0                   arclengths_.resize(n);
      168 ( 0.00%)     24 ( 0.00%)  15 ( 0.00%)        24 ( 0.00%)   0            0                 48 ( 0.00%)   7 ( 0.00%)   7 ( 0.00%)          arclengths_[0] = 0;
    4,928 ( 0.00%)     24 ( 0.00%)  15 ( 0.00%)     3,654 ( 0.00%)   0            0                 24 ( 0.00%)   0            0                   for(int i=1; i<n; ++i)
   48,080 ( 0.00%)     24 ( 0.00%)  15 ( 0.00%)    13,222 ( 0.00%)   0            0              9,616 ( 0.00%)  63 ( 0.00%)  56 ( 0.00%)              arclengths_[i] = arclengths_[i-1] + vertices_[i-1].distanceTo(vertices_[i]);
        .               .            .                  .            .            .                  .            .            .           
       72 ( 0.00%)     24 ( 0.00%)  15 ( 0.00%)        24 ( 0.00%)   0            0                 24 ( 0.00%)   0            0                   dirtyArclengths_ = false;
    6,522 ( 0.00%)      0            0              6,522 ( 0.00%)   0            0                  0            0            0               }
        .               .            .                  .            .            .                  .            .            .           public:
        .               .            .                  .            .            .                  .            .            .               EIGEN_MAKE_ALIGNED_OPERATOR_NEW
        .               .            .                  .            .            .                  .            .            .           };
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           } // end namespace SculptCurve
        .               .            .                  .            .            .                  .            .            .           
        .               .            .                  .            .            .                  .            .            .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/XprHelper.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw           DLmw       

-- line 118 ----------------------------------------
         .               .              .                   .          .          .                   .              .          .           
         .               .              .                   .          .          .                   .              .          .           /** \internal If the template parameter Value is Dynamic, this class is just a wrapper around a T variable that
         .               .              .                   .          .          .                   .              .          .             * can be accessed using value() and setValue().
         .               .              .                   .          .          .                   .              .          .             * Otherwise, this class is an empty structure and value() just returns the template parameter Value.
         .               .              .                   .          .          .                   .              .          .             */
         .               .              .                   .          .          .                   .              .          .           template<typename T, int Value> class variable_if_dynamic
         .               .              .                   .          .          .                   .              .          .           {
         .               .              .                   .          .          .                   .              .          .             public:
 2,489,168 ( 0.03%)  1,317 ( 0.00%)   612 ( 0.01%)    622,292 ( 0.03%) 0          0             933,438 ( 0.07%) 1,210 ( 0.00%) 0               EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamic)
50,086,630 ( 0.67%) 15,821 ( 0.03%) 2,891 ( 0.04%) 13,659,990 ( 0.74%) 0          0          13,659,990 ( 1.02%)     0          0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }
 5,552,682 ( 0.07%)  3,560 ( 0.01%) 1,003 ( 0.01%)  1,850,894 ( 0.10%) 0          0             925,447 ( 0.07%)     0          0               EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }
         .               .              .                   .          .          .                   .              .          .               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
         .               .              .                   .          .          .                   .              .          .           };
         .               .              .                   .          .          .                   .              .          .           
         .               .              .                   .          .          .                   .              .          .           template<typename T> class variable_if_dynamic<T, Dynamic>
         .               .              .                   .          .          .                   .              .          .           {
         .               .              .                   .          .          .                   .              .          .               T m_value;
         .               .              .                   .          .          .                   .              .          .               EIGEN_DEVICE_FUNC variable_if_dynamic() { eigen_assert(false); }
         .               .              .                   .          .          .                   .              .          .             public:
   380,050 ( 0.01%)    832 ( 0.00%)   346 ( 0.00%)    138,200 ( 0.01%) 0          0             138,200 ( 0.01%)    33 ( 0.00%) 0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T value) : m_value(value) {}
   292,800 ( 0.00%)    328 ( 0.00%)   306 ( 0.00%)    146,400 ( 0.01%) 0          0              73,200 ( 0.01%)    33 ( 0.00%) 0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T value() const { return m_value; }
         .               .              .                   .          .          .                   .              .          .               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T value) { m_value = value; }
         .               .              .                   .          .          .                   .              .          .           };
         .               .              .                   .          .          .                   .              .          .           
         .               .              .                   .          .          .                   .              .          .           /** \internal like variable_if_dynamic but for DynamicIndex
         .               .              .                   .          .          .                   .              .          .             */
         .               .              .                   .          .          .                   .              .          .           template<typename T, int Value> class variable_if_dynamicindex
         .               .              .                   .          .          .                   .              .          .           {
         .               .              .                   .          .          .                   .              .          .             public:
         .               .              .                   .          .          .                   .              .          .               EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamicindex)
     8,030 ( 0.00%)    365 ( 0.00%)    43 ( 0.00%)      2,190 ( 0.00%) 0          0               2,190 ( 0.00%)     0          0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamicindex(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }
    35,040 ( 0.00%)      0              0              11,680 ( 0.00%) 0          0               5,840 ( 0.00%)     0          0               EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }
         .               .              .                   .          .          .                   .              .          .               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
         .               .              .                   .          .          .                   .              .          .           };
         .               .              .                   .          .          .                   .              .          .           
         .               .              .                   .          .          .                   .              .          .           template<typename T> class variable_if_dynamicindex<T, DynamicIndex>
         .               .              .                   .          .          .                   .              .          .           {
         .               .              .                   .          .          .                   .              .          .               T m_value;
         .               .              .                   .          .          .                   .              .          .               EIGEN_DEVICE_FUNC variable_if_dynamicindex() { eigen_assert(false); }
         .               .              .                   .          .          .                   .              .          .             public:
-- line 157 ----------------------------------------
-- line 676 ----------------------------------------
         .               .              .                   .          .          .                   .              .          .           
         .               .              .                   .          .          .                   .              .          .           template<typename T1, typename T2>
         .               .              .                   .          .          .                   .              .          .           bool is_same_dense(const T1 &mat1, const T2 &mat2, typename enable_if<has_direct_access<T1>::ret&&has_direct_access<T2>::ret, T1>::type * = 0)
         .               .              .                   .          .          .                   .              .          .           {
         .               .              .                   .          .          .                   .              .          .             return (mat1.data()==mat2.data()) && (mat1.innerStride()==mat2.innerStride()) && (mat1.outerStride()==mat2.outerStride());
         .               .              .                   .          .          .                   .              .          .           }
         .               .              .                   .          .          .                   .              .          .           
         .               .              .                   .          .          .                   .              .          .           template<typename T1, typename T2>
       444 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0                 296 ( 0.00%)     0          0           bool is_same_dense(const T1 &, const T2 &, typename enable_if<!(has_direct_access<T1>::ret&&has_direct_access<T2>::ret), T1>::type * = 0)
         .               .              .                   .          .          .                   .              .          .           {
        74 ( 0.00%)      0              0                   0          0          0                   0              0          0             return false;
       148 ( 0.00%)      0              0                 148 ( 0.00%) 0          0                   0              0          0           }
         .               .              .                   .          .          .                   .              .          .           
         .               .              .                   .          .          .                   .              .          .           // Internal helper defining the cost of a scalar division for the type T.
         .               .              .                   .          .          .                   .              .          .           // The default heuristic can be specialized for each scalar type and architecture.
         .               .              .                   .          .          .                   .              .          .           template<typename T,bool Vectorized=false,typename EnaleIf = void>
         .               .              .                   .          .          .                   .              .          .           struct scalar_div_cost {
         .               .              .                   .          .          .                   .              .          .             enum { value = 8*NumTraits<T>::MulCost };
         .               .              .                   .          .          .                   .              .          .           };
         .               .              .                   .          .          .                   .              .          .           
-- line 695 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/EdgeSample.h
--------------------------------------------------------------------------------
Ir                 I1mr           ILmr         Dr                 D1mr         DLmr         Dw                 D1mw        DLmw       

-- line 17 ----------------------------------------
        .              .            .                  .            .            .                  .           .          .           #ifndef EDGESAMPLE_H
        .              .            .                  .            .            .                  .           .          .           #define EDGESAMPLE_H
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .           #include "Eigen.h"
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .           namespace VectorAnimationComplex
        .              .            .                  .            .            .                  .           .          .           {
        .              .            .                  .            .            .                  .           .          .           
4,683,896 ( 0.06%) 8,976 ( 0.02%) 418 ( 0.01%) 1,344,977 ( 0.07%)   0            0          1,338,256 ( 0.10%) 64 ( 0.00%) 0           class EdgeSample
        .              .            .                  .            .            .                  .           .          .           {
        .              .            .                  .            .            .                  .           .          .           public:
        .              .            .                  .            .            .                  .           .          .               // Access position
7,561,232 ( 0.10%)   517 ( 0.00%) 123 ( 0.00%) 2,160,352 ( 0.12%)  99 ( 0.00%)  93 ( 0.00%) 1,620,264 ( 0.12%)  0          0               inline double x() const { return d_[0]; }
7,561,232 ( 0.10%)   768 ( 0.00%) 142 ( 0.00%) 2,160,352 ( 0.12%)  55 ( 0.00%)  54 ( 0.00%) 1,620,264 ( 0.12%)  0          0               inline double y() const { return d_[1]; }
        .              .            .                  .            .            .                  .           .          .               inline Eigen::Vector2d pos() const { return Eigen::Vector2d(d_[0], d_[1]); }
   51,289 ( 0.00%) 5,820 ( 0.01%) 176 ( 0.00%)    15,085 ( 0.00%)   0            0             18,102 ( 0.00%)  0          0               inline void setX(double newX) { d_[0] = newX; }
   51,289 ( 0.00%) 2,911 ( 0.01%)  88 ( 0.00%)    15,085 ( 0.00%)   0            0             18,102 ( 0.00%)  0          0               inline void setY(double newY) { d_[1] = newY; }
        .              .            .                  .            .            .                  .           .          .               inline void setPos(double x, double y) { d_[0] = x; d_[1] = y; }
        .              .            .                  .            .            .                  .           .          .               inline void setPos(const Eigen::Vector2d& p) { d_[0] = p[0]; d_[1] = p[1]; }
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // Access width
  155,218 ( 0.00%) 3,667 ( 0.01%)  16 ( 0.00%)    44,348 ( 0.00%)  11 ( 0.00%)   0             33,261 ( 0.00%)  0          0               inline double width() const { return d_[2]; }
    9,724 ( 0.00%)    24 ( 0.00%)  10 ( 0.00%)     2,860 ( 0.00%)   0            0              3,432 ( 0.00%)  0          0               inline void setWidth(double newWidth) { d_[2] = newWidth; }
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // Constructor
   56,627 ( 0.00%) 5,559 ( 0.01%) 248 ( 0.00%)     9,993 ( 0.00%)   0            0             19,986 ( 0.00%)  0          0               EdgeSample(double x = 0, double y = 0, double w = 0): d_(x, y, w) {}
   87,304 ( 0.00%) 3,677 ( 0.01%) 112 ( 0.00%)    24,944 ( 0.00%)   0            0             24,944 ( 0.00%)  0          0               EdgeSample(const Eigen::Vector3d & d): d_(d) {}
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // Translate (keep width untouched)
        .              .            .                  .            .            .                  .           .          .               inline void translate(double x, double y) { d_[0] += x; d_[1] += y; }
        .              .            .                  .            .            .                  .           .          .               inline void translate(const Eigen::Vector2d& p) {d_[0] += p[0]; d_[1] += p[1]; }
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // Linear interpolation
   55,803 ( 0.00%) 1,009 ( 0.00%) 216 ( 0.00%)     5,073 ( 0.00%)   0            0             30,438 ( 0.00%)  1 ( 0.00%) 0               EdgeSample lerp(double u, const EdgeSample & other) const
        .              .            .                  .            .            .                  .           .          .               {
  162,336 ( 0.00%) 2,506 ( 0.00%) 320 ( 0.00%)    25,365 ( 0.00%)  63 ( 0.00%)  34 ( 0.00%)    30,438 ( 0.00%)  0          0                   return EdgeSample((1-u)*d_ + u*other.d_);
   30,438 ( 0.00%)     0            0             25,365 ( 0.00%)   0            0                  0           0          0               }
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // Distance, in R^2, between two samples
   36,846 ( 0.00%)   244 ( 0.00%)  45 ( 0.00%)         0            0            0             18,423 ( 0.00%)  0          0               double distanceTo(const EdgeSample & other) const
        .              .            .                  .            .            .                  .           .          .               {
   85,974 ( 0.00%)   216 ( 0.00%)  36 ( 0.00%)    30,705 ( 0.00%) 117 ( 0.00%) 108 ( 0.00%)    24,564 ( 0.00%)  0          0                   double dx = other.d_[0] - d_[0];
   85,974 ( 0.00%)     0            0             30,705 ( 0.00%)  53 ( 0.00%)  50 ( 0.00%)    24,564 ( 0.00%)  0          0                   double dy = other.d_[1] - d_[1];
   42,987 ( 0.00%)   214 ( 0.00%)  36 ( 0.00%)    12,282 ( 0.00%)   0            0              6,141 ( 0.00%)  0          0                   double res2 = dx*dx + dy*dy;
   24,564 ( 0.00%)     0            0              6,141 ( 0.00%)   0            0              6,141 ( 0.00%)  0          0                   return std::sqrt(res2);
   18,423 ( 0.00%)     0            0             12,282 ( 0.00%)   0            0                  0           0          0               }
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // Differential
        .              .            .                  .            .            .                  .           .          .               //
        .              .            .                  .            .            .                  .           .          .               // Note: adding two samples also adds their width! this is useful for
        .              .            .                  .            .            .                  .           .          .               // interpolation purposes, but if you want to translate a sample don't add
        .              .            .                  .            .            .                  .           .          .               // a new sample, instead use the translate() methods.
        .              .            .                  .            .            .                  .           .          .               //
    6,450 ( 0.00%)   826 ( 0.00%)  60 ( 0.00%)       645 ( 0.00%)   0            0              3,225 ( 0.00%)  0          0               EdgeSample operator-(const EdgeSample & other) const
        .              .            .                  .            .            .                  .           .          .               {
   10,320 ( 0.00%)   630 ( 0.00%)  28 ( 0.00%)     1,935 ( 0.00%)   0            0              1,935 ( 0.00%)  0          0                   return EdgeSample(d_ - other.d_);
    3,870 ( 0.00%)     0            0              3,225 ( 0.00%)   0            0                  0           0          0               }
    5,080 ( 0.00%)    16 ( 0.00%)  12 ( 0.00%)       508 ( 0.00%)   0            0              2,540 ( 0.00%)  0          0               EdgeSample operator+(const EdgeSample & other) const
        .              .            .                  .            .            .                  .           .          .               {
    8,128 ( 0.00%)    13 ( 0.00%)  10 ( 0.00%)     1,524 ( 0.00%)   0            0              1,524 ( 0.00%)  0          0                   return EdgeSample(d_ + other.d_);
    3,048 ( 0.00%)     0            0              2,540 ( 0.00%)   0            0                  0           0          0               }
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // For weighted sums
      100 ( 0.00%)     3 ( 0.00%)   2 ( 0.00%)        10 ( 0.00%)   0            0                 50 ( 0.00%)  0          0               EdgeSample operator*(double s) const
        .              .            .                  .            .            .                  .           .          .               {
      160 ( 0.00%)     0            0                 20 ( 0.00%)   0            0                 30 ( 0.00%)  0          0                   return EdgeSample(s * d_);
       60 ( 0.00%)     0            0                 50 ( 0.00%)   0            0                  0           0          0               }
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .               // Eigen alignement
   26,000 ( 0.00%)    76 ( 0.00%)  22 ( 0.00%)     7,800 ( 0.00%)   0            0              7,800 ( 0.00%)  0          0               EIGEN_MAKE_ALIGNED_OPERATOR_NEW
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .           private:
        .              .            .                  .            .            .                  .           .          .               // 2D position + width
        .              .            .                  .            .            .                  .           .          .               Eigen::Vector3d d_;
        .              .            .                  .            .            .                  .           .          .           };
        .              .            .                  .            .            .                  .           .          .           
        .              .            .                  .            .            .                  .           .          .           }
        .              .            .                  .            .            .                  .           .          .           
-- line 94 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw         DLmw        

-- line 37 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .               */
         .               .              .                   .          .          .                   .            .           .             typedef Eigen::Index Index;
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             // FIXME is it needed?
         .               .              .                   .          .          .                   .            .           .             typedef typename internal::traits<Derived>::StorageKind StorageKind;
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             /** \returns a reference to the derived object */
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
 3,424,183 ( 0.05%)  7,840 ( 0.02%) 2,083 ( 0.03%)  1,467,507 ( 0.08%) 0          0             978,338 ( 0.07%)   6 ( 0.00%)  0             Derived& derived() { return *static_cast<Derived*>(this); }
         .               .              .                   .          .          .                   .            .           .             /** \returns a const reference to the derived object */
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
89,956,272 ( 1.21%) 16,751 ( 0.03%) 4,811 ( 0.06%) 38,552,688 ( 2.10%) 0          0          25,701,792 ( 1.92%) 318 ( 0.00%) 12 ( 0.00%)    const Derived& derived() const { return *static_cast<const Derived*>(this); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
   344,988 ( 0.00%)  5,509 ( 0.01%)   930 ( 0.01%)          0          0          0             172,494 ( 0.01%)   0           0             inline Derived& const_cast_derived() const
   258,741 ( 0.00%)    635 ( 0.00%)   457 ( 0.01%)    258,741 ( 0.01%) 0          0                   0            0           0             { return *static_cast<Derived*>(const_cast<EigenBase*>(this)); }
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .             inline const Derived& const_derived() const
         .               .              .                   .          .          .                   .            .           .             { return *static_cast<const Derived*>(this); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             /** \returns the number of rows. \sa cols(), RowsAtCompileTime */
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
50,729,304 ( 0.68%) 20,000 ( 0.04%) 3,357 ( 0.04%) 12,682,326 ( 0.69%) 0          0          16,909,768 ( 1.27%) 362 ( 0.00%) 13 ( 0.00%)    inline Index rows() const { return derived().rows(); }
         .               .              .                   .          .          .                   .            .           .             /** \returns the number of columns. \sa rows(), ColsAtCompileTime*/
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
50,314,200 ( 0.68%)  8,232 ( 0.02%) 2,392 ( 0.03%) 12,578,550 ( 0.68%) 0          0          16,771,400 ( 1.26%)   0           0             inline Index cols() const { return derived().cols(); }
         .               .              .                   .          .          .                   .            .           .             /** \returns the number of coefficients, which is rows()*cols().
         .               .              .                   .          .          .                   .            .           .               * \sa rows(), cols(), SizeAtCompileTime. */
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
70,575,228 ( 0.95%)  8,868 ( 0.02%) 2,170 ( 0.03%) 20,757,420 ( 1.13%) 0          0          20,757,420 ( 1.55%)   2 ( 0.00%)  0             inline Index size() const { return rows() * cols(); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst = *this; \endcode */
         .               .              .                   .          .          .                   .            .           .             template<typename Dest>
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .             inline void evalTo(Dest& dst) const
         .               .              .                   .          .          .                   .            .           .             { derived().evalTo(dst); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst += *this; \endcode */
-- line 74 ----------------------------------------
-- line 92 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .               // derived class can reimplement it in a more optimized way.
         .               .              .                   .          .          .                   .            .           .               typename Dest::PlainObject res(rows(),cols());
         .               .              .                   .          .          .                   .            .           .               evalTo(res);
         .               .              .                   .          .          .                   .            .           .               dst -= res;
         .               .              .                   .          .          .                   .            .           .             }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst.applyOnTheRight(*this); \endcode */
         .               .              .                   .          .          .                   .            .           .             template<typename Dest>
       666 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)         74 ( 0.00%) 0          0                 296 ( 0.00%)   0           0             EIGEN_DEVICE_FUNC inline void applyThisOnTheRight(Dest& dst) const
         .               .              .                   .          .          .                   .            .           .             {
         .               .              .                   .          .          .                   .            .           .               // This is the default implementation,
         .               .              .                   .          .          .                   .            .           .               // derived class can reimplement it in a more optimized way.
     1,110 ( 0.00%)     74 ( 0.00%)     0                 222 ( 0.00%) 0          0                 370 ( 0.00%)   0           0               dst = dst * this->derived();
       444 ( 0.00%)      0              0                 296 ( 0.00%) 0          0                   0            0           0             }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst.applyOnTheLeft(*this); \endcode */
         .               .              .                   .          .          .                   .            .           .             template<typename Dest>
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC inline void applyThisOnTheLeft(Dest& dst) const
         .               .              .                   .          .          .                   .            .           .             {
         .               .              .                   .          .          .                   .            .           .               // This is the default implementation,
         .               .              .                   .          .          .                   .            .           .               // derived class can reimplement it in a more optimized way.
         .               .              .                   .          .          .                   .            .           .               dst = this->derived() * dst;
-- line 113 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/Meta.h
--------------------------------------------------------------------------------
Ir                  I1mr           ILmr         Dr                 D1mr       DLmr       Dw                 D1mw         DLmw        

-- line 299 ----------------------------------------
         .              .            .                  .          .          .                  .            .           .           /** \internal
         .              .            .                  .          .          .                  .            .           .             * A base class do disable default copy ctor and copy assignement operator.
         .              .            .                  .          .          .                  .            .           .             */
         .              .            .                  .          .          .                  .            .           .           class noncopyable
         .              .            .                  .          .          .                  .            .           .           {
         .              .            .                  .          .          .                  .            .           .             EIGEN_DEVICE_FUNC noncopyable(const noncopyable&);
         .              .            .                  .          .          .                  .            .           .             EIGEN_DEVICE_FUNC const noncopyable& operator=(const noncopyable&);
         .              .            .                  .          .          .                  .            .           .           protected:
32,208,400 ( 0.43%) 1,580 ( 0.00%) 352 ( 0.00%) 9,202,400 ( 0.50%) 0          0          9,202,400 ( 0.69%) 174 ( 0.00%) 20 ( 0.00%)    EIGEN_DEVICE_FUNC noncopyable() {}
32,208,400 ( 0.43%)     0            0          9,202,400 ( 0.50%) 0          0          9,202,400 ( 0.69%)   0           0             EIGEN_DEVICE_FUNC ~noncopyable() {}
         .              .            .                  .          .          .                  .            .           .           };
         .              .            .                  .          .          .                  .            .           .           
         .              .            .                  .          .          .                  .            .           .           /** \internal
         .              .            .                  .          .          .                  .            .           .             * Convenient struct to get the result type of a unary or binary functor.
         .              .            .                  .          .          .                  .            .           .             *
         .              .            .                  .          .          .                  .            .           .             * It supports both the current STL mechanism (using the result_type member) as well as
         .              .            .                  .          .          .                  .            .           .             * upcoming next STL generation (using a templated result member).
         .              .            .                  .          .          .                  .            .           .             * If none of these members is provided, then the type of the first argument is returned. FIXME, that behavior is a pretty bad hack.
-- line 316 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h
--------------------------------------------------------------------------------
Ir                  I1mr           ILmr           Dr                  D1mr           DLmr           Dw                 D1mw            DLmw            

-- line 21 ----------------------------------------
         .              .              .                   .              .              .                  .               .               .           namespace Eigen {
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           namespace internal {
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           struct constructor_without_unaligned_array_assert {};
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           template<typename T, int Size>
         .              .              .                   .              .              .                  .               .               .           EIGEN_DEVICE_FUNC
   293,544 ( 0.00%) 3,125 ( 0.01%) 1,006 ( 0.01%)          0              0              0             97,848 ( 0.01%)      0               0           void check_static_allocation_size()
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .             // if EIGEN_STACK_ALLOCATION_LIMIT is defined to 0, then no limit
         .              .              .                   .              .              .                  .               .               .             #if EIGEN_STACK_ALLOCATION_LIMIT
         .              .              .                   .              .              .                  .               .               .             EIGEN_STATIC_ASSERT(Size * sizeof(T) <= EIGEN_STACK_ALLOCATION_LIMIT, OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG);
         .              .              .                   .              .              .                  .               .               .             #endif
   293,544 ( 0.00%) 1,412 ( 0.00%)   351 ( 0.00%)    195,696 ( 0.01%)     0              0                  0               0               0           }
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           /** \internal
         .              .              .                   .              .              .                  .               .               .             * Static array. If the MatrixOrArrayOptions require auto-alignment, the array will be automatically aligned:
         .              .              .                   .              .              .                  .               .               .             * to 16 bytes boundary if the total size is a multiple of 16 bytes.
         .              .              .                   .              .              .                  .               .               .             */
         .              .              .                   .              .              .                  .               .               .           template <typename T, int Size, int MatrixOrArrayOptions,
         .              .              .                   .              .              .                  .               .               .                     int Alignment = (MatrixOrArrayOptions&DontAlign) ? 0
         .              .              .                   .              .              .                  .               .               .                                   : compute_default_alignment<T,Size>::value >
         .              .              .                   .              .              .                  .               .               .           struct plain_array
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .             T array[Size];
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .             EIGEN_DEVICE_FUNC
    56,260 ( 0.00%) 3,611 ( 0.01%)   339 ( 0.00%)          0              0              0             22,504 ( 0.00%)      0               0             plain_array()
         .              .              .                   .              .              .                  .               .               .             { 
    11,252 ( 0.00%)     0              0                   0              0              0             11,252 ( 0.00%)      0               0               check_static_allocation_size<T,Size>();
    33,756 ( 0.00%)     0              0              22,504 ( 0.00%)     0              0                  0               0               0             }
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .             EIGEN_DEVICE_FUNC
         .              .              .                   .              .              .                  .               .               .             plain_array(constructor_without_unaligned_array_assert)
         .              .              .                   .              .              .                  .               .               .             { 
         .              .              .                   .              .              .                  .               .               .               check_static_allocation_size<T,Size>();
         .              .              .                   .              .              .                  .               .               .             }
         .              .              .                   .              .              .                  .               .               .           };
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           #if defined(EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT)
         .              .              .                   .              .              .                  .               .               .             #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask)
         .              .              .                   .              .              .                  .               .               .           #elif EIGEN_GNUC_AT_LEAST(4,7) 
         .              .              .                   .              .              .                  .               .               .             // GCC 4.7 is too aggressive in its optimizations and remove the alignement test based on the fact the array is declared to be aligned.
         .              .              .                   .              .              .                  .               .               .             // See this bug report: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53900
         .              .              .                   .              .              .                  .               .               .             // Hiding the origin of the array pointer behind a function argument seems to do the trick even if the function is inlined:
         .              .              .                   .              .              .                  .               .               .             template<typename PtrType>
    86,596 ( 0.00%) 1,553 ( 0.00%)   321 ( 0.00%)     86,596 ( 0.00%)     0              0                  0               0               0             EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }
         .              .              .                   .              .              .                  .               .               .             #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
         .              .              .                   .              .              .                  .               .               .               eigen_assert((internal::UIntPtr(eigen_unaligned_array_assert_workaround_gcc47(array)) & (sizemask)) == 0 \
         .              .              .                   .              .              .                  .               .               .                         && "this assertion is explained here: " \
         .              .              .                   .              .              .                  .               .               .                         "http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html" \
         .              .              .                   .              .              .                  .               .               .                         " **** READ THIS WEB PAGE !!! ****");
         .              .              .                   .              .              .                  .               .               .           #else
         .              .              .                   .              .              .                  .               .               .             #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
         .              .              .                   .              .              .                  .               .               .               eigen_assert((internal::UIntPtr(array) & (sizemask)) == 0 \
-- line 76 ----------------------------------------
-- line 99 ----------------------------------------
         .              .              .                   .              .              .                  .               .               .           };
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           template <typename T, int Size, int MatrixOrArrayOptions>
         .              .              .                   .              .              .                  .               .               .           struct plain_array<T, Size, MatrixOrArrayOptions, 16>
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .             EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .             EIGEN_DEVICE_FUNC
   432,980 ( 0.01%) 2,991 ( 0.01%)   971 ( 0.01%)          0              0              0            173,192 ( 0.01%)     28 ( 0.00%)      0             plain_array() 
         .              .              .                   .              .              .                  .               .               .             { 
   432,980 ( 0.01%)     0              0              86,596 ( 0.00%)     0              0             86,596 ( 0.01%)      0               0               EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(15);
    86,596 ( 0.00%) 1,719 ( 0.00%)   661 ( 0.01%)          0              0              0             86,596 ( 0.01%)     33 ( 0.00%)      0               check_static_allocation_size<T,Size>();
   259,788 ( 0.00%)     0              0             173,192 ( 0.01%)     0              0                  0               0               0             }
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .             EIGEN_DEVICE_FUNC
         .              .              .                   .              .              .                  .               .               .             plain_array(constructor_without_unaligned_array_assert) 
         .              .              .                   .              .              .                  .               .               .             { 
         .              .              .                   .              .              .                  .               .               .               check_static_allocation_size<T,Size>();
         .              .              .                   .              .              .                  .               .               .             }
         .              .              .                   .              .              .                  .               .               .           };
         .              .              .                   .              .              .                  .               .               .           
-- line 119 ----------------------------------------
-- line 179 ----------------------------------------
         .              .              .                   .              .              .                  .               .               .             */
         .              .              .                   .              .              .                  .               .               .           template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage;
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           // purely fixed-size matrix
         .              .              .                   .              .              .                  .               .               .           template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .               internal::plain_array<T,Size,_Options> m_data;
         .              .              .                   .              .              .                  .               .               .             public:
   782,784 ( 0.01%) 1,389 ( 0.00%)   351 ( 0.00%)     97,848 ( 0.01%)     0              0            293,544 ( 0.02%)      0               0               EIGEN_DEVICE_FUNC DenseStorage() {
         .              .              .                   .              .              .                  .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
   293,544 ( 0.00%)     0              0             195,696 ( 0.01%)     0              0                  0               0               0               }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC
         .              .              .                   .              .              .                  .               .               .               explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
         .              .              .                   .              .              .                  .               .               .                 : m_data(internal::constructor_without_unaligned_array_assert()) {}
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC 
 4,977,474 ( 0.07%) 3,861 ( 0.01%)   305 ( 0.00%)  1,901,103 ( 0.10%) 9,123 ( 0.01%) 4,375 ( 0.00%) 2,292,859 ( 0.17%) 17,431 ( 0.01%) 11,750 ( 0.01%)      DenseStorage(const DenseStorage& other) : m_data(other.m_data) {
         .              .              .                   .              .              .                  .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
 1,175,268 ( 0.02%)     0              0             783,512 ( 0.04%)     0              0                  0               0               0               }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC 
         .              .              .                   .              .              .                  .               .               .               DenseStorage& operator=(const DenseStorage& other)
         .              .              .                   .              .              .                  .               .               .               { 
         .              .              .                   .              .              .                  .               .               .                 if (this != &other) m_data = other.m_data;
         .              .              .                   .              .              .                  .               .               .                 return *this; 
         .              .              .                   .              .              .                  .               .               .               }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {
         .              .              .                   .              .              .                  .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .              .              .                   .              .              .                  .               .               .                 eigen_internal_assert(size==rows*cols && rows==_Rows && cols==_Cols);
         .              .              .                   .              .              .                  .               .               .                 EIGEN_UNUSED_VARIABLE(size);
         .              .              .                   .              .              .                  .               .               .                 EIGEN_UNUSED_VARIABLE(rows);
         .              .              .                   .              .              .                  .               .               .                 EIGEN_UNUSED_VARIABLE(cols);
         .              .              .                   .              .              .                  .               .               .               }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }
28,055,502 ( 0.38%) 1,430 ( 0.00%)   702 ( 0.01%)  9,351,834 ( 0.51%)     0              0          4,675,917 ( 0.35%)      0               0               EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
27,892,236 ( 0.38%) 4,525 ( 0.01%)   659 ( 0.01%)  9,297,412 ( 0.51%)     0              0          4,648,706 ( 0.35%)      0               0               EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}
   369,670 ( 0.00%)   516 ( 0.00%)   125 ( 0.00%)     73,934 ( 0.00%)     0              0            184,835 ( 0.01%)     82 ( 0.00%)     10 ( 0.00%)      EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}
30,645,468 ( 0.41%) 4,264 ( 0.01%) 1,047 ( 0.01%) 13,133,772 ( 0.71%)     0              0          8,755,848 ( 0.66%)      0               0               EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
   464,520 ( 0.01%) 1,456 ( 0.00%)   678 ( 0.01%)    199,080 ( 0.01%)     0              0            132,720 ( 0.01%)     14 ( 0.00%)     12 ( 0.00%)      EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
         .              .              .                   .              .              .                  .               .               .           };
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           // null matrix
         .              .              .                   .              .              .                  .               .               .           template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .             public:
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC DenseStorage() {}
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) {}
-- line 224 ----------------------------------------
-- line 336 ----------------------------------------
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           // purely dynamic matrix.
         .              .              .                   .              .              .                  .               .               .           template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .               T *m_data;
         .              .              .                   .              .              .                  .               .               .               Index m_rows;
         .              .              .                   .              .              .                  .               .               .               Index m_cols;
         .              .              .                   .              .              .                  .               .               .             public:
     4,810 ( 0.00%)   148 ( 0.00%)    74 ( 0.00%)      1,850 ( 0.00%)     0              0              1,850 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
         .              .              .                   .              .              .                  .               .               .                  : m_data(0), m_rows(0), m_cols(0) {}
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols)
         .              .              .                   .              .              .                  .               .               .                 : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows), m_cols(cols)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .              .              .                   .              .              .                  .               .               .                 eigen_internal_assert(size==rows*cols && rows>=0 && cols >=0);
         .              .              .                   .              .              .                  .               .               .               }
       444 ( 0.00%)    74 ( 0.00%)    74 ( 0.00%)          0              0              0                222 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
       666 ( 0.00%)     0              0                 370 ( 0.00%)     0              0                148 ( 0.00%)      0               0                 : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*other.m_cols))
       296 ( 0.00%)    74 ( 0.00%)    74 ( 0.00%)        222 ( 0.00%)     0              0                 74 ( 0.00%)      0               0                 , m_rows(other.m_rows)
       296 ( 0.00%)     0              0                 222 ( 0.00%)     0              0                 74 ( 0.00%)      0               0                 , m_cols(other.m_cols)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*m_cols)
     1,184 ( 0.00%)    74 ( 0.00%)     0                 740 ( 0.00%)     0              0                 74 ( 0.00%)      0               0                 internal::smart_copy(other.m_data, other.m_data+other.m_rows*other.m_cols, m_data);
       222 ( 0.00%)     0              0                 148 ( 0.00%)     0              0                  0               0               0               }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 if (this != &other)
         .              .              .                   .              .              .                  .               .               .                 {
         .              .              .                   .              .              .                  .               .               .                   DenseStorage tmp(other);
         .              .              .                   .              .              .                  .               .               .                   this->swap(tmp);
         .              .              .                   .              .              .                  .               .               .                 }
         .              .              .                   .              .              .                  .               .               .                 return *this;
-- line 368 ----------------------------------------
-- line 383 ----------------------------------------
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 using std::swap;
         .              .              .                   .              .              .                  .               .               .                 swap(m_data, other.m_data);
         .              .              .                   .              .              .                  .               .               .                 swap(m_rows, other.m_rows);
         .              .              .                   .              .              .                  .               .               .                 swap(m_cols, other.m_cols);
         .              .              .                   .              .              .                  .               .               .                 return *this;
         .              .              .                   .              .              .                  .               .               .               }
         .              .              .                   .              .              .                  .               .               .           #endif
     8,436 ( 0.00%)   149 ( 0.00%)     0               3,552 ( 0.00%)     0              0              1,332 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC void swap(DenseStorage& other)
         .              .              .                   .              .              .                  .               .               .               { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
   144,704 ( 0.00%)    74 ( 0.00%)    74 ( 0.00%)     72,352 ( 0.00%)     0              0             36,176 ( 0.00%)     35 ( 0.00%)      0               EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
    82,784 ( 0.00%)    74 ( 0.00%)     0              41,392 ( 0.00%)     0              0             20,696 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
         .              .              .                   .              .              .                  .               .               .               void conservativeResize(Index size, Index rows, Index cols)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*m_cols);
         .              .              .                   .              .              .                  .               .               .                 m_rows = rows;
         .              .              .                   .              .              .                  .               .               .                 m_cols = cols;
         .              .              .                   .              .              .                  .               .               .               }
     3,472 ( 0.00%)   148 ( 0.00%)    74 ( 0.00%)          0              0              0              2,170 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC void resize(Index size, Index rows, Index cols)
         .              .              .                   .              .              .                  .               .               .               {
     3,038 ( 0.00%)   148 ( 0.00%)    74 ( 0.00%)      2,170 ( 0.00%)     0              0                  0               0               0                 if(size != m_rows*m_cols)
         .              .              .                   .              .              .                  .               .               .                 {
     4,774 ( 0.00%)     0              0               2,604 ( 0.00%)     0              0                434 ( 0.00%)      0               0                   internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols);
       868 ( 0.00%)   187 ( 0.00%)    74 ( 0.00%)        434 ( 0.00%)     0              0                  0               0               0                   if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative
     2,604 ( 0.00%)     0              0                 868 ( 0.00%)     0              0                868 ( 0.00%)      0               0                     m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
         .              .              .                   .              .              .                  .               .               .                   else
         .              .              .                   .              .              .                  .               .               .                     m_data = 0;
         .              .              .                   .              .              .                  .               .               .                   EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .              .              .                   .              .              .                  .               .               .                 }
     1,302 ( 0.00%)     0              0                 868 ( 0.00%)     0              0                434 ( 0.00%)      0               0                 m_rows = rows;
     1,302 ( 0.00%)     0              0                 868 ( 0.00%)     0              0                434 ( 0.00%)      0               0                 m_cols = cols;
     1,302 ( 0.00%)   188 ( 0.00%)    74 ( 0.00%)        868 ( 0.00%)     0              0                  0               0               0               }
    45,392 ( 0.00%)    74 ( 0.00%)    74 ( 0.00%)     22,696 ( 0.00%)     0              0             11,348 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC const T *data() const { return m_data; }
     5,048 ( 0.00%)   113 ( 0.00%)    74 ( 0.00%)      2,524 ( 0.00%)     0              0              1,262 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC T *data() { return m_data; }
         .              .              .                   .              .              .                  .               .               .           };
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           // matrix with dynamic width and fixed height (so that matrix has dynamic size).
         .              .              .                   .              .              .                  .               .               .           template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .               T *m_data;
         .              .              .                   .              .              .                  .               .               .               Index m_cols;
         .              .              .                   .              .              .                  .               .               .             public:
-- line 425 ----------------------------------------
-- line 492 ----------------------------------------
         .              .              .                   .              .              .                  .               .               .           };
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           // matrix with dynamic height and fixed width (so that matrix has dynamic size).
         .              .              .                   .              .              .                  .               .               .           template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>
         .              .              .                   .              .              .                  .               .               .           {
         .              .              .                   .              .              .                  .               .               .               T *m_data;
         .              .              .                   .              .              .                  .               .               .               Index m_rows;
         .              .              .                   .              .              .                  .               .               .             public:
     3,256 ( 0.00%)   218 ( 0.00%)   183 ( 0.00%)      1,184 ( 0.00%)     0              0              1,184 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0) {}
         .              .              .                   .              .              .                  .               .               .               explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .              .              .                   .              .              .                  .               .               .                 eigen_internal_assert(size==rows*cols && rows>=0 && cols == _Cols);
         .              .              .                   .              .              .                  .               .               .                 EIGEN_UNUSED_VARIABLE(cols);
         .              .              .                   .              .              .                  .               .               .               }
       888 ( 0.00%)     0              0                   0              0              0                444 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
       888 ( 0.00%)    74 ( 0.00%)    74 ( 0.00%)        444 ( 0.00%)     0              0                296 ( 0.00%)      0               0                 : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*_Cols))
       592 ( 0.00%)     0              0                 444 ( 0.00%)     0              0                148 ( 0.00%)      0               0                 , m_rows(other.m_rows)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*_Cols)
     1,924 ( 0.00%)    74 ( 0.00%)    74 ( 0.00%)      1,184 ( 0.00%)     0              0                148 ( 0.00%)      0               0                 internal::smart_copy(other.m_data, other.m_data+other.m_rows*_Cols, m_data);
       444 ( 0.00%)     0              0                 296 ( 0.00%)     0              0                  0               0               0               }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 if (this != &other)
         .              .              .                   .              .              .                  .               .               .                 {
         .              .              .                   .              .              .                  .               .               .                   DenseStorage tmp(other);
         .              .              .                   .              .              .                  .               .               .                   this->swap(tmp);
         .              .              .                   .              .              .                  .               .               .                 }
         .              .              .                   .              .              .                  .               .               .                 return *this;
-- line 522 ----------------------------------------
-- line 534 ----------------------------------------
         .              .              .                   .              .              .                  .               .               .               DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 using std::swap;
         .              .              .                   .              .              .                  .               .               .                 swap(m_data, other.m_data);
         .              .              .                   .              .              .                  .               .               .                 swap(m_rows, other.m_rows);
         .              .              .                   .              .              .                  .               .               .                 return *this;
         .              .              .                   .              .              .                  .               .               .               }
         .              .              .                   .              .              .                  .               .               .           #endif
     7,104 ( 0.00%)    74 ( 0.00%)     0               2,664 ( 0.00%)     0              0              1,332 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }
         .              .              .                   .              .              .                  .               .               .               EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
    20,800 ( 0.00%)   148 ( 0.00%)   148 ( 0.00%)     10,400 ( 0.00%)     0              0              5,200 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
    16,932 ( 0.00%)     0              0               5,644 ( 0.00%)     0              0              2,822 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
         .              .              .                   .              .              .                  .               .               .               void conservativeResize(Index size, Index rows, Index)
         .              .              .                   .              .              .                  .               .               .               {
         .              .              .                   .              .              .                  .               .               .                 m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*_Cols);
         .              .              .                   .              .              .                  .               .               .                 m_rows = rows;
         .              .              .                   .              .              .                  .               .               .               }
     3,552 ( 0.00%)    56 ( 0.00%)    35 ( 0.00%)          0              0              0              2,220 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index rows, Index)
         .              .              .                   .              .              .                  .               .               .               {
     1,776 ( 0.00%)     0              0               1,332 ( 0.00%)     0              0                  0               0               0                 if(size != m_rows*_Cols)
         .              .              .                   .              .              .                  .               .               .                 {
     2,368 ( 0.00%)   222 ( 0.00%)   148 ( 0.00%)      1,184 ( 0.00%)     0              0                296 ( 0.00%)      0               0                   internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows);
       592 ( 0.00%)     0              0                 296 ( 0.00%)     0              0                  0               0               0                   if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative
     1,776 ( 0.00%)     0              0                 592 ( 0.00%)     0              0                592 ( 0.00%)      0               0                     m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
         .              .              .                   .              .              .                  .               .               .                   else
         .              .              .                   .              .              .                  .               .               .                     m_data = 0;
         .              .              .                   .              .              .                  .               .               .                   EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .              .              .                   .              .              .                  .               .               .                 }
     1,332 ( 0.00%)    74 ( 0.00%)     0                 888 ( 0.00%)     0              0                444 ( 0.00%)      0               0                 m_rows = rows;
     1,332 ( 0.00%)   148 ( 0.00%)    74 ( 0.00%)        888 ( 0.00%)     0              0                  0               0               0               }
    14,880 ( 0.00%)     0              0               7,440 ( 0.00%)     0              0              3,720 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC const T *data() const { return m_data; }
     9,472 ( 0.00%)   148 ( 0.00%)   148 ( 0.00%)      4,736 ( 0.00%)     0              0              2,368 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC T *data() { return m_data; }
         .              .              .                   .              .              .                  .               .               .           };
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           } // end namespace Eigen
         .              .              .                   .              .              .                  .               .               .           
         .              .              .                   .              .              .                  .               .               .           #endif // EIGEN_MATRIX_H

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw         DLmw        

-- line 26 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           namespace internal {
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {
         .               .              .                   .          .          .                   .            .           .             template<typename Index>
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .             static EIGEN_ALWAYS_INLINE void run(Index, Index)
         .               .              .                   .          .          .                   .            .           .             {
    73,934 ( 0.00%)     94 ( 0.00%)    94 ( 0.00%)          0          0          0                   0            0           0             }
         .               .              .                   .          .          .                   .            .           .           };
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           template<> struct check_rows_cols_for_overflow<Dynamic> {
         .               .              .                   .          .          .                   .            .           .             template<typename Index>
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .             static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)
         .               .              .                   .          .          .                   .            .           .             {
         .               .              .                   .          .          .                   .            .           .               // http://hg.mozilla.org/mozilla-central/file/6c8a909977d3/xpcom/ds/CheckedInt.h#l242
         .               .              .                   .          .          .                   .            .           .               // we assume Index is signed
     1,312 ( 0.00%)    148 ( 0.00%)    74 ( 0.00%)          0          0          0                 656 ( 0.00%)   0           0               Index max_index = (std::size_t(1) << (8 * sizeof(Index) - 1)) - 1; // assume Index is signed
     5,248 ( 0.00%)    148 ( 0.00%)   148 ( 0.00%)      1,968 ( 0.00%) 0          0                 656 ( 0.00%)   0           0               bool error = (rows == 0 || cols == 0) ? false
     1,968 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      1,312 ( 0.00%) 0          0                   0            0           0                          : (rows > max_index / cols);
     1,312 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        656 ( 0.00%) 0          0                   0            0           0               if (error)
         .               .              .                   .          .          .                   .            .           .                 throw_std_bad_alloc();
       656 ( 0.00%)      0              0                   0          0          0                   0            0           0             }
         .               .              .                   .          .          .                   .            .           .           };
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           template <typename Derived,
         .               .              .                   .          .          .                   .            .           .                     typename OtherDerived = Derived,
         .               .              .                   .          .          .                   .            .           .                     bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
         .               .              .                   .          .          .                   .            .           .           struct conservative_resize_like_impl;
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
-- line 57 ----------------------------------------
-- line 90 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .             * \tparam Derived is the derived type, e.g., a Matrix or Array
         .               .              .                   .          .          .                   .            .           .             *
         .               .              .                   .          .          .                   .            .           .             * \sa \ref TopicClassHierarchy
         .               .              .                   .          .          .                   .            .           .             */
         .               .              .                   .          .          .                   .            .           .           template<typename Derived>
         .               .              .                   .          .          .                   .            .           .           class PlainObjectBase : public doxygen::dense_xpr_base_dispatcher<Derived>
         .               .              .                   .          .          .                   .            .           .           #else
         .               .              .                   .          .          .                   .            .           .           template<typename Derived>
     9,768 ( 0.00%)    113 ( 0.00%)     0               2,664 ( 0.00%) 0          0               2,664 ( 0.00%)   0           0           class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
         .               .              .                   .          .          .                   .            .           .           #endif
         .               .              .                   .          .          .                   .            .           .           {
         .               .              .                   .          .          .                   .            .           .             public:
         .               .              .                   .          .          .                   .            .           .               enum { Options = internal::traits<Derived>::Options };
         .               .              .                   .          .          .                   .            .           .               typedef typename internal::dense_xpr_base<Derived>::type Base;
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               typedef typename internal::traits<Derived>::StorageKind StorageKind;
         .               .              .                   .          .          .                   .            .           .               typedef typename internal::traits<Derived>::Scalar Scalar;
-- line 106 ----------------------------------------
-- line 135 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .               template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };
         .               .              .                   .          .          .                   .            .           .               template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             protected:
         .               .              .                   .          .          .                   .            .           .               DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .             public:
         .               .              .                   .          .          .                   .            .           .               enum { NeedsToAlign = (SizeAtCompileTime != Dynamic) && (internal::traits<Derived>::Alignment>0) };
    15,780 ( 0.00%)      3 ( 0.00%)     0               4,734 ( 0.00%) 0          0               4,734 ( 0.00%)   0           0               EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
   105,798 ( 0.00%) 11,275 ( 0.02%)   318 ( 0.00%)     45,342 ( 0.00%) 0          0              30,228 ( 0.00%)   0           0               Base& base() { return *static_cast<Base*>(this); }
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               const Base& base() const { return *static_cast<const Base*>(this); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
37,599,784 ( 0.51%)  2,975 ( 0.01%) 1,130 ( 0.01%)  9,409,988 ( 0.51%) 0          0          14,084,856 ( 1.05%)  81 ( 0.00%) 15 ( 0.00%)      EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
37,315,704 ( 0.50%)    406 ( 0.00%)   383 ( 0.00%)  9,334,100 ( 0.51%) 0          0          13,985,628 ( 1.05%)   0           0               EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index,Index) const
         .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
         .               .              .                   .          .          .                   .            .           .               {
-- line 161 ----------------------------------------
-- line 165 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .                   return m_storage.data()[rowId + colId * m_storage.rows()];
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const
         .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     3,552 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               1,776 ( 0.00%)   0           0               EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
         .               .              .                   .          .          .                   .            .           .               {
     4,144 ( 0.00%)      0              0               1,184 ( 0.00%) 0          0                 592 ( 0.00%)   0           0                 return m_storage.data()[index];
     1,184 ( 0.00%)      0              0               1,184 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,Index) const
         .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,Index) const for details. */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
    10,792 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               6,745 ( 0.00%)   0           0               EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 if(Flags & RowMajorBit)
         .               .              .                   .          .          .                   .            .           .                   return m_storage.data()[colId + rowId * m_storage.cols()];
         .               .              .                   .          .          .                   .            .           .                 else // column-major
    15,439 ( 0.00%)  1,030 ( 0.00%)   343 ( 0.00%)      4,347 ( 0.00%) 0          0               2,698 ( 0.00%)   0           0                   return m_storage.data()[rowId + colId * m_storage.rows()];
     4,047 ( 0.00%)      0              0               4,047 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) const
         .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) const for details. */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
    12,564 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               6,282 ( 0.00%)   0           0               EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
         .               .              .                   .          .          .                   .            .           .               {
    14,658 ( 0.00%)      0              0               4,188 ( 0.00%) 0          0               2,094 ( 0.00%)   0           0                 return m_storage.data()[index];
     4,188 ( 0.00%)      0              0               4,188 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** This is the const version of coeffRef(Index,Index) which is thus synonym of coeff(Index,Index).
         .               .              .                   .          .          .                   .            .           .                 * It is provided for convenience. */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     2,432 ( 0.00%)    113 ( 0.00%)    74 ( 0.00%)          0          0          0               1,520 ( 0.00%)   0           0               EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 if(Flags & RowMajorBit)
         .               .              .                   .          .          .                   .            .           .                   return m_storage.data()[colId + rowId * m_storage.cols()];
         .               .              .                   .          .          .                   .            .           .                 else // column-major
     3,952 ( 0.00%)      0              0               1,216 ( 0.00%) 0          0                 608 ( 0.00%)   0           0                   return m_storage.data()[rowId + colId * m_storage.rows()];
       912 ( 0.00%)      0              0                 912 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** This is the const version of coeffRef(Index) which is thus synonym of coeff(Index).
         .               .              .                   .          .          .                   .            .           .                 * It is provided for convenience. */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 return m_storage.data()[index];
         .               .              .                   .          .          .                   .            .           .               }
-- line 218 ----------------------------------------
-- line 247 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .               /** \internal */
         .               .              .                   .          .          .                   .            .           .               template<int StoreMode>
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** \returns a const pointer to the data array of this matrix */
21,922,810 ( 0.30%)  6,849 ( 0.01%)   782 ( 0.01%)          0          0          0           8,769,124 ( 0.66%)   0           0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar *data() const
21,922,810 ( 0.30%)  1,350 ( 0.00%)   357 ( 0.00%) 13,153,686 ( 0.72%) 0          0           4,384,562 ( 0.33%)   0           0               { return m_storage.data(); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** \returns a pointer to the data array of this matrix */
    21,015 ( 0.00%)    823 ( 0.00%)   709 ( 0.01%)          0          0          0               8,406 ( 0.00%)   0           0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar *data()
    21,015 ( 0.00%)      1 ( 0.00%)     0              12,609 ( 0.00%) 0          0               4,203 ( 0.00%) 170 ( 0.00%)  0               { return m_storage.data(); }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** Resizes \c *this to a \a rows x \a cols matrix.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * This method is intended for dynamic-size matrices, although it is legal to call it on any
         .               .              .                   .          .          .                   .            .           .                 * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
         .               .              .                   .          .          .                   .            .           .                 * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * If the current number of coefficients of \c *this exactly matches the
-- line 268 ----------------------------------------
-- line 271 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .                 * shrinking, the data is reallocated and all previous values are lost.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * Example: \include Matrix_resize_int_int.cpp
         .               .              .                   .          .          .                   .            .           .                 * Output: \verbinclude Matrix_resize_int_int.out
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
         .               .              .                   .          .          .                   .            .           .                 */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
   262,325 ( 0.00%)  4,570 ( 0.01%)   508 ( 0.01%)          0          0          0             149,900 ( 0.01%)   0           0               EIGEN_STRONG_INLINE void resize(Index rows, Index cols)
         .               .              .                   .          .          .                   .            .           .               {
   447,816 ( 0.01%)  4,741 ( 0.01%)   582 ( 0.01%)    223,908 ( 0.01%) 0          0              74,950 ( 0.01%)   0           0                 eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,rows==RowsAtCompileTime)
         .               .              .                   .          .          .                   .            .           .                              && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,cols==ColsAtCompileTime)
         .               .              .                   .          .          .                   .            .           .                              && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,rows<=MaxRowsAtCompileTime)
         .               .              .                   .          .          .                   .            .           .                              && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,cols<=MaxColsAtCompileTime)
         .               .              .                   .          .          .                   .            .           .                              && rows>=0 && cols>=0 && "Invalid sizes when resizing a matrix or array.");
         .               .              .                   .          .          .                   .            .           .                 internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(rows, cols);
         .               .              .                   .          .          .                   .            .           .                 #ifdef EIGEN_INITIALIZE_COEFFS
         .               .              .                   .          .          .                   .            .           .                   Index size = rows*cols;
         .               .              .                   .          .          .                   .            .           .                   bool size_changed = size != this->size();
         .               .              .                   .          .          .                   .            .           .                   m_storage.resize(size, rows, cols);
         .               .              .                   .          .          .                   .            .           .                   if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
         .               .              .                   .          .          .                   .            .           .                 #else
   299,800 ( 0.00%)  2,269 ( 0.00%)   383 ( 0.00%)    187,375 ( 0.01%) 0          0              37,475 ( 0.00%)   0           0                   m_storage.resize(rows*cols, rows, cols);
         .               .              .                   .          .          .                   .            .           .                 #endif
   112,425 ( 0.00%)      0              0              74,950 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** Resizes \c *this to a vector of length \a size
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * \only_for_vectors. This method does not work for
         .               .              .                   .          .          .                   .            .           .                 * partially dynamic matrices when the static dimension is anything other
         .               .              .                   .          .          .                   .            .           .                 * than 1. For example it will not work with Matrix<double, 2, Dynamic>.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * Example: \include Matrix_resize_int.cpp
         .               .              .                   .          .          .                   .            .           .                 * Output: \verbinclude Matrix_resize_int.out
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * \sa resize(Index,Index), resize(NoChange_t, Index), resize(Index, NoChange_t)
         .               .              .                   .          .          .                   .            .           .                 */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     2,220 ( 0.00%)     74 ( 0.00%)     0                   0          0          0               1,110 ( 0.00%)   0           0               inline void resize(Index size)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
       740 ( 0.00%)      0              0                 370 ( 0.00%) 0          0                   0            0           0                 eigen_assert(((SizeAtCompileTime == Dynamic && (MaxSizeAtCompileTime==Dynamic || size<=MaxSizeAtCompileTime)) || SizeAtCompileTime == size) && size>=0);
         .               .              .                   .          .          .                   .            .           .                 #ifdef EIGEN_INITIALIZE_COEFFS
         .               .              .                   .          .          .                   .            .           .                   bool size_changed = size != this->size();
         .               .              .                   .          .          .                   .            .           .                 #endif
         .               .              .                   .          .          .                   .            .           .                 if(RowsAtCompileTime == 1)
         .               .              .                   .          .          .                   .            .           .                   m_storage.resize(size, 1, size);
         .               .              .                   .          .          .                   .            .           .                 else
     2,220 ( 0.00%)    222 ( 0.00%)   148 ( 0.00%)      1,110 ( 0.00%) 0          0                 370 ( 0.00%)   0           0                   m_storage.resize(size, size, 1);
         .               .              .                   .          .          .                   .            .           .                 #ifdef EIGEN_INITIALIZE_COEFFS
         .               .              .                   .          .          .                   .            .           .                   if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
         .               .              .                   .          .          .                   .            .           .                 #endif
     1,110 ( 0.00%)      0              0                 740 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** Resizes the matrix, changing only the number of columns. For the parameter of type NoChange_t, just pass the special value \c NoChange
         .               .              .                   .          .          .                   .            .           .                 * as in the example below.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * Example: \include Matrix_resize_NoChange_int.cpp
         .               .              .                   .          .          .                   .            .           .                 * Output: \verbinclude Matrix_resize_NoChange_int.out
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * \sa resize(Index,Index)
-- line 331 ----------------------------------------
-- line 354 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .                 * Takes care of doing all the checking that's needed.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * Note that copying a row-vector into a vector (and conversely) is allowed.
         .               .              .                   .          .          .                   .            .           .                 * The resizing, if any, is then done in the appropriate way so that row-vectors
         .               .              .                   .          .          .                   .            .           .                 * remain row-vectors and vectors remain vectors.
         .               .              .                   .          .          .                   .            .           .                 */
         .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
   259,805 ( 0.00%) 14,789 ( 0.03%)   625 ( 0.01%)          0          0          0             148,460 ( 0.01%)   0           0               EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)
         .               .              .                   .          .          .                   .            .           .               {
   148,460 ( 0.00%)    932 ( 0.00%)   288 ( 0.00%)     37,115 ( 0.00%) 0          0              74,230 ( 0.01%)   0           0                 const OtherDerived& other = _other.derived();
   334,035 ( 0.00%)  1,919 ( 0.00%)   546 ( 0.01%)     74,230 ( 0.00%) 0          0             148,460 ( 0.01%)   0           0                 internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(other.rows(), other.cols());
   334,035 ( 0.00%)  9,315 ( 0.02%)   894 ( 0.01%)     74,230 ( 0.00%) 0          0             111,345 ( 0.01%)   0           0                 const Index othersize = other.rows()*other.cols();
         .               .              .                   .          .          .                   .            .           .                 if(RowsAtCompileTime == 1)
         .               .              .                   .          .          .                   .            .           .                 {
         .               .              .                   .          .          .                   .            .           .                   eigen_assert(other.rows() == 1 || other.cols() == 1);
         .               .              .                   .          .          .                   .            .           .                   resize(1, othersize);
         .               .              .                   .          .          .                   .            .           .                 }
         .               .              .                   .          .          .                   .            .           .                 else if(ColsAtCompileTime == 1)
         .               .              .                   .          .          .                   .            .           .                 {
   370,410 ( 0.00%)  9,493 ( 0.02%)   628 ( 0.01%)     74,082 ( 0.00%) 0          0              74,082 ( 0.01%)   0           0                   eigen_assert(other.rows() == 1 || other.cols() == 1);
   222,246 ( 0.00%)  8,602 ( 0.02%) 1,151 ( 0.01%)     74,082 ( 0.00%) 0          0              37,041 ( 0.00%)   0           0                   resize(othersize, 1);
         .               .              .                   .          .          .                   .            .           .                 }
       962 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        222 ( 0.00%) 0          0                 222 ( 0.00%)   0           0                 else resize(other.rows(), other.cols());
   148,460 ( 0.00%)     77 ( 0.00%)    76 ( 0.00%)    111,345 ( 0.01%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** Resizes the matrix to \a rows x \a cols while leaving old values untouched.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * The method is intended for matrices of dynamic size. If you only want to change the number
         .               .              .                   .          .          .                   .            .           .                 * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or
         .               .              .                   .          .          .                   .            .           .                 * conservativeResize(Index, NoChange_t).
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * Matrices are resized relative to the top-left element. In case values need to be 
-- line 386 ----------------------------------------
-- line 476 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .                 return Base::operator=(func);
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               // Prevent user from trying to instantiate PlainObjectBase objects
         .               .              .                   .          .          .                   .            .           .               // by making all its constructor protected. See bug 1074.
         .               .              .                   .          .          .                   .            .           .             protected:
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
   675,389 ( 0.01%)  8,628 ( 0.02%) 2,128 ( 0.03%)    122,798 ( 0.01%) 0          0             245,596 ( 0.02%)  44 ( 0.00%)  0               EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .           //       _check_template_params();
         .               .              .                   .          .          .                   .            .           .           //       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
   184,197 ( 0.00%)      0              0             122,798 ( 0.01%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           #ifndef EIGEN_PARSED_BY_DOXYGEN
         .               .              .                   .          .          .                   .            .           .               // FIXME is it still needed ?
         .               .              .                   .          .          .                   .            .           .               /** \internal */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               explicit PlainObjectBase(internal::constructor_without_unaligned_array_assert)
         .               .              .                   .          .          .                   .            .           .                 : m_storage(internal::constructor_without_unaligned_array_assert())
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .           //       _check_template_params(); EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           #endif
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           #if EIGEN_HAS_RVALUE_REFERENCES
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
   199,038 ( 0.00%)      0              0                   0          0          0             113,736 ( 0.01%)   0           0               PlainObjectBase(PlainObjectBase&& other) EIGEN_NOEXCEPT
   284,340 ( 0.00%)    379 ( 0.00%)   223 ( 0.00%)     85,302 ( 0.00%) 0          0              85,302 ( 0.01%)   0           0                 : m_storage( std::move(other.m_storage) )
         .               .              .                   .          .          .                   .            .           .               {
   113,736 ( 0.00%)      0              0              85,302 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               PlainObjectBase& operator=(PlainObjectBase&& other) EIGEN_NOEXCEPT
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 using std::swap;
         .               .              .                   .          .          .                   .            .           .                 swap(m_storage, other.m_storage);
         .               .              .                   .          .          .                   .            .           .                 return *this;
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           #endif
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** Copy constructor */
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
 2,181,264 ( 0.03%)  1,975 ( 0.00%)   306 ( 0.00%)          0          0          0           1,090,632 ( 0.08%)   0           0               EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)
 3,998,984 ( 0.05%)    148 ( 0.00%)    74 ( 0.00%)  1,817,720 ( 0.10%) 0          0             727,088 ( 0.05%)  82 ( 0.00%)  0                 : Base(), m_storage(other.m_storage) { }
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)
         .               .              .                   .          .          .                   .            .           .                 : m_storage(size, rows, cols)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .           //       _check_template_params();
         .               .              .                   .          .          .                   .            .           .           //       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** \sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */
         .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
   222,838 ( 0.00%)  7,874 ( 0.02%) 1,117 ( 0.01%)          0          0          0             111,493 ( 0.01%)   0           0               EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)
   222,690 ( 0.00%)    806 ( 0.00%)   118 ( 0.00%)     74,230 ( 0.00%) 0          0              74,230 ( 0.01%)   0           0                 : m_storage()
         .               .              .                   .          .          .                   .            .           .               {
    37,115 ( 0.00%)      0              0                   0          0          0              37,115 ( 0.00%)   0           0                 _check_template_params();
   185,575 ( 0.00%)    182 ( 0.00%)   182 ( 0.00%)     74,230 ( 0.00%) 0          0              37,115 ( 0.00%)   0           0                 resizeLike(other);
   185,575 ( 0.00%)  4,880 ( 0.01%)   700 ( 0.01%)     74,230 ( 0.00%) 0          0              37,115 ( 0.00%)   0           0                 _set_noalias(other);
   111,493 ( 0.00%)     74 ( 0.00%)     0              74,378 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** \sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */
         .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)
         .               .              .                   .          .          .                   .            .           .                 : m_storage()
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 _check_template_params();
-- line 546 ----------------------------------------
-- line 704 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .                 * \sa operator=(const MatrixBase<OtherDerived>&), _set_noalias()
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * \internal
         .               .              .                   .          .          .                   .            .           .                 */
         .               .              .                   .          .          .                   .            .           .               // aliasing is dealt once in internall::call_assignment
         .               .              .                   .          .          .                   .            .           .               // so at this stage we have to assume aliasing... and resising has to be done later.
         .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
   161,091 ( 0.00%)  9,079 ( 0.02%)   345 ( 0.00%)          0          0          0              92,052 ( 0.01%)   0           0               EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)
         .               .              .                   .          .          .                   .            .           .               {
   230,130 ( 0.00%)  6,250 ( 0.01%)   798 ( 0.01%)     46,026 ( 0.00%) 0          0              69,039 ( 0.01%)   0           0                 internal::call_assignment(this->derived(), other.derived());
    69,039 ( 0.00%)     75 ( 0.00%)     0              23,013 ( 0.00%) 0          0              23,013 ( 0.00%)   0           0                 return this->derived();
    69,039 ( 0.00%)     88 ( 0.00%)    88 ( 0.00%)     69,039 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               /** \internal Like _set() but additionally makes the assumption that no aliasing effect can happen (which
         .               .              .                   .          .          .                   .            .           .                 * is the case when creating a new matrix) so one can enforce lazy evaluation.
         .               .              .                   .          .          .                   .            .           .                 *
         .               .              .                   .          .          .                   .            .           .                 * \sa operator=(const MatrixBase<OtherDerived>&), _set()
         .               .              .                   .          .          .                   .            .           .                 */
         .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
   379,230 ( 0.01%)  3,040 ( 0.01%)   832 ( 0.01%)     37,923 ( 0.00%) 0          0             189,615 ( 0.01%)   0           0               EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 // I don't think we need this resize call since the lazyAssign will anyways resize
         .               .              .                   .          .          .                   .            .           .                 // and lazyAssign will be called by the assign selector.
         .               .              .                   .          .          .                   .            .           .                 //_resize_to_match(other);
         .               .              .                   .          .          .                   .            .           .                 // the 'false' below means to enforce lazy evaluation. We don't use lazyAssign() because
         .               .              .                   .          .          .                   .            .           .                 // it wouldn't allow to copy a row-vector into a column-vector.
   606,768 ( 0.01%)  4,633 ( 0.01%) 1,779 ( 0.02%)     75,846 ( 0.00%) 0          0             151,692 ( 0.01%)   0           0                 internal::call_assignment_no_alias(this->derived(), other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>());
   113,769 ( 0.00%)  4,766 ( 0.01%)   108 ( 0.00%)     37,923 ( 0.00%) 0          0              37,923 ( 0.00%)   0           0                 return this->derived();
   227,538 ( 0.00%)  4,370 ( 0.01%) 1,244 ( 0.02%)    189,615 ( 0.01%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               template<typename T0, typename T1>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     1,184 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0                 740 ( 0.00%)   0           0               EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
         .               .              .                   .          .          .                   .            .           .               {
       148 ( 0.00%)      0              0                   0          0          0                 148 ( 0.00%)   0           0                 const bool t0_is_integer_alike = internal::is_valid_index_type<T0>::value;
       148 ( 0.00%)      0              0                   0          0          0                 148 ( 0.00%)   0           0                 const bool t1_is_integer_alike = internal::is_valid_index_type<T1>::value;
         .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT(t0_is_integer_alike &&
         .               .              .                   .          .          .                   .            .           .                                     t1_is_integer_alike,
         .               .              .                   .          .          .                   .            .           .                                     FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
       888 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        444 ( 0.00%) 0          0                 148 ( 0.00%)   0           0                 resize(rows,cols);
       444 ( 0.00%)      0              0                 296 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .               
         .               .              .                   .          .          .                   .            .           .               template<typename T0, typename T1>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
   198,160 ( 0.00%)  1,616 ( 0.00%)   407 ( 0.01%)          0          0          0             123,850 ( 0.01%)   0           0               EIGEN_STRONG_INLINE void _init2(const T0& val0, const T1& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)
   203,996 ( 0.00%)    119 ( 0.00%)    88 ( 0.00%)     99,080 ( 0.01%) 0          0              74,310 ( 0.01%)   3 ( 0.00%)  0                 m_storage.data()[0] = Scalar(val0);
   228,766 ( 0.00%)  1,047 ( 0.00%)   310 ( 0.00%)     99,080 ( 0.01%) 0          0              74,310 ( 0.01%)   0           0                 m_storage.data()[1] = Scalar(val1);
    74,310 ( 0.00%)      0              0              49,540 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .               
         .               .              .                   .          .          .                   .            .           .               template<typename T0, typename T1>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init2(const Index& val0, const Index& val1,
         .               .              .                   .          .          .                   .            .           .                                               typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)
         .               .              .                   .          .          .                   .            .           .                                                                             && (internal::is_same<T0,Index>::value)
         .               .              .                   .          .          .                   .            .           .                                                                             && (internal::is_same<T1,Index>::value)
         .               .              .                   .          .          .                   .            .           .                                                                             && Base::SizeAtCompileTime==2,T1>::type* = 0)
-- line 763 ----------------------------------------
-- line 766 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .                 m_storage.data()[0] = Scalar(val0);
         .               .              .                   .          .          .                   .            .           .                 m_storage.data()[1] = Scalar(val1);
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               // The argument is convertible to the Index type and we either have a non 1x1 Matrix, or a dynamic-sized Array,
         .               .              .                   .          .          .                   .            .           .               // then the argument is meant to be the size of the object.
         .               .              .                   .          .          .                   .            .           .               template<typename T>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     1,998 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)        222 ( 0.00%) 0          0               1,110 ( 0.00%)   0           0               EIGEN_STRONG_INLINE void _init1(Index size, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)
         .               .              .                   .          .          .                   .            .           .                                                                                         && ((!internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value || Base::SizeAtCompileTime==Dynamic)),T>::type* = 0)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 // NOTE MSVC 2008 complains if we directly put bool(NumTraits<T>::IsInteger) as the EIGEN_STATIC_ASSERT argument.
       222 ( 0.00%)      0              0                   0          0          0                 222 ( 0.00%)   0           0                 const bool is_integer_alike = internal::is_valid_index_type<T>::value;
       666 ( 0.00%)      0              0                   0          0          0                 222 ( 0.00%)   0           0                 EIGEN_UNUSED_VARIABLE(is_integer_alike);
         .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT(is_integer_alike,
         .               .              .                   .          .          .                   .            .           .                                     FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
     1,110 ( 0.00%)    148 ( 0.00%)   148 ( 0.00%)        444 ( 0.00%) 0          0                 222 ( 0.00%)   0           0                 resize(size);
     1,332 ( 0.00%)      0              0                 888 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .               
         .               .              .                   .          .          .                   .            .           .               // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coefficient (case where scalar type can be implicitely converted)
         .               .              .                   .          .          .                   .            .           .               template<typename T>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1)
         .               .              .                   .          .          .                   .            .           .                 m_storage.data()[0] = val0;
-- line 791 ----------------------------------------
-- line 809 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init1(const Scalar* data){
         .               .              .                   .          .          .                   .            .           .                 this->_set_noalias(ConstMapType(data));
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               // Initialize an arbitrary matrix from a dense expression
         .               .              .                   .          .          .                   .            .           .               template<typename T, typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     4,848 ( 0.00%)    660 ( 0.00%)   622 ( 0.01%)          0          0          0               2,424 ( 0.00%)   0           0               EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other){
     4,040 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)      1,616 ( 0.00%) 0          0                 808 ( 0.00%)   0           0                 this->_set_noalias(other);
     2,424 ( 0.00%)      0              0               1,616 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               // Initialize an arbitrary matrix from an object convertible to the Derived type.
         .               .              .                   .          .          .                   .            .           .               template<typename T>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init1(const Derived& other){
         .               .              .                   .          .          .                   .            .           .                 this->_set_noalias(other);
         .               .              .                   .          .          .                   .            .           .               }
         .               .              .                   .          .          .                   .            .           .           
-- line 827 ----------------------------------------
-- line 880 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .               
         .               .              .                   .          .          .                   .            .           .           #ifndef EIGEN_PARSED_BY_DOXYGEN
         .               .              .                   .          .          .                   .            .           .               /** \internal
         .               .              .                   .          .          .                   .            .           .                 * \brief Override DenseBase::swap() since for dynamic-sized matrices
         .               .              .                   .          .          .                   .            .           .                 * of same type it is enough to swap the data pointers.
         .               .              .                   .          .          .                   .            .           .                 */
         .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
   105,798 ( 0.00%)    558 ( 0.00%)   213 ( 0.00%)          0          0          0              60,456 ( 0.00%)   0           0               void swap(DenseBase<OtherDerived> & other)
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 enum { SwapPointers = internal::is_same<Derived, OtherDerived>::value && Base::SizeAtCompileTime==Dynamic };
   151,140 ( 0.00%)  1,446 ( 0.00%)   209 ( 0.00%)     30,228 ( 0.00%) 0          0              45,342 ( 0.00%)   0           0                 internal::matrix_swap_impl<Derived, OtherDerived, bool(SwapPointers)>::run(this->derived(), other.derived());
    60,456 ( 0.00%)      0              0              45,342 ( 0.00%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .               
         .               .              .                   .          .          .                   .            .           .               /** \internal
         .               .              .                   .          .          .                   .            .           .                 * \brief const version forwarded to DenseBase::swap
         .               .              .                   .          .          .                   .            .           .                 */
         .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .               void swap(DenseBase<OtherDerived> const & other)
         .               .              .                   .          .          .                   .            .           .               { Base::swap(other.derived()); }
         .               .              .                   .          .          .                   .            .           .               
         .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
   381,066 ( 0.01%)    418 ( 0.00%)    74 ( 0.00%)          0          0          0             127,022 ( 0.01%)   0           0               static EIGEN_STRONG_INLINE void _check_template_params()
         .               .              .                   .          .          .                   .            .           .               {
         .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, (Options&RowMajor)==RowMajor)
         .               .              .                   .          .          .                   .            .           .                                   && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, (Options&RowMajor)==0)
         .               .              .                   .          .          .                   .            .           .                                   && ((RowsAtCompileTime == Dynamic) || (RowsAtCompileTime >= 0))
         .               .              .                   .          .          .                   .            .           .                                   && ((ColsAtCompileTime == Dynamic) || (ColsAtCompileTime >= 0))
         .               .              .                   .          .          .                   .            .           .                                   && ((MaxRowsAtCompileTime == Dynamic) || (MaxRowsAtCompileTime >= 0))
         .               .              .                   .          .          .                   .            .           .                                   && ((MaxColsAtCompileTime == Dynamic) || (MaxColsAtCompileTime >= 0))
         .               .              .                   .          .          .                   .            .           .                                   && (MaxRowsAtCompileTime == RowsAtCompileTime || RowsAtCompileTime==Dynamic)
         .               .              .                   .          .          .                   .            .           .                                   && (MaxColsAtCompileTime == ColsAtCompileTime || ColsAtCompileTime==Dynamic)
         .               .              .                   .          .          .                   .            .           .                                   && (Options & (DontAlign|RowMajor)) == Options),
         .               .              .                   .          .          .                   .            .           .                   INVALID_MATRIX_TEMPLATE_PARAMETERS)
   381,066 ( 0.01%)  1,450 ( 0.00%)   425 ( 0.01%)    254,044 ( 0.01%) 0          0                   0            0           0               }
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .               enum { IsPlainObjectBase = 1 };
         .               .              .                   .          .          .                   .            .           .           #endif
         .               .              .                   .          .          .                   .            .           .           };
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           namespace internal {
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           template <typename Derived, typename OtherDerived, bool IsVector>
-- line 923 ----------------------------------------
-- line 1009 ----------------------------------------
         .               .              .                   .          .          .                   .            .           .                 _this.tail(num_new_elements) = other.tail(num_new_elements);
         .               .              .                   .          .          .                   .            .           .             }
         .               .              .                   .          .          .                   .            .           .           };
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>
         .               .              .                   .          .          .                   .            .           .           struct matrix_swap_impl
         .               .              .                   .          .          .                   .            .           .           {
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
    90,684 ( 0.00%)  3,795 ( 0.01%)   213 ( 0.00%)          0          0          0              45,342 ( 0.00%)   0           0             static inline void run(MatrixTypeA& a, MatrixTypeB& b)
         .               .              .                   .          .          .                   .            .           .             {
   120,912 ( 0.00%)  5,643 ( 0.01%)   209 ( 0.00%)     30,228 ( 0.00%) 0          0              30,228 ( 0.00%)   0           0               a.base().swap(b);
    45,342 ( 0.00%)      0              0              30,228 ( 0.00%) 0          0                   0            0           0             }
         .               .              .                   .          .          .                   .            .           .           };
         .               .              .                   .          .          .                   .            .           .           
         .               .              .                   .          .          .                   .            .           .           template<typename MatrixTypeA, typename MatrixTypeB>
         .               .              .                   .          .          .                   .            .           .           struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>
         .               .              .                   .          .          .                   .            .           .           {
         .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .            .           .             static inline void run(MatrixTypeA& a, MatrixTypeB& b)
         .               .              .                   .          .          .                   .            .           .             {
-- line 1028 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 131 ----------------------------------------
         .               .              .                   .          .          .                   .          .          .                 * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
         .               .              .                   .          .          .                   .          .          .                 * function equivalent to \link operator[](Index) const \endlink.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index) const, coeffRef(Index), coeff(Index,Index) const
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE CoeffReturnType
34,889,823 ( 0.47%)  2,268 ( 0.00%)   151 ( 0.00%)  3,876,647 ( 0.21%) 0          0          19,383,235 ( 1.45%) 0          0               coeff(Index index) const
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
         .               .              .                   .          .          .                   .          .          .                                     THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS)
         .               .              .                   .          .          .                   .          .          .                 eigen_internal_assert(index >= 0 && index < size());
73,656,293 ( 0.99%)  3,461 ( 0.01%)   740 ( 0.01%)  7,753,294 ( 0.42%) 0          0          15,506,588 ( 1.16%) 0          0                 return internal::evaluator<Derived>(derived()).coeff(index);
23,259,882 ( 0.31%)  1,863 ( 0.00%)   698 ( 0.01%) 19,383,235 ( 1.05%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the coefficient at given index.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index), operator()(Index,Index) const, x() const, y() const,
         .               .              .                   .          .          .                   .          .          .                 * z() const, w() const
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE CoeffReturnType
19,383,235 ( 0.26%) 13,802 ( 0.03%)   869 ( 0.01%)          0          0          0          11,629,941 ( 0.87%) 0          0               operator[](Index index) const
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
         .               .              .                   .          .          .                   .          .          .                                     THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD)
27,136,529 ( 0.37%)    708 ( 0.00%)   588 ( 0.01%) 11,629,941 ( 0.63%) 0          0           3,876,647 ( 0.29%) 0          0                 eigen_assert(index >= 0 && index < size());
19,383,235 ( 0.26%)  2,322 ( 0.00%)   739 ( 0.01%)  7,753,294 ( 0.42%) 0          0           3,876,647 ( 0.29%) 0          0                 return coeff(index);
 7,753,294 ( 0.10%)      0              0           7,753,294 ( 0.42%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the coefficient at given index.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * This is synonymous to operator[](Index) const.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index), operator()(Index,Index) const, x() const, y() const,
-- line 172 ----------------------------------------
-- line 332 ----------------------------------------
         .               .              .                   .          .          .                   .          .          .                 * parameters \a row and \a col are in range.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
         .               .              .                   .          .          .                   .          .          .                 * function equivalent to \link operator()(Index,Index) \endlink.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator()(Index,Index), coeff(Index, Index) const, coeffRef(Index)
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    40,271 ( 0.00%)    513 ( 0.00%)   489 ( 0.01%)      3,661 ( 0.00%) 0          0              21,966 ( 0.00%) 0          0               EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 eigen_internal_assert(row >= 0 && row < rows()
         .               .              .                   .          .          .                   .          .          .                                    && col >= 0 && col < cols());
    73,220 ( 0.00%)    439 ( 0.00%)   415 ( 0.01%)     10,983 ( 0.00%) 0          0              14,644 ( 0.00%) 0          0                 return internal::evaluator<Derived>(derived()).coeffRef(row,col);
    21,966 ( 0.00%)    439 ( 0.00%)   415 ( 0.01%)     18,305 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
         .               .              .                   .          .          .                   .          .          .               coeffRefByOuterInner(Index outer, Index inner)
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 return coeffRef(rowIndexByOuterInner(outer, inner),
         .               .              .                   .          .          .                   .          .          .                                 colIndexByOuterInner(outer, inner));
         .               .              .                   .          .          .                   .          .          .               }
-- line 353 ----------------------------------------
-- line 354 ----------------------------------------
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns a reference to the coefficient at given the given row and column.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index)
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
    25,627 ( 0.00%)    439 ( 0.00%)   415 ( 0.01%)          0          0          0              14,644 ( 0.00%) 0          0               operator()(Index row, Index col)
         .               .              .                   .          .          .                   .          .          .               {
    51,254 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)     21,966 ( 0.00%) 0          0               7,322 ( 0.00%) 0          0                 eigen_assert(row >= 0 && row < rows()
         .               .              .                   .          .          .                   .          .          .                     && col >= 0 && col < cols());
    21,966 ( 0.00%)    439 ( 0.00%)   415 ( 0.01%)     10,983 ( 0.00%) 0          0               3,661 ( 0.00%) 0          0                 return coeffRef(row, col);
     7,322 ( 0.00%)      0              0               7,322 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** Short version: don't use this function, use
         .               .              .                   .          .          .                   .          .          .                 * \link operator[](Index) \endlink instead.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * Long version: this function is similar to
         .               .              .                   .          .          .                   .          .          .                 * \link operator[](Index) \endlink, but without the assertion.
         .               .              .                   .          .          .                   .          .          .                 * Use this for limiting the performance cost of debugging code when doing
-- line 375 ----------------------------------------
-- line 379 ----------------------------------------
         .               .              .                   .          .          .                   .          .          .                 * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
         .               .              .                   .          .          .                   .          .          .                 * function equivalent to \link operator[](Index) \endlink.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index), coeff(Index) const, coeffRef(Index,Index)
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
 2,674,110 ( 0.04%)  2,762 ( 0.01%) 1,469 ( 0.02%)    267,411 ( 0.01%) 0          0           1,337,055 ( 0.10%) 0          0               coeffRef(Index index)
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
         .               .              .                   .          .          .                   .          .          .                                     THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS)
         .               .              .                   .          .          .                   .          .          .                 eigen_internal_assert(index >= 0 && index < size());
 5,080,809 ( 0.07%)  1,634 ( 0.00%)   676 ( 0.01%)    534,822 ( 0.03%) 0          0           1,069,644 ( 0.08%) 0          0                 return internal::evaluator<Derived>(derived()).coeffRef(index);
 1,604,466 ( 0.02%)      0              0           1,337,055 ( 0.07%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns a reference to the coefficient at given index.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index) const, operator()(Index,Index), x(), y(), z(), w()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
 1,597,746 ( 0.02%) 12,056 ( 0.02%)   702 ( 0.01%)          0          0          0             798,873 ( 0.06%) 0          0               operator[](Index index)
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
         .               .              .                   .          .          .                   .          .          .                                     THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD)
 1,864,037 ( 0.03%)    332 ( 0.00%)   309 ( 0.00%)    798,873 ( 0.04%) 0          0             266,291 ( 0.02%) 0          0                 eigen_assert(index >= 0 && index < size());
 1,331,455 ( 0.02%)  4,129 ( 0.01%)   367 ( 0.00%)    532,582 ( 0.03%) 0          0             266,291 ( 0.02%) 0          0                 return coeffRef(index);
   532,582 ( 0.01%)    332 ( 0.00%)   310 ( 0.00%)    532,582 ( 0.03%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns a reference to the coefficient at given index.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * This is synonymous to operator[](Index).
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index) const, operator()(Index,Index), x(), y(), z(), w()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
     6,720 ( 0.00%)    222 ( 0.00%)    74 ( 0.00%)          0          0          0               3,360 ( 0.00%) 0          0               operator()(Index index)
         .               .              .                   .          .          .                   .          .          .               {
     7,840 ( 0.00%)      0              0               3,360 ( 0.00%) 0          0               1,120 ( 0.00%) 0          0                 eigen_assert(index >= 0 && index < size());
     5,600 ( 0.00%)    113 ( 0.00%)    74 ( 0.00%)      2,240 ( 0.00%) 0          0               1,120 ( 0.00%) 0          0                 return coeffRef(index);
     2,240 ( 0.00%)      0              0               2,240 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](0).  */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
   570,515 ( 0.01%)    880 ( 0.00%)   485 ( 0.01%)    155,595 ( 0.01%) 0          0             155,595 ( 0.01%) 0          0               x() { return (*this)[0]; }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](1).  */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
   259,325 ( 0.00%)    150 ( 0.00%)   132 ( 0.00%)          0          0          0             103,730 ( 0.01%) 0          0               y()
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=2, OUT_OF_RANGE_ACCESS);
   207,460 ( 0.00%)      0              0              51,865 ( 0.00%) 0          0              51,865 ( 0.00%) 0          0                 return (*this)[1];
   103,730 ( 0.00%)      0              0             103,730 ( 0.01%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](2).  */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
     1,825 ( 0.00%)      0              0                   0          0          0                 730 ( 0.00%) 0          0               z()
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=3, OUT_OF_RANGE_ACCESS);
     1,460 ( 0.00%)    365 ( 0.00%)   341 ( 0.00%)        365 ( 0.00%) 0          0                 365 ( 0.00%) 0          0                 return (*this)[2];
       730 ( 0.00%)      0              0                 730 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](3).  */
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
         .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
         .               .              .                   .          .          .                   .          .          .               w()
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=4, OUT_OF_RANGE_ACCESS);
-- line 461 ----------------------------------------
-- line 488 ----------------------------------------
         .               .              .                   .          .          .                   .          .          .               using Base::size;
         .               .              .                   .          .          .                   .          .          .               using Base::derived;
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive elements within a slice in the inner direction.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa outerStride(), rowStride(), colStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    59,040 ( 0.00%)    328 ( 0.00%)   308 ( 0.00%)          0          0          0              23,616 ( 0.00%) 0          0               inline Index innerStride() const
         .               .              .                   .          .          .                   .          .          .               {
    59,040 ( 0.00%)      0              0              11,808 ( 0.00%) 0          0              23,616 ( 0.00%) 0          0                 return derived().innerStride();
    23,616 ( 0.00%)      0              0              23,616 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive inner slices (for example, between two consecutive columns
         .               .              .                   .          .          .                   .          .          .                 *          in a column-major matrix).
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), rowStride(), colStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    59,040 ( 0.00%)    328 ( 0.00%)   313 ( 0.00%)          0          0          0              23,616 ( 0.00%) 0          0               inline Index outerStride() const
         .               .              .                   .          .          .                   .          .          .               {
    59,040 ( 0.00%)    328 ( 0.00%)   313 ( 0.00%)     11,808 ( 0.00%) 0          0              23,616 ( 0.00%) 0          0                 return derived().outerStride();
    23,616 ( 0.00%)      0              0              23,616 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               // FIXME shall we remove it ?
         .               .              .                   .          .          .                   .          .          .               inline Index stride() const
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
         .               .              .                   .          .          .                   .          .          .               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive rows.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), colStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    59,040 ( 0.00%)    328 ( 0.00%)   306 ( 0.00%)          0          0          0              23,616 ( 0.00%) 0          0               inline Index rowStride() const
         .               .              .                   .          .          .                   .          .          .               {
    35,424 ( 0.00%)      0              0              11,808 ( 0.00%) 0          0              11,808 ( 0.00%) 0          0                 return Derived::IsRowMajor ? outerStride() : innerStride();
    23,616 ( 0.00%)      0              0              23,616 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive columns.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), rowStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    59,040 ( 0.00%)    328 ( 0.00%)   306 ( 0.00%)          0          0          0              23,616 ( 0.00%) 0          0               inline Index colStride() const
         .               .              .                   .          .          .                   .          .          .               {
    35,424 ( 0.00%)      0              0              11,808 ( 0.00%) 0          0              11,808 ( 0.00%) 0          0                 return Derived::IsRowMajor ? innerStride() : outerStride();
    23,616 ( 0.00%)      0              0              23,616 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           };
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           /** \brief Base class providing direct read/write coefficient access to matrices and arrays.
         .               .              .                   .          .          .                   .          .          .             * \ingroup Core_Module
         .               .              .                   .          .          .                   .          .          .             * \tparam Derived Type of the derived class
         .               .              .                   .          .          .                   .          .          .             * \tparam #DirectWriteAccessors Constant indicating direct access
         .               .              .                   .          .          .                   .          .          .             *
         .               .              .                   .          .          .                   .          .          .             * This class defines functions to work with strides which can be used to access entries directly. This class
-- line 544 ----------------------------------------
-- line 562 ----------------------------------------
         .               .              .                   .          .          .                   .          .          .               using Base::size;
         .               .              .                   .          .          .                   .          .          .               using Base::derived;
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive elements within a slice in the inner direction.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa outerStride(), rowStride(), colStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    11,320 ( 0.00%)      0              0                   0          0          0               4,528 ( 0.00%) 0          0               inline Index innerStride() const
         .               .              .                   .          .          .                   .          .          .               {
    11,320 ( 0.00%)      0              0               2,264 ( 0.00%) 0          0               4,528 ( 0.00%) 0          0                 return derived().innerStride();
     4,528 ( 0.00%)      0              0               4,528 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive inner slices (for example, between two consecutive columns
         .               .              .                   .          .          .                   .          .          .                 *          in a column-major matrix).
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), rowStride(), colStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
   132,120 ( 0.00%)  1,783 ( 0.00%)   811 ( 0.01%)          0          0          0              52,848 ( 0.00%) 0          0               inline Index outerStride() const
         .               .              .                   .          .          .                   .          .          .               {
   132,120 ( 0.00%)    296 ( 0.00%)    74 ( 0.00%)     26,424 ( 0.00%) 0          0              52,848 ( 0.00%) 0          0                 return derived().outerStride();
    52,848 ( 0.00%)      0              0              52,848 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               // FIXME shall we remove it ?
         .               .              .                   .          .          .                   .          .          .               inline Index stride() const
         .               .              .                   .          .          .                   .          .          .               {
         .               .              .                   .          .          .                   .          .          .                 return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
         .               .              .                   .          .          .                   .          .          .               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive rows.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), colStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    11,320 ( 0.00%)    402 ( 0.00%)   380 ( 0.00%)          0          0          0               4,528 ( 0.00%) 0          0               inline Index rowStride() const
         .               .              .                   .          .          .                   .          .          .               {
     6,792 ( 0.00%)      0              0               2,264 ( 0.00%) 0          0               2,264 ( 0.00%) 0          0                 return Derived::IsRowMajor ? outerStride() : innerStride();
     4,528 ( 0.00%)      0              0               4,528 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive columns.
         .               .              .                   .          .          .                   .          .          .                 *
         .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), rowStride()
         .               .              .                   .          .          .                   .          .          .                 */
         .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    11,320 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               4,528 ( 0.00%) 0          0               inline Index colStride() const
         .               .              .                   .          .          .                   .          .          .               {
     6,792 ( 0.00%)      0              0               2,264 ( 0.00%) 0          0               2,264 ( 0.00%) 0          0                 return Derived::IsRowMajor ? innerStride() : outerStride();
     4,528 ( 0.00%)      0              0               4,528 ( 0.00%) 0          0                   0          0          0               }
         .               .              .                   .          .          .                   .          .          .           };
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           namespace internal {
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           template<int Alignment, typename Derived, bool JustReturnZero>
         .               .              .                   .          .          .                   .          .          .           struct first_aligned_impl
         .               .              .                   .          .          .                   .          .          .           {
     3,424 ( 0.00%)      0              0                   0          0          0               1,712 ( 0.00%) 0          0             static inline Index run(const Derived&)
     2,568 ( 0.00%)     35 ( 0.00%)    35 ( 0.00%)      1,712 ( 0.00%) 0          0                   0          0          0             { return 0; }
         .               .              .                   .          .          .                   .          .          .           };
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           template<int Alignment, typename Derived>
         .               .              .                   .          .          .                   .          .          .           struct first_aligned_impl<Alignment, Derived, false>
         .               .              .                   .          .          .                   .          .          .           {
         .               .              .                   .          .          .                   .          .          .             static inline Index run(const Derived& m)
         .               .              .                   .          .          .                   .          .          .             {
         .               .              .                   .          .          .                   .          .          .               return internal::first_aligned<Alignment>(m.data(), m.size());
-- line 627 ----------------------------------------
-- line 631 ----------------------------------------
         .               .              .                   .          .          .                   .          .          .           /** \internal \returns the index of the first element of the array stored by \a m that is properly aligned with respect to \a Alignment for vectorization.
         .               .              .                   .          .          .                   .          .          .             *
         .               .              .                   .          .          .                   .          .          .             * \tparam Alignment requested alignment in Bytes.
         .               .              .                   .          .          .                   .          .          .             *
         .               .              .                   .          .          .                   .          .          .             * There is also the variant first_aligned(const Scalar*, Integer) defined in Memory.h. See it for more
         .               .              .                   .          .          .                   .          .          .             * documentation.
         .               .              .                   .          .          .                   .          .          .             */
         .               .              .                   .          .          .                   .          .          .           template<int Alignment, typename Derived>
     3,424 ( 0.00%)      0              0                   0          0          0               1,712 ( 0.00%) 0          0           static inline Index first_aligned(const DenseBase<Derived>& m)
         .               .              .                   .          .          .                   .          .          .           {
         .               .              .                   .          .          .                   .          .          .             enum { ReturnZero = (int(evaluator<Derived>::Alignment) >= Alignment) || !(Derived::Flags & DirectAccessBit) };
     4,280 ( 0.00%)      0              0                 856 ( 0.00%) 0          0               1,712 ( 0.00%) 0          0             return first_aligned_impl<Alignment, Derived, ReturnZero>::run(m.derived());
     1,712 ( 0.00%)      0              0               1,712 ( 0.00%) 0          0                   0          0          0           }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           template<typename Derived>
     3,424 ( 0.00%)     74 ( 0.00%)    74 ( 0.00%)          0          0          0               1,712 ( 0.00%) 0          0           static inline Index first_default_aligned(const DenseBase<Derived>& m)
         .               .              .                   .          .          .                   .          .          .           {
         .               .              .                   .          .          .                   .          .          .             typedef typename Derived::Scalar Scalar;
         .               .              .                   .          .          .                   .          .          .             typedef typename packet_traits<Scalar>::type DefaultPacketType;
     2,568 ( 0.00%)      0              0                 856 ( 0.00%) 0          0                 856 ( 0.00%) 0          0             return internal::first_aligned<int(unpacket_traits<DefaultPacketType>::alignment),Derived>(m);
     1,712 ( 0.00%)      0              0               1,712 ( 0.00%) 0          0                   0          0          0           }
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           template<typename Derived, bool HasDirectAccess = has_direct_access<Derived>::ret>
         .               .              .                   .          .          .                   .          .          .           struct inner_stride_at_compile_time
         .               .              .                   .          .          .                   .          .          .           {
         .               .              .                   .          .          .                   .          .          .             enum { ret = traits<Derived>::InnerStrideAtCompileTime };
         .               .              .                   .          .          .                   .          .          .           };
         .               .              .                   .          .          .                   .          .          .           
         .               .              .                   .          .          .                   .          .          .           template<typename Derived>
-- line 659 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                  I1mr           ILmr         Dr                 D1mr           DLmr         Dw                 D1mw         DLmw         

-- line 89 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                  	pointer;
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 struct _Vector_impl_data
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	pointer _M_start;
         .              .            .                  .              .            .                  .            .            .           	pointer _M_finish;
         .              .            .                  .              .            .                  .            .            .           	pointer _M_end_of_storage;
         .              .            .                  .              .            .                  .            .            .           
    10,924 ( 0.00%)   790 ( 0.00%) 174 ( 0.00%)         0              0            0              5,472 ( 0.00%)   0            0           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
    16,416 ( 0.00%)   554 ( 0.00%) 245 ( 0.00%)     8,208 ( 0.00%)     0            0              8,208 ( 0.00%) 830 ( 0.00%) 568 ( 0.00%)  	: _M_start(), _M_finish(), _M_end_of_storage()
     8,208 ( 0.00%)     0            0              5,472 ( 0.00%)     0            0                  0            0            0           	{ }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
     2,185 ( 0.00%)    23 ( 0.00%)   8 ( 0.00%)         0              0            0              1,311 ( 0.00%)   0            0           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
     3,496 ( 0.00%)   110 ( 0.00%)  48 ( 0.00%)     2,622 ( 0.00%)     0            0                874 ( 0.00%)  83 ( 0.00%)  82 ( 0.00%)  	: _M_start(__x._M_start), _M_finish(__x._M_finish),
     1,748 ( 0.00%)    23 ( 0.00%)   8 ( 0.00%)     1,311 ( 0.00%)     0            0                437 ( 0.00%)  38 ( 0.00%)  38 ( 0.00%)  	  _M_end_of_storage(__x._M_end_of_storage)
     5,681 ( 0.00%)    23 ( 0.00%)   8 ( 0.00%)     3,933 ( 0.00%)     0            0              1,311 ( 0.00%)   0            0           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           	void
       540 ( 0.00%)    10 ( 0.00%)  10 ( 0.00%)         0              0            0                324 ( 0.00%)   0            0           	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .           	{
       432 ( 0.00%)     8 ( 0.00%)   8 ( 0.00%)       324 ( 0.00%)     0            0                108 ( 0.00%)   0            0           	  _M_start = __x._M_start;
       432 ( 0.00%)     0            0                324 ( 0.00%)     0            0                108 ( 0.00%)   0            0           	  _M_finish = __x._M_finish;
       432 ( 0.00%)     0            0                324 ( 0.00%)     1 ( 0.00%)   0                108 ( 0.00%)   0            0           	  _M_end_of_storage = __x._M_end_of_storage;
       324 ( 0.00%)     0            0                216 ( 0.00%)     0            0                  0            0            0           	}
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           	void
       324 ( 0.00%)    18 ( 0.00%)  18 ( 0.00%)        36 ( 0.00%)     0            0                144 ( 0.00%)   0            0           	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .           	{
         .              .            .                  .              .            .                  .            .            .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
         .              .            .                  .              .            .                  .            .            .           	  // information used by TBAA.
       108 ( 0.00%)     0            0                  0              0            0                 36 ( 0.00%)   0            0           	  _Vector_impl_data __tmp;
       180 ( 0.00%)     0            0                 36 ( 0.00%)     0            0                 36 ( 0.00%)   0            0           	  __tmp._M_copy_data(*this);
       180 ( 0.00%)     0            0                 72 ( 0.00%)     0            0                 36 ( 0.00%)   0            0           	  _M_copy_data(__x);
       180 ( 0.00%)    18 ( 0.00%)  18 ( 0.00%)        36 ( 0.00%)     0            0                 36 ( 0.00%)   0            0           	  __x._M_copy_data(__tmp);
       216 ( 0.00%)     0            0                144 ( 0.00%)     0            0                  0            0            0           	}
         .              .            .                  .              .            .                  .            .            .                 };
         .              .            .                  .              .            .                  .            .            .           
    34,476 ( 0.00%) 1,121 ( 0.00%) 139 ( 0.00%)     9,408 ( 0.00%)     0            0              9,408 ( 0.00%)   0            0                 struct _Vector_impl
         .              .            .                  .              .            .                  .            .            .           	: public _Tp_alloc_type, public _Vector_impl_data
         .              .            .                  .              .            .                  .            .            .                 {
     7,540 ( 0.00%)   914 ( 0.00%) 323 ( 0.00%)         0              0            0              3,024 ( 0.00%)   0            0           	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
         .              .            .                  .              .            .                  .            .            .           	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
     9,072 ( 0.00%)   201 ( 0.00%) 158 ( 0.00%)     3,024 ( 0.00%)     0            0              3,024 ( 0.00%)   0            0           	: _Tp_alloc_type()
     4,536 ( 0.00%)     0            0              3,024 ( 0.00%)     0            0                  0            0            0           	{ }
         .              .            .                  .              .            .                  .            .            .           
     7,128 ( 0.00%)    75 ( 0.00%)  27 ( 0.00%)         0              0            0              3,564 ( 0.00%)   0            0           	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
     9,504 ( 0.00%)   489 ( 0.00%)  67 ( 0.00%)     3,564 ( 0.00%)     0            0              2,376 ( 0.00%)   0            0           	: _Tp_alloc_type(__a)
     3,564 ( 0.00%)    10 ( 0.00%)  10 ( 0.00%)     2,376 ( 0.00%)     0            0                  0            0            0           	{ }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
         .              .            .                  .              .            .                  .            .            .           	// Not defaulted, to enforce noexcept(true) even when
         .              .            .                  .              .            .                  .            .            .           	// !is_nothrow_move_constructible<_Tp_alloc_type>.
     3,059 ( 0.00%)   104 ( 0.00%)  40 ( 0.00%)         0              0            0              1,748 ( 0.00%)   0            0           	_Vector_impl(_Vector_impl&& __x) noexcept
     6,555 ( 0.00%)   115 ( 0.00%)  40 ( 0.00%)     1,748 ( 0.00%)     0            0              1,748 ( 0.00%)   0            0           	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
     1,748 ( 0.00%)     8 ( 0.00%)   8 ( 0.00%)     1,311 ( 0.00%)     0            0                  0            0            0           	{ }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           	_Vector_impl(_Tp_alloc_type&& __a) noexcept
         .              .            .                  .              .            .                  .            .            .           	: _Tp_alloc_type(std::move(__a))
         .              .            .                  .              .            .                  .            .            .           	{ }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
         .              .            .                  .              .            .                  .            .            .           	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
         .              .            .                  .              .            .                  .            .            .           	{ }
-- line 153 ----------------------------------------
-- line 268 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .           #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
         .              .            .                  .              .            .                  .            .            .           #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
         .              .            .                  .              .            .                  .            .            .                 };
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .               public:
         .              .            .                  .              .            .                  .            .            .                 typedef _Alloc allocator_type;
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 _Tp_alloc_type&
    33,894 ( 0.00%) 2,184 ( 0.00%) 545 ( 0.01%)         0              0            0             16,994 ( 0.00%)   0            0                 _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
    25,491 ( 0.00%)   113 ( 0.00%)  36 ( 0.00%)    25,491 ( 0.00%)     0            0                  0            0            0                 { return this->_M_impl; }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 const _Tp_alloc_type&
    20,230 ( 0.00%) 1,864 ( 0.00%) 536 ( 0.01%)         0              0            0             10,152 ( 0.00%)   5 ( 0.00%)   0                 _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
    15,228 ( 0.00%)    71 ( 0.00%)  29 ( 0.00%)    15,228 ( 0.00%)     0            0                  0            0            0                 { return this->_M_impl; }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 allocator_type
       108 ( 0.00%)    18 ( 0.00%)  10 ( 0.00%)         0              0            0                 54 ( 0.00%)   0            0                 get_allocator() const _GLIBCXX_NOEXCEPT
       198 ( 0.00%)     0            0                 90 ( 0.00%)     0            0                 36 ( 0.00%)   0            0                 { return allocator_type(_M_get_Tp_allocator()); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
    16,612 ( 0.00%)   341 ( 0.00%) 133 ( 0.00%)     4,536 ( 0.00%)     0            0              4,536 ( 0.00%)   0            0                 _Vector_base() = default;
         .              .            .                  .              .            .                  .            .            .           #else
         .              .            .                  .              .            .                  .            .            .                 _Vector_base() { }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
       108 ( 0.00%)     8 ( 0.00%)   8 ( 0.00%)         0              0            0                 54 ( 0.00%)   0            0                 _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       144 ( 0.00%)     0            0                 72 ( 0.00%)     0            0                 18 ( 0.00%)   0            0                 : _M_impl(__a) { }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Kept for ABI compatibility.
         .              .            .                  .              .            .                  .            .            .           #if !_GLIBCXX_INLINE_VERSION
         .              .            .                  .              .            .                  .            .            .                 _Vector_base(size_t __n)
         .              .            .                  .              .            .                  .            .            .                 : _M_impl()
         .              .            .                  .              .            .                  .            .            .                 { _M_create_storage(__n); }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
     9,360 ( 0.00%)   312 ( 0.00%)  65 ( 0.00%)         0              0            0              5,850 ( 0.00%)   0            0                 _Vector_base(size_t __n, const allocator_type& __a)
     5,850 ( 0.00%)   233 ( 0.00%)  34 ( 0.00%)     2,340 ( 0.00%)     0            0              1,170 ( 0.00%)   0            0                 : _M_impl(__a)
    10,530 ( 0.00%)   595 ( 0.00%) 108 ( 0.00%)     5,850 ( 0.00%)     0            0              1,170 ( 0.00%)   0            0                 { _M_create_storage(__n); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
     6,118 ( 0.00%)    64 ( 0.00%)  16 ( 0.00%)     1,748 ( 0.00%)     0            0              1,748 ( 0.00%)   0            0                 _Vector_base(_Vector_base&&) = default;
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Kept for ABI compatibility.
         .              .            .                  .              .            .                  .            .            .           # if !_GLIBCXX_INLINE_VERSION
         .              .            .                  .              .            .                  .            .            .                 _Vector_base(_Tp_alloc_type&& __a) noexcept
         .              .            .                  .              .            .                  .            .            .                 : _M_impl(std::move(__a)) { }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 _Vector_base(_Vector_base&& __x, const allocator_type& __a)
         .              .            .                  .              .            .                  .            .            .                 : _M_impl(__a)
-- line 316 ----------------------------------------
-- line 325 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                 }
         .              .            .                  .              .            .                  .            .            .           # endif
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
         .              .            .                  .              .            .                  .            .            .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
         .              .            .                  .              .            .                  .            .            .                 { }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
    15,660 ( 0.00%)   888 ( 0.00%) 123 ( 0.00%)         0              0            0              6,272 ( 0.00%)   0            0                 ~_Vector_base() _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
    21,952 ( 0.00%)     0            0              9,408 ( 0.00%)     0            0              3,136 ( 0.00%)   0            0           	_M_deallocate(_M_impl._M_start,
    25,447 ( 0.00%)   307 ( 0.00%)  60 ( 0.00%)    12,544 ( 0.00%)    51 ( 0.00%)  22 ( 0.00%)         0            0            0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
    18,816 ( 0.00%)    47 ( 0.00%)  25 ( 0.00%)     9,408 ( 0.00%)     0            0              3,136 ( 0.00%)   0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .               public:
         .              .            .                  .              .            .                  .            .            .                 _Vector_impl _M_impl;
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 pointer
    18,827 ( 0.00%) 1,048 ( 0.00%) 336 ( 0.00%)         0              0            0              9,432 ( 0.00%)   0            0                 _M_allocate(size_t __n)
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
    20,962 ( 0.00%)   551 ( 0.00%) 153 ( 0.00%)     7,756 ( 0.00%)     0            0              2,306 ( 0.00%)   0            0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
     6,288 ( 0.00%)   459 ( 0.00%) 114 ( 0.00%)     6,288 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 void
    35,713 ( 0.00%) 1,270 ( 0.00%) 217 ( 0.00%)         0              0            0             20,440 ( 0.00%)   0            0                 _M_deallocate(pointer __p, size_t __n)
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
    10,220 ( 0.00%)   158 ( 0.00%)  26 ( 0.00%)     5,110 ( 0.00%)     0            0                  0            0            0           	if (__p)
    13,836 ( 0.00%)    44 ( 0.00%)   0              6,918 ( 0.00%)     0            0              2,306 ( 0.00%)   0            0           	  _Tr::deallocate(_M_impl, __p, __n);
    15,330 ( 0.00%)   154 ( 0.00%)  12 ( 0.00%)    10,220 ( 0.00%)     1 ( 0.00%)   0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .               protected:
         .              .            .                  .              .            .                  .            .            .                 void
     7,020 ( 0.00%)   286 ( 0.00%)  54 ( 0.00%)         0              0            0              3,510 ( 0.00%)   0            0                 _M_create_storage(size_t __n)
         .              .            .                  .              .            .                  .            .            .                 {
     8,190 ( 0.00%)   228 ( 0.00%)  34 ( 0.00%)     3,510 ( 0.00%)     0            0              2,340 ( 0.00%)   0            0           	this->_M_impl._M_start = this->_M_allocate(__n);
     4,680 ( 0.00%)   143 ( 0.00%)  32 ( 0.00%)     3,510 ( 0.00%)     0            0              1,170 ( 0.00%)   0            0           	this->_M_impl._M_finish = this->_M_impl._M_start;
     9,372 ( 0.00%)   338 ( 0.00%)  54 ( 0.00%)     4,680 ( 0.00%)     0            0              1,170 ( 0.00%)   0            0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
     3,510 ( 0.00%)     0            0              2,340 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .               };
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .             /**
         .              .            .                  .              .            .                  .            .            .              *  @brief A standard container which offers fixed time access to
         .              .            .                  .              .            .                  .            .            .              *  individual elements in any order.
         .              .            .                  .              .            .                  .            .            .              *
         .              .            .                  .              .            .                  .            .            .              *  @ingroup sequences
         .              .            .                  .              .            .                  .            .            .              *
-- line 372 ----------------------------------------
-- line 445 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	// Instantiating std::__relocate_a might cause an error outside the
         .              .            .                  .              .            .                  .            .            .           	// immediate context (in __relocate_object_a's noexcept-specifier),
         .              .            .                  .              .            .                  .            .            .           	// so only do it if we know the type can be move-inserted into *this.
         .              .            .                  .              .            .                  .            .            .           	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
         .              .            .                  .              .            .                  .            .            .                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 static pointer
    31,030 ( 0.00%)   332 ( 0.00%) 170 ( 0.00%)         0              0            0             19,440 ( 0.00%)   0            0                 _S_do_relocate(pointer __first, pointer __last, pointer __result,
         .              .            .                  .              .            .                  .            .            .           		     _Tp_alloc_type& __alloc, true_type) noexcept
         .              .            .                  .              .            .                  .            .            .                 {
    23,328 ( 0.00%)   614 ( 0.00%) 143 ( 0.00%)    15,552 ( 0.00%)     0            0              3,888 ( 0.00%)   0            0           	return std::__relocate_a(__first, __last, __result, __alloc);
     7,776 ( 0.00%)     0            0              7,776 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 static pointer
         .              .            .                  .              .            .                  .            .            .                 _S_do_relocate(pointer, pointer, pointer __result,
         .              .            .                  .              .            .                  .            .            .           		     _Tp_alloc_type&, false_type) noexcept
         .              .            .                  .              .            .                  .            .            .                 { return __result; }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 static pointer
    31,030 ( 0.00%)    39 ( 0.00%)  30 ( 0.00%)         0              0            0             19,440 ( 0.00%)   0            0                 _S_relocate(pointer __first, pointer __last, pointer __result,
         .              .            .                  .              .            .                  .            .            .           		  _Tp_alloc_type& __alloc) noexcept
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	using __do_it = __bool_constant<_S_use_relocate()>;
    23,328 ( 0.00%)     0            0             15,552 ( 0.00%)     0            0              3,888 ( 0.00%)   0            0           	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
     7,776 ( 0.00%)    27 ( 0.00%)  12 ( 0.00%)     7,776 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           #endif // C++11
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .               protected:
         .              .            .                  .              .            .                  .            .            .                 using _Base::_M_allocate;
         .              .            .                  .              .            .                  .            .            .                 using _Base::_M_deallocate;
         .              .            .                  .              .            .                  .            .            .                 using _Base::_M_impl;
         .              .            .                  .              .            .                  .            .            .                 using _Base::_M_get_Tp_allocator;
         .              .            .                  .              .            .                  .            .            .           
-- line 478 ----------------------------------------
-- line 479 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .               public:
         .              .            .                  .              .            .                  .            .            .                 // [23.2.4.1] construct/copy/destroy
         .              .            .                  .              .            .                  .            .            .                 // (assign() and get_allocator() are also listed in this section)
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Creates a %vector with no elements.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
    16,612 ( 0.00%) 1,008 ( 0.00%) 455 ( 0.01%)     4,536 ( 0.00%)     0            0              4,536 ( 0.00%)   0            0                 vector() = default;
         .              .            .                  .              .            .                  .            .            .           #else
         .              .            .                  .              .            .                  .            .            .                 vector() { }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Creates a %vector with no elements.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __a  An allocator object.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 explicit
       108 ( 0.00%)    18 ( 0.00%)  18 ( 0.00%)         0              0            0                 54 ( 0.00%)   0            0                 vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       144 ( 0.00%)     0            0                 72 ( 0.00%)     0            0                 18 ( 0.00%)   0            0                 : _Base(__a) { }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Creates a %vector with default constructed elements.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __n  The number of elements to initially create.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __a  An allocator.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This constructor fills the %vector with @a __n default
-- line 506 ----------------------------------------
-- line 514 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Creates a %vector with copies of an exemplar element.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __n  The number of elements to initially create.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __value  An element to copy.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __a  An allocator.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This constructor fills the %vector with @a __n copies of @a __value.
         .              .            .                  .              .            .                  .            .            .                  */
       270 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)         0              0            0                180 ( 0.00%)   0            0                 vector(size_type __n, const value_type& __value,
         .              .            .                  .              .            .                  .            .            .           	     const allocator_type& __a = allocator_type())
       360 ( 0.00%)    10 ( 0.00%)  10 ( 0.00%)       120 ( 0.00%)     0            0                 60 ( 0.00%)   0            0                 : _Base(_S_check_init_len(__n, __a), __a)
       300 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)       180 ( 0.00%)     0            0                 30 ( 0.00%)   0            0                 { _M_fill_initialize(__n, __value); }
         .              .            .                  .              .            .                  .            .            .           #else
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Creates a %vector with copies of an exemplar element.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __n  The number of elements to initially create.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __value  An element to copy.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __a  An allocator.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 533 ----------------------------------------
-- line 545 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  All the elements of @a __x are copied, but any unused capacity in
         .              .            .                  .              .            .                  .            .            .                  *  @a __x  will not be copied
         .              .            .                  .              .            .                  .            .            .                  *  (i.e. capacity() == size() in the new %vector).
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  The newly-created %vector uses a copy of the allocator object used
         .              .            .                  .              .            .                  .            .            .                  *  by @a __x (unless the allocator traits dictate a different object).
         .              .            .                  .              .            .                  .            .            .                  */
    13,680 ( 0.00%)   612 ( 0.00%) 118 ( 0.00%)     1,140 ( 0.00%)     0            0              7,980 ( 0.00%)   2 ( 0.00%)   0                 vector(const vector& __x)
         .              .            .                  .              .            .                  .            .            .                 : _Base(__x.size(),
    23,940 ( 0.00%) 1,054 ( 0.00%) 143 ( 0.00%)     3,420 ( 0.00%)     0            0              5,700 ( 0.00%)   4 ( 0.00%)   0           	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
         .              .            .                  .              .            .                  .            .            .                 {
     2,280 ( 0.00%)    26 ( 0.00%)  11 ( 0.00%)     1,140 ( 0.00%)     0            0              1,140 ( 0.00%)   0            0           	this->_M_impl._M_finish =
    15,960 ( 0.00%)   717 ( 0.00%)  79 ( 0.00%)     4,560 ( 0.00%)     0            0              3,420 ( 0.00%)   0            0           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
         .              .            .                  .              .            .                  .            .            .           				      this->_M_impl._M_start,
     4,560 ( 0.00%)   158 ( 0.00%)  43 ( 0.00%)     1,140 ( 0.00%)     0            0              1,140 ( 0.00%)   0            0           				      _M_get_Tp_allocator());
    11,400 ( 0.00%)   828 ( 0.00%) 100 ( 0.00%)     7,980 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  %Vector move constructor.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  The newly-created %vector contains the exact contents of the
         .              .            .                  .              .            .                  .            .            .                  *  moved instance.
         .              .            .                  .              .            .                  .            .            .                  *  The contents of the moved instance are a valid, but unspecified
         .              .            .                  .              .            .                  .            .            .                  *  %vector.
         .              .            .                  .              .            .                  .            .            .                  */
     6,118 ( 0.00%)   235 ( 0.00%)  80 ( 0.00%)     1,748 ( 0.00%)     0            0              1,748 ( 0.00%)   0            0                 vector(vector&&) noexcept = default;
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /// Copy constructor with alternative allocator
         .              .            .                  .              .            .                  .            .            .                 vector(const vector& __x, const allocator_type& __a)
         .              .            .                  .              .            .                  .            .            .                 : _Base(__x.size(), __a)
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	this->_M_impl._M_finish =
         .              .            .                  .              .            .                  .            .            .           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
         .              .            .                  .              .            .                  .            .            .           				      this->_M_impl._M_start,
-- line 580 ----------------------------------------
-- line 670 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  The dtor only erases the elements, and note that if the
         .              .            .                  .              .            .                  .            .            .                  *  elements themselves are pointers, the pointed-to memory is
         .              .            .                  .              .            .                  .            .            .                  *  not touched in any way.  Managing the pointer is the user's
         .              .            .                  .              .            .                  .            .            .                  *  responsibility.
         .              .            .                  .              .            .                  .            .            .                  */
    15,660 ( 0.00%) 1,036 ( 0.00%) 368 ( 0.00%)         0              0            0              6,272 ( 0.00%)   0            0                 ~vector() _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
    21,952 ( 0.00%)   105 ( 0.00%)  23 ( 0.00%)    12,544 ( 0.00%) 1,036 ( 0.00%) 819 ( 0.00%)     3,136 ( 0.00%)   0            0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
    12,544 ( 0.00%)   496 ( 0.00%)  69 ( 0.00%)     3,136 ( 0.00%)     0            0              3,136 ( 0.00%)   0            0           		      _M_get_Tp_allocator());
         .              .            .                  .              .            .                  .            .            .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
    18,816 ( 0.00%)    50 ( 0.00%)  11 ( 0.00%)     9,408 ( 0.00%)     1 ( 0.00%)   0              3,136 ( 0.00%)   0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  %Vector assignment operator.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __x  A %vector of identical element and allocator types.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  All the elements of @a __x are copied, but any unused capacity in
         .              .            .                  .              .            .                  .            .            .                  *  @a __x will not be copied.
         .              .            .                  .              .            .                  .            .            .                  *
-- line 691 ----------------------------------------
-- line 701 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  The contents of @a __x are moved into this %vector (without copying,
         .              .            .                  .              .            .                  .            .            .                  *  if the allocators permit it).
         .              .            .                  .              .            .                  .            .            .                  *  Afterwards @a __x is a valid, but unspecified %vector.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  Whether the allocator is moved depends on the allocator traits.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 vector&
       108 ( 0.00%)    18 ( 0.00%)  13 ( 0.00%)         0              0            0                 54 ( 0.00%)   0            0                 operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
         .              .            .                  .              .            .                  .            .            .                 {
        18 ( 0.00%)     0            0                  0              0            0                 18 ( 0.00%)   0            0           	constexpr bool __move_storage =
         .              .            .                  .              .            .                  .            .            .           	  _Alloc_traits::_S_propagate_on_move_assign()
         .              .            .                  .              .            .                  .            .            .           	  || _Alloc_traits::_S_always_equal();
       144 ( 0.00%)     8 ( 0.00%)   5 ( 0.00%)        36 ( 0.00%)     0            0                 36 ( 0.00%)   0            0           	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
        18 ( 0.00%)     0            0                 18 ( 0.00%)     0            0                  0            0            0           	return *this;
        36 ( 0.00%)     0            0                 36 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  %Vector list assignment operator.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __l  An initializer_list.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This function fills a %vector with copies of the elements in the
         .              .            .                  .              .            .                  .            .            .                  *  initializer list @a __l.
         .              .            .                  .              .            .                  .            .            .                  *
-- line 724 ----------------------------------------
-- line 803 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // iterators
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read/write iterator that points to the first
         .              .            .                  .              .            .                  .            .            .                  *  element in the %vector.  Iteration is done in ordinary
         .              .            .                  .              .            .                  .            .            .                  *  element order.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 iterator
    17,441 ( 0.00%)   329 ( 0.00%) 208 ( 0.00%)     2,186 ( 0.00%)     0            0              6,558 ( 0.00%)   0            0                 begin() _GLIBCXX_NOEXCEPT
    24,046 ( 0.00%)   626 ( 0.00%) 333 ( 0.00%)    13,116 ( 0.00%)     0            0              2,186 ( 0.00%)   0            0                 { return iterator(this->_M_impl._M_start); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read-only (constant) iterator that points to the
         .              .            .                  .              .            .                  .            .            .                  *  first element in the %vector.  Iteration is done in ordinary
         .              .            .                  .              .            .                  .            .            .                  *  element order.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 const_iterator
    13,056 ( 0.00%)   359 ( 0.00%) 102 ( 0.00%)     1,632 ( 0.00%)     0            0              4,896 ( 0.00%)   0            0                 begin() const _GLIBCXX_NOEXCEPT
    17,952 ( 0.00%)    81 ( 0.00%)  50 ( 0.00%)     9,792 ( 0.00%)     0            0              1,632 ( 0.00%)   0            0                 { return const_iterator(this->_M_impl._M_start); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read/write iterator that points one past the last
         .              .            .                  .              .            .                  .            .            .                  *  element in the %vector.  Iteration is done in ordinary
         .              .            .                  .              .            .                  .            .            .                  *  element order.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 iterator
   220,091 ( 0.00%) 1,840 ( 0.00%) 723 ( 0.01%)    27,525 ( 0.00%)     0            0             82,575 ( 0.01%)   0            0                 end() _GLIBCXX_NOEXCEPT
   330,300 ( 0.00%) 4,237 ( 0.01%) 481 ( 0.01%)   165,150 ( 0.01%)     0            0             27,525 ( 0.00%)   0            0                 { return iterator(this->_M_impl._M_finish); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read-only (constant) iterator that points one past
         .              .            .                  .              .            .                  .            .            .                  *  the last element in the %vector.  Iteration is done in
         .              .            .                  .              .            .                  .            .            .                  *  ordinary element order.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 const_iterator
    12,344 ( 0.00%) 1,275 ( 0.00%) 215 ( 0.00%)     1,543 ( 0.00%)     0            0              4,629 ( 0.00%)   0            0                 end() const _GLIBCXX_NOEXCEPT
    18,516 ( 0.00%)   682 ( 0.00%) 107 ( 0.00%)     9,258 ( 0.00%)     0            0              1,543 ( 0.00%)   0            0                 { return const_iterator(this->_M_impl._M_finish); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read/write reverse iterator that points to the
         .              .            .                  .              .            .                  .            .            .                  *  last element in the %vector.  Iteration is done in reverse
         .              .            .                  .              .            .                  .            .            .                  *  element order.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 reverse_iterator
         .              .            .                  .              .            .                  .            .            .                 rbegin() _GLIBCXX_NOEXCEPT
-- line 847 ----------------------------------------
-- line 910 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                 const_reverse_iterator
         .              .            .                  .              .            .                  .            .            .                 crend() const noexcept
         .              .            .                  .              .            .                  .            .            .                 { return const_reverse_iterator(begin()); }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // [23.2.4.2] capacity
         .              .            .                  .              .            .                  .            .            .                 /**  Returns the number of elements in the %vector.  */
         .              .            .                  .              .            .                  .            .            .                 size_type
 3,303,206 ( 0.04%) 1,885 ( 0.00%) 653 ( 0.01%)         0              0            0          1,651,682 ( 0.12%)  71 ( 0.00%)   0                 size() const _GLIBCXX_NOEXCEPT
 9,767,883 ( 0.13%) 1,359 ( 0.00%) 400 ( 0.00%) 4,955,046 ( 0.27%) 1,361 ( 0.00%) 779 ( 0.00%)         0            0            0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**  Returns the size() of the largest possible %vector.  */
         .              .            .                  .              .            .                  .            .            .                 size_type
    19,516 ( 0.00%)   687 ( 0.00%) 398 ( 0.00%)         0              0            0              7,836 ( 0.00%)   0            0                 max_size() const _GLIBCXX_NOEXCEPT
    27,426 ( 0.00%)   668 ( 0.00%) 169 ( 0.00%)    11,754 ( 0.00%)     0            0              7,836 ( 0.00%)   0            0                 { return _S_max_size(_M_get_Tp_allocator()); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Resizes the %vector to the specified number of elements.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __new_size  Number of elements the %vector should contain.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This function will %resize the %vector to the specified
         .              .            .                  .              .            .                  .            .            .                  *  number of elements.  If the number is smaller than the
         .              .            .                  .              .            .                  .            .            .                  *  %vector's current size the %vector is truncated, otherwise
         .              .            .                  .              .            .                  .            .            .                  *  default constructed elements are appended.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 void
       204 ( 0.00%)    27 ( 0.00%)  18 ( 0.00%)         0              0            0                102 ( 0.00%)   0            0                 resize(size_type __new_size)
         .              .            .                  .              .            .                  .            .            .                 {
       238 ( 0.00%)    24 ( 0.00%)  15 ( 0.00%)        68 ( 0.00%)     0            0                 34 ( 0.00%)   0            0           	if (__new_size > size())
       110 ( 0.00%)    10 ( 0.00%)  10 ( 0.00%)        30 ( 0.00%)     0            0                 20 ( 0.00%)   0            0           	  _M_default_append(__new_size - size());
       168 ( 0.00%)    24 ( 0.00%)  15 ( 0.00%)        48 ( 0.00%)     0            0                 24 ( 0.00%)   0            0           	else if (__new_size < size())
        63 ( 0.00%)     0            0                 28 ( 0.00%)     0            0                  7 ( 0.00%)   0            0           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
       112 ( 0.00%)     0            0                 68 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Resizes the %vector to the specified number of elements.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __new_size  Number of elements the %vector should contain.
         .              .            .                  .              .            .                  .            .            .                  *  @param  __x  Data with which new elements should be populated.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This function will %resize the %vector to the specified
         .              .            .                  .              .            .                  .            .            .                  *  number of elements.  If the number is smaller than the
-- line 951 ----------------------------------------
-- line 990 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                 { _M_shrink_to_fit(); }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns the total number of elements that the %vector can
         .              .            .                  .              .            .                  .            .            .                  *  hold before needing to allocate more memory.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 size_type
       200 ( 0.00%)    40 ( 0.00%)  20 ( 0.00%)         0              0            0                100 ( 0.00%)   0            0                 capacity() const _GLIBCXX_NOEXCEPT
       100 ( 0.00%)     0            0                100 ( 0.00%)    38 ( 0.00%)   0                  0            0            0                 { return size_type(this->_M_impl._M_end_of_storage
       500 ( 0.00%)    50 ( 0.00%)  21 ( 0.00%)       200 ( 0.00%)    29 ( 0.00%)   0                  0            0            0           			 - this->_M_impl._M_start); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns true if the %vector is empty.  (Thus begin() would
         .              .            .                  .              .            .                  .            .            .                  *  equal end().)
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 _GLIBCXX_NODISCARD bool
         .              .            .                  .              .            .                  .            .            .                 empty() const _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 { return begin() == end(); }
-- line 1008 ----------------------------------------
-- line 1035 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                  *  @return  Read/write reference to data.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This operator allows for easy, array-style, data access.
         .              .            .                  .              .            .                  .            .            .                  *  Note that data access with this operator is unchecked and
         .              .            .                  .              .            .                  .            .            .                  *  out_of_range lookups are not defined. (For checked lookups
         .              .            .                  .              .            .                  .            .            .                  *  see at().)
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 reference
   276,962 ( 0.00%) 1,630 ( 0.00%) 137 ( 0.00%)         0              0            0            166,191 ( 0.01%)   0            0                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	__glibcxx_requires_subscript(__n);
   281,570 ( 0.00%) 1,685 ( 0.00%) 105 ( 0.00%)   166,191 ( 0.01%)     0            0                  0            0            0           	return *(this->_M_impl._M_start + __n);
   110,794 ( 0.00%)     0            0            110,794 ( 0.01%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  @brief  Subscript access to the data contained in the %vector.
         .              .            .                  .              .            .                  .            .            .                  *  @param __n The index of the element for which data should be
         .              .            .                  .              .            .                  .            .            .                  *  accessed.
         .              .            .                  .              .            .                  .            .            .                  *  @return  Read-only (constant) reference to data.
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This operator allows for easy, array-style, data access.
         .              .            .                  .              .            .                  .            .            .                  *  Note that data access with this operator is unchecked and
         .              .            .                  .              .            .                  .            .            .                  *  out_of_range lookups are not defined. (For checked lookups
         .              .            .                  .              .            .                  .            .            .                  *  see at().)
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 const_reference
15,455,780 ( 0.21%) 3,277 ( 0.01%) 566 ( 0.01%)         0              0            0          9,273,468 ( 0.69%)   0            0                 operator[](size_type __n) const _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	__glibcxx_requires_subscript(__n);
24,582,959 ( 0.33%)     0            0          9,273,468 ( 0.50%)     0            0                  0            0            0           	return *(this->_M_impl._M_start + __n);
 6,182,312 ( 0.08%)    11 ( 0.00%)   4 ( 0.00%) 6,182,312 ( 0.34%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .               protected:
         .              .            .                  .              .            .                  .            .            .                 /// Safety check used only from at().
         .              .            .                  .              .            .                  .            .            .                 void
         .              .            .                  .              .            .                  .            .            .                 _M_range_check(size_type __n) const
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	if (__n >= this->size())
         .              .            .                  .              .            .                  .            .            .           	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
-- line 1073 ----------------------------------------
-- line 1113 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .           	return (*this)[__n];
         .              .            .                  .              .            .                  .            .            .                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read/write reference to the data at the first
         .              .            .                  .              .            .                  .            .            .                  *  element of the %vector.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 reference
       136 ( 0.00%)    15 ( 0.00%)  15 ( 0.00%)        17 ( 0.00%)     0            0                 51 ( 0.00%)   0            0                 front() _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	__glibcxx_requires_nonempty();
       119 ( 0.00%)     0            0                 17 ( 0.00%)     0            0                 51 ( 0.00%)   0            0           	return *begin();
        85 ( 0.00%)    15 ( 0.00%)  15 ( 0.00%)        68 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read-only (constant) reference to the data at the first
         .              .            .                  .              .            .                  .            .            .                  *  element of the %vector.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 const_reference
     1,536 ( 0.00%)   120 ( 0.00%)  18 ( 0.00%)       192 ( 0.00%)     0            0                576 ( 0.00%)   0            0                 front() const _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	__glibcxx_requires_nonempty();
     1,344 ( 0.00%)    11 ( 0.00%)   0                192 ( 0.00%)     0            0                576 ( 0.00%)   0            0           	return *begin();
       960 ( 0.00%)    50 ( 0.00%)  10 ( 0.00%)       768 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read/write reference to the data at the last
         .              .            .                  .              .            .                  .            .            .                  *  element of the %vector.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 reference
   202,786 ( 0.00%) 2,120 ( 0.00%) 332 ( 0.00%)    25,356 ( 0.00%)     0            0             76,068 ( 0.01%)   0            0                 back() _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	__glibcxx_requires_nonempty();
   304,272 ( 0.00%) 1,224 ( 0.00%) 319 ( 0.00%)    25,356 ( 0.00%)     0            0            126,780 ( 0.01%)   0            0           	return *(end() - 1);
   126,780 ( 0.00%)   806 ( 0.00%) 204 ( 0.00%)   101,424 ( 0.01%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Returns a read-only (constant) reference to the data at the
         .              .            .                  .              .            .                  .            .            .                  *  last element of the %vector.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 const_reference
       824 ( 0.00%)   111 ( 0.00%)  18 ( 0.00%)       103 ( 0.00%)     0            0                309 ( 0.00%)   0            0                 back() const _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	__glibcxx_requires_nonempty();
     1,236 ( 0.00%)     0            0                103 ( 0.00%)     0            0                515 ( 0.00%)   0            0           	return *(end() - 1);
       515 ( 0.00%)    58 ( 0.00%)   9 ( 0.00%)       412 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .              .            .                  .              .            .                  .            .            .                 // DR 464. Suggestion for new member functions in standard containers.
         .              .            .                  .              .            .                  .            .            .                 // data access
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *   Returns a pointer such that [data(), data() + size()) is a valid
         .              .            .                  .              .            .                  .            .            .                  *   range.  For a non-empty %vector, data() == &front().
         .              .            .                  .              .            .                  .            .            .                  */
-- line 1166 ----------------------------------------
-- line 1179 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                  *
         .              .            .                  .              .            .                  .            .            .                  *  This is a typical stack operation.  The function creates an
         .              .            .                  .              .            .                  .            .            .                  *  element at the end of the %vector and assigns the given data
         .              .            .                  .              .            .                  .            .            .                  *  to it.  Due to the nature of a %vector this operation can be
         .              .            .                  .              .            .                  .            .            .                  *  done in constant time if the %vector has preallocated space
         .              .            .                  .              .            .                  .            .            .                  *  available.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 void
    96,042 ( 0.00%) 3,398 ( 0.01%) 323 ( 0.00%)         0              0            0             48,021 ( 0.00%)   0            0                 push_back(const value_type& __x)
         .              .            .                  .              .            .                  .            .            .                 {
    96,042 ( 0.00%)   124 ( 0.00%)  69 ( 0.00%)    64,028 ( 0.00%)     2 ( 0.00%)   0                  0            0            0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
         .              .            .                  .              .            .                  .            .            .           	  {
         .              .            .                  .              .            .                  .            .            .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
   102,711 ( 0.00%)   469 ( 0.00%)  80 ( 0.00%)    58,692 ( 0.00%)     0            0             14,673 ( 0.00%)   0            0           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         .              .            .                  .              .            .                  .            .            .           				     __x);
    73,365 ( 0.00%)    18 ( 0.00%)   0             44,019 ( 0.00%)     0            0             14,673 ( 0.00%)   0            0           	    ++this->_M_impl._M_finish;
         .              .            .                  .              .            .                  .            .            .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
         .              .            .                  .              .            .                  .            .            .           	  }
         .              .            .                  .              .            .                  .            .            .           	else
    12,006 ( 0.00%)   560 ( 0.00%) 242 ( 0.00%)     4,002 ( 0.00%)     0            0              2,668 ( 0.00%)   0            0           	  _M_realloc_insert(end(), __x);
    62,694 ( 0.00%)   231 ( 0.00%) 192 ( 0.00%)    32,014 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
         .              .            .                  .              .            .                  .            .            .                 void
     7,254 ( 0.00%)   177 ( 0.00%) 156 ( 0.00%)         0              0            0              3,627 ( 0.00%)   0            0                 push_back(value_type&& __x)
    13,299 ( 0.00%)    64 ( 0.00%)  41 ( 0.00%)     4,836 ( 0.00%)     0            0              2,418 ( 0.00%)   0            0                 { emplace_back(std::move(__x)); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 template<typename... _Args>
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus > 201402L
         .              .            .                  .              .            .                  .            .            .           	reference
         .              .            .                  .              .            .                  .            .            .           #else
         .              .            .                  .              .            .                  .            .            .           	void
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           	emplace_back(_Args&&... __args);
-- line 1212 ----------------------------------------
-- line 1490 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Erases all the elements.  Note that this function only erases the
         .              .            .                  .              .            .                  .            .            .                  *  elements, and that if the elements themselves are pointers, the
         .              .            .                  .              .            .                  .            .            .                  *  pointed-to memory is not touched in any way.  Managing the pointer is
         .              .            .                  .              .            .                  .            .            .                  *  the user's responsibility.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 void
     1,840 ( 0.00%)   268 ( 0.00%) 206 ( 0.00%)         0              0            0                736 ( 0.00%)   0            0                 clear() _GLIBCXX_NOEXCEPT
     3,312 ( 0.00%)   147 ( 0.00%) 118 ( 0.00%)     1,840 ( 0.00%)    40 ( 0.00%)  20 ( 0.00%)       368 ( 0.00%)   0            0                 { _M_erase_at_end(this->_M_impl._M_start); }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .               protected:
         .              .            .                  .              .            .                  .            .            .                 /**
         .              .            .                  .              .            .                  .            .            .                  *  Memory expansion handler.  Uses the member allocation function to
         .              .            .                  .              .            .                  .            .            .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
         .              .            .                  .              .            .                  .            .            .                  */
         .              .            .                  .              .            .                  .            .            .                 template<typename _ForwardIterator>
         .              .            .                  .              .            .                  .            .            .           	pointer
       180 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)         0              0            0                120 ( 0.00%)   0            0           	_M_allocate_and_copy(size_type __n,
         .              .            .                  .              .            .                  .            .            .           			     _ForwardIterator __first, _ForwardIterator __last)
         .              .            .                  .              .            .                  .            .            .           	{
       120 ( 0.00%)     0            0                 40 ( 0.00%)     0            0                 40 ( 0.00%)  20 ( 0.00%)   0           	  pointer __result = this->_M_allocate(__n);
         .              .            .                  .              .            .                  .            .            .           	  __try
         .              .            .                  .              .            .                  .            .            .           	    {
       100 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)        60 ( 0.00%)     0            0                 20 ( 0.00%)   0            0           	      std::__uninitialized_copy_a(__first, __last, __result,
        80 ( 0.00%)     0            0                 20 ( 0.00%)     0            0                 20 ( 0.00%)   0            0           					  _M_get_Tp_allocator());
        40 ( 0.00%)     0            0                 20 ( 0.00%)     0            0                  0            0            0           	      return __result;
         .              .            .                  .              .            .                  .            .            .           	    }
         .              .            .                  .              .            .                  .            .            .           	  __catch(...)
         .              .            .                  .              .            .                  .            .            .           	    {
         .              .            .                  .              .            .                  .            .            .           	      _M_deallocate(__result, __n);
         .              .            .                  .              .            .                  .            .            .           	      __throw_exception_again;
         .              .            .                  .              .            .                  .            .            .           	    }
        60 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)        60 ( 0.00%)     0            0                  0            0            0           	}
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Internal constructor functions follow.
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Called by the range constructor to implement [23.1.1]/9
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus < 201103L
         .              .            .                  .              .            .                  .            .            .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1531 ----------------------------------------
-- line 1585 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .           	    std::__uninitialized_copy_a(__first, __last,
         .              .            .                  .              .            .                  .            .            .           					this->_M_impl._M_start,
         .              .            .                  .              .            .                  .            .            .           					_M_get_Tp_allocator());
         .              .            .                  .              .            .                  .            .            .           	}
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Called by the first initialize_dispatch above and by the
         .              .            .                  .              .            .                  .            .            .                 // vector(n,value,a) constructor.
         .              .            .                  .              .            .                  .            .            .                 void
       210 ( 0.00%)    40 ( 0.00%)  40 ( 0.00%)         0              0            0                120 ( 0.00%)   0            0                 _M_fill_initialize(size_type __n, const value_type& __value)
         .              .            .                  .              .            .                  .            .            .                 {
        60 ( 0.00%)     0            0                 30 ( 0.00%)     0            0                 30 ( 0.00%)   0            0           	this->_M_impl._M_finish =
       180 ( 0.00%)     0            0                120 ( 0.00%)     0            0                 30 ( 0.00%)   0            0           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
       120 ( 0.00%)     0            0                 30 ( 0.00%)     0            0                 30 ( 0.00%)   0            0           					_M_get_Tp_allocator());
        90 ( 0.00%)     0            0                 60 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
         .              .            .                  .              .            .                  .            .            .                 // Called by the vector(n) constructor.
         .              .            .                  .              .            .                  .            .            .                 void
         .              .            .                  .              .            .                  .            .            .                 _M_default_initialize(size_type __n)
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	this->_M_impl._M_finish =
         .              .            .                  .              .            .                  .            .            .           	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
-- line 1606 ----------------------------------------
-- line 1748 ----------------------------------------
         .              .            .                  .              .            .                  .            .            .                 // Emplacing an rvalue of the correct type can use _M_insert_rval.
         .              .            .                  .              .            .                  .            .            .                 iterator
         .              .            .                  .              .            .                  .            .            .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
         .              .            .                  .              .            .                  .            .            .                 { return _M_insert_rval(__position, std::move(__v)); }
         .              .            .                  .              .            .                  .            .            .           #endif
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Called by _M_fill_insert, _M_insert_aux etc.
         .              .            .                  .              .            .                  .            .            .                 size_type
    21,347 ( 0.00%)   545 ( 0.00%) 265 ( 0.00%)     1,944 ( 0.00%)     0            0             11,664 ( 0.00%)   0            0                 _M_check_len(size_type __n, const char* __s) const
         .              .            .                  .              .            .                  .            .            .                 {
    27,216 ( 0.00%)   891 ( 0.00%) 288 ( 0.00%)     5,832 ( 0.00%)     0            0              3,888 ( 0.00%)   0            0           	if (max_size() - size() < __n)
         .              .            .                  .              .            .                  .            .            .           	  __throw_length_error(__N(__s));
         .              .            .                  .              .            .                  .            .            .           
    31,104 ( 0.00%) 1,134 ( 0.00%) 398 ( 0.00%)     5,832 ( 0.00%)     0            0              9,720 ( 0.00%)   0            0           	const size_type __len = size() + (std::max)(size(), __n);
    21,384 ( 0.00%)   944 ( 0.00%) 324 ( 0.00%)     9,720 ( 0.00%)     0            0              3,888 ( 0.00%)   0            0           	return (__len < size() || __len > max_size()) ? max_size() : __len;
    11,664 ( 0.00%)   325 ( 0.00%) 239 ( 0.00%)     9,720 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Called by constructors to check initial size.
         .              .            .                  .              .            .                  .            .            .                 static size_type
       300 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)        30 ( 0.00%)     0            0                150 ( 0.00%)   0            0                 _S_check_init_len(size_type __n, const allocator_type& __a)
         .              .            .                  .              .            .                  .            .            .                 {
       450 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)        60 ( 0.00%)     0            0                 90 ( 0.00%)   0            0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
         .              .            .                  .              .            .                  .            .            .           	  __throw_length_error(
         .              .            .                  .              .            .                  .            .            .           	      __N("cannot create std::vector larger than max_size()"));
        30 ( 0.00%)     0            0                 30 ( 0.00%)     0            0                  0            0            0           	return __n;
       180 ( 0.00%)    20 ( 0.00%)  20 ( 0.00%)       150 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 static size_type
    31,510 ( 0.00%) 1,617 ( 0.00%) 489 ( 0.01%)     3,948 ( 0.00%)     0            0             11,844 ( 0.00%)   0            0                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
         .              .            .                  .              .            .                  .            .            .           	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
         .              .            .                  .              .            .                  .            .            .           	// (even if std::allocator_traits::max_size says we can).
     7,896 ( 0.00%)   183 ( 0.00%)  93 ( 0.00%)         0              0            0              3,948 ( 0.00%)   0            0           	const size_t __diffmax
         .              .            .                  .              .            .                  .            .            .           	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
    15,792 ( 0.00%)    93 ( 0.00%)  43 ( 0.00%)     3,948 ( 0.00%)     0            0              7,896 ( 0.00%)   0            0           	const size_t __allocmax = _Alloc_traits::max_size(__a);
    23,688 ( 0.00%)     0            0              3,948 ( 0.00%)     0            0              3,948 ( 0.00%)   0            0           	return (std::min)(__diffmax, __allocmax);
    19,740 ( 0.00%)    46 ( 0.00%)  46 ( 0.00%)    15,792 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Internal erase functions follow.
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
         .              .            .                  .              .            .                  .            .            .                 // _M_assign_aux.
         .              .            .                  .              .            .                  .            .            .                 void
     2,250 ( 0.00%)   534 ( 0.00%) 335 ( 0.00%)         0              0            0              1,125 ( 0.00%)   4 ( 0.00%)   0                 _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
         .              .            .                  .              .            .                  .            .            .                 {
     3,579 ( 0.00%)    37 ( 0.00%)  35 ( 0.00%)     1,500 ( 0.00%)     0            0                375 ( 0.00%)   0            0           	if (size_type __n = this->_M_impl._M_finish - __pos)
         .              .            .                  .              .            .                  .            .            .           	  {
     1,182 ( 0.00%)     0            0                591 ( 0.00%)     0            0                197 ( 0.00%)   0            0           	    std::_Destroy(__pos, this->_M_impl._M_finish,
       788 ( 0.00%)   127 ( 0.00%)  84 ( 0.00%)       197 ( 0.00%)     0            0                197 ( 0.00%)   0            0           			  _M_get_Tp_allocator());
       591 ( 0.00%)     7 ( 0.00%)   7 ( 0.00%)       394 ( 0.00%)     0            0                197 ( 0.00%)   0            0           	    this->_M_impl._M_finish = __pos;
         .              .            .                  .              .            .                  .            .            .           	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
         .              .            .                  .              .            .                  .            .            .           	  }
     1,125 ( 0.00%)   129 ( 0.00%)  71 ( 0.00%)       750 ( 0.00%)     0            0                  0            0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 iterator
         .              .            .                  .              .            .                  .            .            .                 _M_erase(iterator __position);
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 iterator
         .              .            .                  .              .            .                  .            .            .                 _M_erase(iterator __first, iterator __last);
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .           #if __cplusplus >= 201103L
         .              .            .                  .              .            .                  .            .            .               private:
         .              .            .                  .              .            .                  .            .            .                 // Constant-time move assignment when source object's memory can be
         .              .            .                  .              .            .                  .            .            .                 // moved, either because the source's allocator will move too
         .              .            .                  .              .            .                  .            .            .                 // or because the allocators are equal.
         .              .            .                  .              .            .                  .            .            .                 void
       180 ( 0.00%)    18 ( 0.00%)  18 ( 0.00%)        18 ( 0.00%)     0            0                 90 ( 0.00%)   0            0                 _M_move_assign(vector&& __x, true_type) noexcept
         .              .            .                  .              .            .                  .            .            .                 {
       234 ( 0.00%)     8 ( 0.00%)   8 ( 0.00%)        18 ( 0.00%)     0            0                 54 ( 0.00%)   0            0           	vector __tmp(get_allocator());
        90 ( 0.00%)    10 ( 0.00%)  10 ( 0.00%)        36 ( 0.00%)     0            0                 18 ( 0.00%)   0            0           	this->_M_impl._M_swap_data(__x._M_impl);
        90 ( 0.00%)     0            0                 18 ( 0.00%)     0            0                 18 ( 0.00%)   0            0           	__tmp._M_impl._M_swap_data(__x._M_impl);
       180 ( 0.00%)    18 ( 0.00%)  15 ( 0.00%)        36 ( 0.00%)     0            0                 54 ( 0.00%)   0            0           	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
       162 ( 0.00%)     0            0                 90 ( 0.00%)     0            0                 18 ( 0.00%)   0            0                 }
         .              .            .                  .              .            .                  .            .            .           
         .              .            .                  .              .            .                  .            .            .                 // Do move assignment when it might not be possible to move source
         .              .            .                  .              .            .                  .            .            .                 // object's memory, resulting in a linear-time operation.
         .              .            .                  .              .            .                  .            .            .                 void
         .              .            .                  .              .            .                  .            .            .                 _M_move_assign(vector&& __x, false_type)
         .              .            .                  .              .            .                  .            .            .                 {
         .              .            .                  .              .            .                  .            .            .           	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
         .              .            .                  .              .            .                  .            .            .           	  _M_move_assign(std::move(__x), true_type());
-- line 1829 ----------------------------------------

--------------------------------------------------------------------------------
-- User-annotated source: cachegrind.out.9430
--------------------------------------------------------------------------------
  No information has been collected for cachegrind.out.9430

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/./elf/dl-lookup.c
  ./malloc/./malloc/malloc.c
  ./math/../sysdeps/ieee754/dbl-64/e_hypot.c
  ./nptl/./nptl/pthread_mutex_lock.c
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strchr-avx2.S
  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S
  ./string/../sysdeps/x86_64/strcmp.S

--------------------------------------------------------------------------------
Ir                     I1mr               ILmr             Dr                   D1mr             DLmr             Dw                   D1mw            DLmw            
--------------------------------------------------------------------------------
1,450,763,433 (19.53%) 1,024,734 ( 2.01%) 196,709 ( 2.45%) 439,434,865 (23.90%) 355,007 ( 0.28%) 346,081 ( 0.39%) 407,015,683 (30.48%) 27,301 ( 0.02%) 13,484 ( 0.01%)  events annotated

