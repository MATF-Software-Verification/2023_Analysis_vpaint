--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         12582912 B, 64 B, 12-way associative
Command:          ../build/src/Gui/./VPaint
Data file:        cachegrind.out.9430
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr                ILmr                Dr                     D1mr                 DLmr                 Dw                     D1mw                 DLmw                 
--------------------------------------------------------------------------------
12,890,648,807 (100.0%) 61,904,187 (100.0%) 10,452,435 (100.0%) 3,377,230,446 (100.0%) 250,254,098 (100.0%) 228,000,057 (100.0%) 2,844,209,557 (100.0%) 398,550,877 (100.0%) 313,843,782 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr                ILmr               Dr                   D1mr                 DLmr                 Dw                   D1mw                 DLmw                  file:function
--------------------------------------------------------------------------------
5,091,266,093 (39.50%) 27,191,407 (43.92%) 5,866,669 (56.13%) 993,376,218 (29.41%)  11,006,496 ( 4.40%)   2,766,602 ( 1.21%) 795,885,439 (27.98%) 172,322,779 (43.24%)  89,584,741 (28.54%)  ???:???
1,247,578,456 ( 9.68%)    134,193 ( 0.22%)    18,033 ( 0.17%) 453,957,354 (13.44%) 223,331,972 (89.24%) 221,310,834 (97.07%) 453,346,210 (15.94%) 223,464,631 (56.07%) 223,286,047 (71.15%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  254,531,412 ( 1.97%)      2,762 ( 0.00%)     1,734 ( 0.02%)  59,889,744 ( 1.77%)           0                    0           67,375,962 ( 2.37%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 2, 1, 0, 2, 1>, 0>::coeff(long) const
  206,787,816 ( 1.60%)      4,969 ( 0.01%)     2,214 ( 0.02%)  60,313,113 ( 1.79%)           0                    0           68,929,272 ( 2.42%)         213 ( 0.00%)           8 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > >::evaluator(Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > const&)
  170,219,539 ( 1.32%)      4,908 ( 0.01%)        68 ( 0.00%)  72,951,231 ( 2.16%)           0                    0           48,634,154 ( 1.71%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::derived() const
  147,446,814 ( 1.14%)     11,278 ( 0.02%)     1,380 ( 0.01%)  34,693,368 ( 1.03%)           0                    0           39,030,039 ( 1.37%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 3, 1, 0, 3, 1>, 0>::coeff(long) const
  143,992,178 ( 1.12%)      4,324 ( 0.01%)     1,360 ( 0.01%)  39,270,594 ( 1.16%)           0                    0           39,270,594 ( 1.38%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/XprHelper.h:Eigen::internal::variable_if_dynamic<long, 0>::variable_if_dynamic(long)
  142,238,142 ( 1.10%)      3,889 ( 0.01%)     2,614 ( 0.03%)  52,403,526 ( 1.55%)           0                    0           37,431,090 ( 1.32%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 2, 1, 0, 2, 1>, 0>::operator[](long) const
  136,894,132 ( 1.06%)      1,606 ( 0.00%)       505 ( 0.00%)  40,262,980 ( 1.19%)           0                    0           40,262,980 ( 1.42%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::size() const
  120,626,226 ( 0.94%)      2,019 ( 0.00%)       480 ( 0.00%)  34,464,636 ( 1.02%)           0                    0           34,464,636 ( 1.21%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::evaluator(Eigen::Matrix<double, 2, 1, 0, 2, 1> const&)
  114,419,362 ( 0.89%)    229,769 ( 0.37%)     9,742 ( 0.09%)  19,707,983 ( 0.58%)       8,607 ( 0.00%)         124 ( 0.00%)   8,465,919 ( 0.30%)     117,845 ( 0.03%)       9,884 ( 0.00%)  ???:QBezier::addToPolygon(QDataBuffer<QPointF>&, double) const
  111,871,080 ( 0.87%)        809 ( 0.00%)       431 ( 0.00%)  37,290,360 ( 1.10%)           1 ( 0.00%)           0           22,374,216 ( 0.79%)           0                    0           /usr/include/c++/11/bits/stl_vector.h:std::vector<VectorAnimationComplex::Triangle, Eigen::aligned_allocator<VectorAnimationComplex::Triangle> >::operator[](unsigned long) const
  106,595,832 ( 0.83%)     12,558 ( 0.02%)       933 ( 0.01%)  31,090,451 ( 0.92%)           0                    0           35,531,944 ( 1.25%)         406 ( 0.00%)           1 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >::evaluator(Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > const&)
   98,308,647 ( 0.76%)      5,590 ( 0.01%)     3,031 ( 0.03%)  29,856,353 ( 0.88%)     933,930 ( 0.37%)     929,201 ( 0.41%)  23,650,919 ( 0.83%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/Triangles.cpp:VectorAnimationComplex::Triangles::draw() const
   97,260,684 ( 0.75%)     16,957 ( 0.03%)       965 ( 0.01%)  24,315,171 ( 0.72%)           0                    0           32,420,228 ( 1.14%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::rows() const
   97,260,684 ( 0.75%)        195 ( 0.00%)         1 ( 0.00%)  24,315,171 ( 0.72%)           0                    0           32,420,228 ( 1.14%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::cols() const
   96,610,136 ( 0.75%)      7,578 ( 0.01%)       552 ( 0.01%)  34,409,267 ( 1.02%)   3,763,446 ( 1.50%)      36,911 ( 0.02%)   8,058,355 ( 0.28%)       5,864 ( 0.00%)         150 ( 0.00%)  ./elf/./elf/dl-lookup.c:do_lookup_x
   96,504,275 ( 0.75%)      2,102 ( 0.00%)       680 ( 0.01%)  27,572,650 ( 0.82%)           0                    0           27,572,650 ( 0.97%)       1,884 ( 0.00%)          25 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/Meta.h:Eigen::internal::noncopyable::noncopyable()
   96,504,275 ( 0.75%)          0                  0           27,572,650 ( 0.82%)           0                    0           27,572,650 ( 0.97%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/Meta.h:Eigen::internal::noncopyable::~noncopyable()
   94,777,749 ( 0.74%)      2,172 ( 0.00%)       495 ( 0.00%)  25,848,477 ( 0.77%)           0                    0           25,848,477 ( 0.91%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::~evaluator()
   94,777,749 ( 0.74%)      1,019 ( 0.00%)         2 ( 0.00%)  25,848,477 ( 0.77%)           0                    0           25,848,477 ( 0.91%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::~evaluator_base()
   94,777,749 ( 0.74%)          0                  0           25,848,477 ( 0.77%)           0                    0           25,848,477 ( 0.91%)         358 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::evaluator_base()
   94,777,749 ( 0.74%)          0                  0           25,848,477 ( 0.77%)           0                    0           25,848,477 ( 0.91%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > >::~evaluator()
   92,187,151 ( 0.72%)      3,212 ( 0.01%)       929 ( 0.01%)  39,508,779 ( 1.17%)           0                    0           26,339,186 ( 0.93%)           4 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::derived() const
   89,834,616 ( 0.70%)        776 ( 0.00%)        46 ( 0.00%)  37,431,090 ( 1.11%)           0                    0           22,458,654 ( 0.79%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> > >::coeff(long) const
   87,334,970 ( 0.68%)    660,448 ( 1.07%)    21,071 ( 0.20%)  25,865,627 ( 0.77%)     216,032 ( 0.09%)      42,422 ( 0.02%)  12,055,609 ( 0.42%)      26,212 ( 0.01%)       2,234 ( 0.00%)  ./malloc/./malloc/malloc.c:_int_free
   86,161,590 ( 0.67%)      1,170 ( 0.00%)        20 ( 0.00%)  25,848,477 ( 0.77%)           0                    0           25,848,477 ( 0.91%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::data() const
   82,396,749 ( 0.64%)     49,816 ( 0.08%)     1,171 ( 0.01%)  30,356,697 ( 0.90%)           0                    0           21,683,355 ( 0.76%)           1 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 3, 1, 0, 3, 1>, 0>::operator[](long) const
   74,497,198 ( 0.58%)  1,167,116 ( 1.89%)    59,265 ( 0.57%)  12,865,407 ( 0.38%)     378,016 ( 0.15%)     100,628 ( 0.04%)  11,535,466 ( 0.41%)     361,752 ( 0.09%)     180,182 ( 0.06%)  ./malloc/./malloc/malloc.c:_int_malloc
   74,093,820 ( 0.57%)     14,561 ( 0.02%)       518 ( 0.00%)  21,792,300 ( 0.65%)           0                    0           21,792,300 ( 0.77%)           6 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::size() const
   74,054,816 ( 0.57%)      1,533 ( 0.00%)        22 ( 0.00%)  18,513,704 ( 0.55%)           0                    0           27,770,556 ( 0.98%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::rows() const
   74,054,816 ( 0.57%)          0                  0           18,513,704 ( 0.55%)           0                    0           27,770,556 ( 0.98%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 2, 1, 0, 2, 1> >::cols() const
   62,180,902 ( 0.48%)     10,389 ( 0.02%)       467 ( 0.00%)  17,765,972 ( 0.53%)           0                    0           17,765,972 ( 0.62%)           1 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::evaluator(Eigen::Matrix<double, 3, 1, 0, 3, 1> const&)
   60,313,113 ( 0.47%)      1,435 ( 0.00%)       890 ( 0.01%)  25,848,477 ( 0.77%)           0                    0           17,232,318 ( 0.61%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 2, 2, 1, 0>::data() const
   55,541,112 ( 0.43%)        836 ( 0.00%)        53 ( 0.00%)  18,513,704 ( 0.55%)           0                    0            9,256,852 ( 0.33%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 2, 2, 1, 0>::rows()
   55,541,112 ( 0.43%)          0                  0           18,513,704 ( 0.55%)           0                    0            9,256,852 ( 0.33%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 2, 2, 1, 0>::cols()
   52,535,064 ( 0.41%)     25,224 ( 0.04%)       934 ( 0.01%)  13,133,766 ( 0.39%)           0                    0           17,511,688 ( 0.62%)           6 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::rows() const
   52,535,064 ( 0.41%)          0                  0           13,133,766 ( 0.39%)           0                    0           17,511,688 ( 0.62%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h:Eigen::EigenBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::cols() const
   52,056,072 ( 0.40%)        793 ( 0.00%)       411 ( 0.00%)  21,690,030 ( 0.64%)           0                    0           13,014,018 ( 0.46%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >::coeff(long) const
   50,753,769 ( 0.39%)    302,345 ( 0.49%)    10,770 ( 0.10%)  13,232,246 ( 0.39%)     299,218 ( 0.12%)      60,095 ( 0.03%)   5,925,124 ( 0.21%)       9,074 ( 0.00%)         478 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc
   48,856,423 ( 0.38%)     11,435 ( 0.02%)       466 ( 0.00%)  13,324,479 ( 0.39%)           0                    0           13,324,479 ( 0.47%)          89 ( 0.00%)          22 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::evaluator_base()
   48,856,423 ( 0.38%)      7,856 ( 0.01%)       878 ( 0.01%)  13,324,479 ( 0.39%)           0                    0           13,324,479 ( 0.47%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::~evaluator()
   48,856,423 ( 0.38%)      5,181 ( 0.01%)       412 ( 0.00%)  13,324,479 ( 0.39%)           0                    0           13,324,479 ( 0.47%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator_base<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::~evaluator_base()
   48,856,423 ( 0.38%)          0                  0           13,324,479 ( 0.39%)           0                    0           13,324,479 ( 0.47%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h:Eigen::internal::evaluator<Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >::~evaluator()
   44,419,380 ( 0.34%)     11,165 ( 0.02%)       466 ( 0.00%)  13,325,814 ( 0.39%)           0                    0           13,325,814 ( 0.47%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::data() const
   43,061,112 ( 0.33%)    113,218 ( 0.18%)     4,277 ( 0.04%)  14,804,397 ( 0.44%)       9,247 ( 0.00%)       1,172 ( 0.00%)   4,027,229 ( 0.14%)       3,171 ( 0.00%)          16 ( 0.00%)  ???:QTransform::map(QPointF const&) const
   41,460,200 ( 0.32%)    110,133 ( 0.18%)     5,085 ( 0.05%)     227,916 ( 0.01%)         322 ( 0.00%)           0           39,104,805 ( 1.37%)     694,112 ( 0.17%)     335,029 ( 0.11%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
   38,440,423 ( 0.30%)        803 ( 0.00%)       513 ( 0.00%)  10,501,020 ( 0.31%)           0                    0            9,334,240 ( 0.33%)         129 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/SculptCurve.h:SculptCurve::Curve<VectorAnimationComplex::EdgeSample>::operator[](int) const
   36,500,544 ( 0.28%)        201 ( 0.00%)        70 ( 0.00%)  10,139,040 ( 0.30%)           0                    0           12,673,800 ( 0.45%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/SculptCurve.h:SculptCurve::Curve<VectorAnimationComplex::EdgeSample>::intersects(VectorAnimationComplex::EdgeSample&, VectorAnimationComplex::EdgeSample&, VectorAnimationComplex::EdgeSample&, VectorAnimationComplex::EdgeSample&, double&, double&, double)
   36,225,448 ( 0.28%)          0                  0            9,056,362 ( 0.27%)           0                    0           13,584,543 ( 0.48%)          22 ( 0.00%)          15 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::rows() const
   36,225,448 ( 0.28%)          0                  0            9,056,362 ( 0.27%)           0                    0           13,584,543 ( 0.48%)           2 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::cols() const
   31,093,566 ( 0.24%)      5,627 ( 0.01%)       872 ( 0.01%)  13,325,814 ( 0.39%)           0                    0            8,883,876 ( 0.31%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 3, 3, 1, 0>::data() const
   29,600,508 ( 0.23%)      1,116 ( 0.00%)       266 ( 0.00%)   8,457,288 ( 0.25%)         401 ( 0.00%)         150 ( 0.00%)   6,342,966 ( 0.22%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/EdgeSample.h:VectorAnimationComplex::EdgeSample::y() const
   29,600,508 ( 0.23%)        886 ( 0.00%)       245 ( 0.00%)   8,457,288 ( 0.25%)         290 ( 0.00%)         211 ( 0.00%)   6,342,966 ( 0.22%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/EdgeSample.h:VectorAnimationComplex::EdgeSample::x() const
   28,954,321 ( 0.22%)      5,733 ( 0.01%)       426 ( 0.00%)   4,136,291 ( 0.12%)       1,529 ( 0.00%)         719 ( 0.00%)           0                    0                    0           ./string/../sysdeps/x86_64/multiarch/strchr-avx2.S:__strchr_avx2
   27,169,086 ( 0.21%)      9,725 ( 0.02%)        52 ( 0.00%)   9,056,362 ( 0.27%)           0                    0            4,528,181 ( 0.16%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 3, 3, 1, 0>::cols()
   27,169,086 ( 0.21%)        927 ( 0.00%)       465 ( 0.00%)   9,056,362 ( 0.27%)           0                    0            4,528,181 ( 0.16%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 3, 3, 1, 0>::rows()
   25,112,616 ( 0.19%)    176,011 ( 0.28%)     4,458 ( 0.04%)   9,007,329 ( 0.27%)     162,863 ( 0.07%)      39,999 ( 0.02%)   4,366,668 ( 0.15%)      11,111 ( 0.00%)         542 ( 0.00%)  ./malloc/./malloc/malloc.c:free
   24,299,232 ( 0.19%)      4,667 ( 0.01%)       317 ( 0.00%)   4,298,136 ( 0.13%)      92,250 ( 0.04%)      45,032 ( 0.02%)   1,581,022 ( 0.06%)       1,474 ( 0.00%)         120 ( 0.00%)  ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x
   21,364,172 ( 0.17%)      1,599 ( 0.00%)         6 ( 0.00%)   6,283,580 ( 0.19%)           0                    0            6,283,580 ( 0.22%)           3 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h:Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::PlainObjectBase(Eigen::PlainObjectBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> > const&)
   21,177,396 ( 0.16%)     21,292 ( 0.03%)     3,216 ( 0.03%)   5,478,836 ( 0.16%)       6,640 ( 0.00%)         698 ( 0.00%)   4,747,948 ( 0.17%)          97 ( 0.00%)           0           ???:QWidgetPrivate::safeAreaMargins() const
   20,876,625 ( 0.16%)     47,367 ( 0.08%)     3,659 ( 0.04%)   8,267,770 ( 0.24%)     595,387 ( 0.24%)      87,162 ( 0.04%)     131,922 ( 0.00%)         232 ( 0.00%)           3 ( 0.00%)  ???:QMetaObject::indexOfProperty(char const*) const
   20,205,216 ( 0.16%)        750 ( 0.00%)         3 ( 0.00%)   8,839,782 ( 0.26%)      21,230 ( 0.01%)      13,832 ( 0.01%)   7,576,956 ( 0.27%)      14,370 ( 0.00%)      11,030 ( 0.00%)  /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h:Eigen::DenseStorage<double, 3, 3, 1, 0>::DenseStorage(Eigen::DenseStorage<double, 3, 3, 1, 0> const&)
   19,987,168 ( 0.16%)      1,652 ( 0.00%)       856 ( 0.01%)   7,495,188 ( 0.22%)       1,799 ( 0.00%)       1,737 ( 0.00%)   2,498,396 ( 0.09%)           0                    0           /usr/include/c++/11/bits/stl_vector.h:std::vector<VectorAnimationComplex::Triangle, Eigen::aligned_allocator<VectorAnimationComplex::Triangle> >::size() const
   19,806,290 ( 0.15%)      4,246 ( 0.01%)     1,319 ( 0.01%)   4,527,152 ( 0.13%)           0                    0            5,093,046 ( 0.18%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h:Eigen::DenseCoeffsBase<Eigen::Matrix<double, 2, 1, 0, 2, 1>, 1>::coeffRef(long)
   19,724,832 ( 0.15%)      1,466 ( 0.00%)       307 ( 0.00%)   7,396,812 ( 0.22%)         731 ( 0.00%)         338 ( 0.00%)   2,465,604 ( 0.09%)           3 ( 0.00%)           0           /usr/include/c++/11/bits/stl_vector.h:std::vector<VectorAnimationComplex::EdgeSample, Eigen::aligned_allocator<VectorAnimationComplex::EdgeSample> >::size() const
   19,205,236 ( 0.15%)     14,342 ( 0.02%)     1,083 ( 0.01%)   3,576,488 ( 0.11%)     205,433 ( 0.08%)      18,001 ( 0.01%)           0                    0                    0           ./string/../sysdeps/x86_64/strcmp.S:strcmp
   19,046,688 ( 0.15%)        465 ( 0.00%)       165 ( 0.00%)   6,457,284 ( 0.19%)           8 ( 0.00%)           8 ( 0.00%)   7,616,430 ( 0.27%)           0                    0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/SculptCurve.h:SculptCurve::Curve<VectorAnimationComplex::EdgeSample>::intersects(double, double, double, double, double, double, double, double, double&, double&, double)
   17,847,570 ( 0.14%)        576 ( 0.00%)       231 ( 0.00%)   5,949,190 ( 0.18%)           0                    0            3,569,514 ( 0.13%)           0                    0           /usr/include/c++/11/bits/stl_vector.h:std::vector<VectorAnimationComplex::EdgeSample, Eigen::aligned_allocator<VectorAnimationComplex::EdgeSample> >::operator[](unsigned long) const
   17,594,024 ( 0.14%)        547 ( 0.00%)        12 ( 0.00%)   5,026,864 ( 0.15%)           0                    0            5,026,864 ( 0.18%)         132 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/Matrix.h:Eigen::Matrix<double, 3, 1, 0, 3, 1>::Matrix(Eigen::Matrix<double, 3, 1, 0, 3, 1> const&)
   17,404,002 ( 0.14%)     10,967 ( 0.02%)       262 ( 0.00%)   4,972,572 ( 0.15%)           0                    0            4,972,572 ( 0.17%)           1 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/EdgeSample.h:VectorAnimationComplex::EdgeSample::EdgeSample(VectorAnimationComplex::EdgeSample const&)
   16,602,864 ( 0.13%)      1,245 ( 0.00%)       445 ( 0.00%)   2,477,821 ( 0.07%)         125 ( 0.00%)          34 ( 0.00%)   1,775,190 ( 0.06%)           0                    0           ???:QColor::toRgb() const
   16,251,040 ( 0.13%)         12 ( 0.00%)        12 ( 0.00%)   1,964,591 ( 0.06%)           6 ( 0.00%)           0               24,549 ( 0.00%)         257 ( 0.00%)         206 ( 0.00%)  ???:init_scan_orders()
   16,176,000 ( 0.13%)     91,227 ( 0.15%)     4,786 ( 0.05%)   2,761,710 ( 0.08%)      14,248 ( 0.01%)         957 ( 0.00%)           0                    0                    0           ./math/../sysdeps/ieee754/dbl-64/e_hypot.c:hypot@@GLIBC_2.35
   14,938,098 ( 0.12%)     79,004 ( 0.13%)     8,070 ( 0.08%)   3,079,769 ( 0.09%)     387,612 ( 0.15%)      97,127 ( 0.04%)   2,284,616 ( 0.08%)       6,814 ( 0.00%)         689 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc_consolidate
   14,696,121 ( 0.11%)    140,037 ( 0.23%)     4,268 ( 0.04%)   1,403,076 ( 0.04%)           2 ( 0.00%)           0            2,710,837 ( 0.10%)      28,493 ( 0.01%)       5,430 ( 0.00%)  ???:QArrayData::allocate(unsigned long, unsigned long, unsigned long, QFlags<QArrayData::AllocationOption>)
   14,168,638 ( 0.11%)        905 ( 0.00%)         3 ( 0.00%)   3,864,174 ( 0.11%)           0                    0            3,864,174 ( 0.14%)         135 ( 0.00%)           0           /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/MatrixBase.h:Eigen::MatrixBase<Eigen::Matrix<double, 3, 1, 0, 3, 1> >::MatrixBase()
   13,891,716 ( 0.11%)     18,118 ( 0.03%)     9,522 ( 0.09%)   3,929,796 ( 0.12%)       4,544 ( 0.00%)       1,775 ( 0.00%)     798,732 ( 0.03%)           0                    0           ./math/../sysdeps/ieee754/dbl-64/s_sin.c:__cos_fma
   13,848,938 ( 0.11%)    142,874 ( 0.23%)    21,938 ( 0.21%)   2,066,234 ( 0.06%)      27,473 ( 0.01%)       7,292 ( 0.00%)     574,363 ( 0.02%)       9,602 ( 0.00%)       3,076 ( 0.00%)  ???:QUnicodeTools::initCharAttributes(unsigned short const*, int, QUnicodeTools::ScriptItem const*, int, QCharAttributes*, QFlags<QUnicodeTools::CharAttributeOption>)
   13,726,750 ( 0.11%)    355,522 ( 0.57%)    46,881 ( 0.45%)   3,687,070 ( 0.11%)       6,654 ( 0.00%)         744 ( 0.00%)   1,838,218 ( 0.06%)       5,753 ( 0.00%)         611 ( 0.00%)  ???:QTextLine::layout_helper(int)
   13,632,966 ( 0.11%)     21,977 ( 0.04%)    10,764 ( 0.10%)   3,895,632 ( 0.12%)      22,968 ( 0.01%)       8,156 ( 0.00%)     710,748 ( 0.02%)           0                    0           ./math/../sysdeps/ieee754/dbl-64/s_sin.c:__sin_fma
   13,533,169 ( 0.10%)     68,276 ( 0.11%)     2,487 ( 0.02%)   4,111,067 ( 0.12%)      60,186 ( 0.02%)      36,586 ( 0.02%)     835,955 ( 0.03%)           0                    0           ???:QWidgetPrivate::windowHandle(QWidgetPrivate::WindowHandleMode) const

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/Triangles.cpp
--------------------------------------------------------------------------------
Ir                  I1mr           ILmr         Dr                 D1mr             DLmr             Dw                 D1mw       DLmw       

-- line 18 ----------------------------------------
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           #include "../OpenGL.h"
         .              .            .                  .                .                .                  .          .          .           #include "../View3DSettings.h"
         .              .            .                  .                .                .                  .          .          .           #include <limits>
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           namespace VectorAnimationComplex
         .              .            .                  .                .                .                  .          .          .           {
         .              .            .                  .                .                .                  .          .          .           
       300 ( 0.00%)    58 ( 0.00%)  39 ( 0.00%)         0                0                0                120 ( 0.00%) 0          0           Triangles::Triangles() :
       420 ( 0.00%)    59 ( 0.00%)  39 ( 0.00%)       120 ( 0.00%)       0                0                240 ( 0.00%) 1 ( 0.00%) 1 ( 0.00%)      triangles_()
         .              .            .                  .                .                .                  .          .          .           {
       180 ( 0.00%)     0            0                120 ( 0.00%)       0                0                  0          0          0           }
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           bool Triangle::intersects(const Eigen::Vector2d & p) const
    19,701 ( 0.00%)    22 ( 0.00%)  11 ( 0.00%)     2,189 ( 0.00%)       0                0              8,756 ( 0.00%) 0          0           {
    65,670 ( 0.00%)    22 ( 0.00%)  22 ( 0.00%)     8,756 ( 0.00%)       0                0             13,134 ( 0.00%) 0          0               double a1 = cross(b-a,p-a);
    70,048 ( 0.00%)    22 ( 0.00%)  22 ( 0.00%)     8,756 ( 0.00%)       0                0             13,134 ( 0.00%) 0          0               double a2 = cross(c-b,p-b);
    67,859 ( 0.00%)    22 ( 0.00%)  22 ( 0.00%)     8,756 ( 0.00%)       0                0             13,134 ( 0.00%) 0          0               double a3 = cross(a-c,p-c);
         .              .            .                  .                .                .                  .          .          .           
    26,431 ( 0.00%)    11 ( 0.00%)  11 ( 0.00%)     7,109 ( 0.00%)       0                0                  0          0          0               return (a1 >= 0 && a2 >=0 && a3 >= 0) || (a1 <= 0 && a2 <=0 && a3 <= 0);
    10,945 ( 0.00%)    11 ( 0.00%)  11 ( 0.00%)     8,756 ( 0.00%)       0                0                  0          0          0           }
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           namespace
         .              .            .                  .                .                .                  .          .          .           {
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           void threeWayMinMax(double a, double b, double c, double & min, double & max)
         .              .            .                  .                .                .                  .          .          .           {
         .              .            .                  .                .                .                  .          .          .               if(a<b)
         .              .            .                  .                .                .                  .          .          .               {
-- line 46 ----------------------------------------
-- line 139 ----------------------------------------
         .              .            .                  .                .                .                  .          .          .                                        r_xMin-c[0], r_xMax-c[0], r_yMin-c[1], r_yMax-c[1],
         .              .            .                  .                .                .                  .          .          .                                        b[0]-c[0], b[1]-c[1])) return false;
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .               // In all other cases
         .              .            .                  .                .                .                  .          .          .               return true;
         .              .            .                  .                .                .                  .          .          .           }
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           bool Triangles::intersects(const Eigen::Vector2d & p) const
       297 ( 0.00%)    66 ( 0.00%)  22 ( 0.00%)        33 ( 0.00%)       0                0                132 ( 0.00%) 0          0           {
    31,240 ( 0.00%)    66 ( 0.00%)  22 ( 0.00%)        99 ( 0.00%)       0                0              8,954 ( 0.00%) 0          0               for (const Triangle & t : triangles_)
    15,323 ( 0.00%)     0            0              4,378 ( 0.00%)       0                0              2,189 ( 0.00%) 0          0                   if (t.intersects(p))
         .              .            .                  .                .                .                  .          .          .                       return true;
         .              .            .                  .                .                .                  .          .          .           
        33 ( 0.00%)     0            0                  0                0                0                  0          0          0               return false;
       165 ( 0.00%)     0            0                132 ( 0.00%)       0                0                  0          0          0           }
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           bool Triangles::intersects(const BoundingBox & bb) const
         .              .            .                  .                .                .                  .          .          .           {
         .              .            .                  .                .                .                  .          .          .               for (const Triangle & t : triangles_)
         .              .            .                  .                .                .                  .          .          .                   if (t.intersects(bb))
         .              .            .                  .                .                .                  .          .          .                       return true;
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .               return false;
-- line 161 ----------------------------------------
-- line 173 ----------------------------------------
         .              .            .                  .                .                .                  .          .          .           {
         .              .            .                  .                .                .                  .          .          .               BoundingBox bb;
         .              .            .                  .                .                .                  .          .          .               for (const Triangle & t : triangles_)
         .              .            .                  .                .                .                  .          .          .                   bb.unite(t.boundingBox());
         .              .            .                  .                .                .                  .          .          .               return bb;
         .              .            .                  .                .                .                  .          .          .           }
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           void Triangles::draw() const
    28,878 ( 0.00%) 1,429 ( 0.00%) 866 ( 0.01%)         0                0                0             14,439 ( 0.00%) 0          0           {
     9,626 ( 0.00%)     0            0                  0                0                0              4,813 ( 0.00%) 0          0               glBegin(GL_TRIANGLES);
11,235,238 ( 0.09%)   867 ( 0.00%) 433 ( 0.00%) 3,738,662 ( 0.11%)       0                0          1,252,638 ( 0.04%) 0          0               for (unsigned int i=0; i<triangles_.size(); ++i)
         .              .            .                  .                .                .                  .          .          .               {
27,346,264 ( 0.21%)   910 ( 0.00%) 433 ( 0.00%) 8,701,084 ( 0.26%) 313,073 ( 0.13%) 311,615 ( 0.14%) 7,458,072 ( 0.26%) 0          0                   glVertex2d(triangles_[i].a[0], triangles_[i].a[1]);
29,832,288 ( 0.23%) 1,601 ( 0.00%) 866 ( 0.01%) 8,701,084 ( 0.26%) 309,809 ( 0.12%) 308,413 ( 0.14%) 7,458,072 ( 0.26%) 0          0                   glVertex2d(triangles_[i].b[0], triangles_[i].b[1]);
29,832,288 ( 0.23%)   783 ( 0.00%) 433 ( 0.00%) 8,701,084 ( 0.26%) 310,580 ( 0.12%) 309,173 ( 0.14%) 7,458,072 ( 0.26%) 0          0                   glVertex2d(triangles_[i].c[0], triangles_[i].c[1]);
         .              .            .                  .                .                .                  .          .          .               }
     4,813 ( 0.00%)     0            0                  0                0                0              4,813 ( 0.00%) 0          0               glEnd();
    19,252 ( 0.00%)     0            0             14,439 ( 0.00%)     468 ( 0.00%)       0                  0          0          0           }
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .           void Triangles::draw3D(Time t, View3DSettings & viewSettings) const
         .              .            .                  .                .                .                  .          .          .           {
         .              .            .                  .                .                .                  .          .          .               const double z = viewSettings.zFromT(t);
         .              .            .                  .                .                .                  .          .          .           
         .              .            .                  .                .                .                  .          .          .               glBegin (GL_TRIANGLES);
         .              .            .                  .                .                .                  .          .          .               for (unsigned int i=0; i<triangles_.size(); ++i)
         .              .            .                  .                .                .                  .          .          .               {
-- line 198 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseStorage.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                  D1mr            DLmr            Dw                  D1mw            DLmw            

-- line 21 ----------------------------------------
         .               .              .                   .               .               .                   .               .               .           namespace Eigen {
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           namespace internal {
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           struct constructor_without_unaligned_array_assert {};
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           template<typename T, int Size>
         .               .              .                   .               .               .                   .               .               .           EIGEN_DEVICE_FUNC
   757,425 ( 0.01%)  4,352 ( 0.01%) 1,385 ( 0.01%)          0               0               0             252,475 ( 0.01%)      0               0           void check_static_allocation_size()
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .             // if EIGEN_STACK_ALLOCATION_LIMIT is defined to 0, then no limit
         .               .              .                   .               .               .                   .               .               .             #if EIGEN_STACK_ALLOCATION_LIMIT
         .               .              .                   .               .               .                   .               .               .             EIGEN_STATIC_ASSERT(Size * sizeof(T) <= EIGEN_STACK_ALLOCATION_LIMIT, OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG);
         .               .              .                   .               .               .                   .               .               .             #endif
   757,425 ( 0.01%)  2,103 ( 0.00%)   489 ( 0.00%)    504,950 ( 0.01%)      0               0                   0               0               0           }
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           /** \internal
         .               .              .                   .               .               .                   .               .               .             * Static array. If the MatrixOrArrayOptions require auto-alignment, the array will be automatically aligned:
         .               .              .                   .               .               .                   .               .               .             * to 16 bytes boundary if the total size is a multiple of 16 bytes.
         .               .              .                   .               .               .                   .               .               .             */
         .               .              .                   .               .               .                   .               .               .           template <typename T, int Size, int MatrixOrArrayOptions,
         .               .              .                   .               .               .                   .               .               .                     int Alignment = (MatrixOrArrayOptions&DontAlign) ? 0
         .               .              .                   .               .               .                   .               .               .                                   : compute_default_alignment<T,Size>::value >
         .               .              .                   .               .               .                   .               .               .           struct plain_array
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .             T array[Size];
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .             EIGEN_DEVICE_FUNC
   126,160 ( 0.00%)  9,847 ( 0.02%)   461 ( 0.00%)          0               0               0              50,464 ( 0.00%)      0               0             plain_array()
         .               .              .                   .               .               .                   .               .               .             { 
    25,232 ( 0.00%)      0              0                   0               0               0              25,232 ( 0.00%)      4 ( 0.00%)      1 ( 0.00%)      check_static_allocation_size<T,Size>();
    75,696 ( 0.00%)      0              0              50,464 ( 0.00%)      0               0                   0               0               0             }
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .             EIGEN_DEVICE_FUNC
         .               .              .                   .               .               .                   .               .               .             plain_array(constructor_without_unaligned_array_assert)
         .               .              .                   .               .               .                   .               .               .             { 
         .               .              .                   .               .               .                   .               .               .               check_static_allocation_size<T,Size>();
         .               .              .                   .               .               .                   .               .               .             }
         .               .              .                   .               .               .                   .               .               .           };
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           #if defined(EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT)
         .               .              .                   .               .               .                   .               .               .             #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask)
         .               .              .                   .               .               .                   .               .               .           #elif EIGEN_GNUC_AT_LEAST(4,7) 
         .               .              .                   .               .               .                   .               .               .             // GCC 4.7 is too aggressive in its optimizations and remove the alignement test based on the fact the array is declared to be aligned.
         .               .              .                   .               .               .                   .               .               .             // See this bug report: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53900
         .               .              .                   .               .               .                   .               .               .             // Hiding the origin of the array pointer behind a function argument seems to do the trick even if the function is inlined:
         .               .              .                   .               .               .                   .               .               .             template<typename PtrType>
   227,243 ( 0.00%)  2,049 ( 0.00%)   834 ( 0.01%)    227,243 ( 0.01%)      0               0                   0               0               0             EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }
         .               .              .                   .               .               .                   .               .               .             #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
         .               .              .                   .               .               .                   .               .               .               eigen_assert((internal::UIntPtr(eigen_unaligned_array_assert_workaround_gcc47(array)) & (sizemask)) == 0 \
         .               .              .                   .               .               .                   .               .               .                         && "this assertion is explained here: " \
         .               .              .                   .               .               .                   .               .               .                         "http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html" \
         .               .              .                   .               .               .                   .               .               .                         " **** READ THIS WEB PAGE !!! ****");
         .               .              .                   .               .               .                   .               .               .           #else
         .               .              .                   .               .               .                   .               .               .             #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
         .               .              .                   .               .               .                   .               .               .               eigen_assert((internal::UIntPtr(array) & (sizemask)) == 0 \
-- line 76 ----------------------------------------
-- line 99 ----------------------------------------
         .               .              .                   .               .               .                   .               .               .           };
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           template <typename T, int Size, int MatrixOrArrayOptions>
         .               .              .                   .               .               .                   .               .               .           struct plain_array<T, Size, MatrixOrArrayOptions, 16>
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .             EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .             EIGEN_DEVICE_FUNC
 1,136,215 ( 0.01%)  4,245 ( 0.01%) 1,385 ( 0.01%)          0               0               0             454,486 ( 0.02%)      1 ( 0.00%)      0             plain_array() 
         .               .              .                   .               .               .                   .               .               .             { 
 1,136,215 ( 0.01%)      0              0             227,243 ( 0.01%)      0               0             227,243 ( 0.01%)      0               0               EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(15);
   227,243 ( 0.00%)  2,527 ( 0.00%) 1,348 ( 0.01%)          0               0               0             227,243 ( 0.01%)    164 ( 0.00%)     18 ( 0.00%)      check_static_allocation_size<T,Size>();
   681,729 ( 0.01%)      0              0             454,486 ( 0.01%)      0               0                   0               0               0             }
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .             EIGEN_DEVICE_FUNC
         .               .              .                   .               .               .                   .               .               .             plain_array(constructor_without_unaligned_array_assert) 
         .               .              .                   .               .               .                   .               .               .             { 
         .               .              .                   .               .               .                   .               .               .               check_static_allocation_size<T,Size>();
         .               .              .                   .               .               .                   .               .               .             }
         .               .              .                   .               .               .                   .               .               .           };
         .               .              .                   .               .               .                   .               .               .           
-- line 119 ----------------------------------------
-- line 179 ----------------------------------------
         .               .              .                   .               .               .                   .               .               .             */
         .               .              .                   .               .               .                   .               .               .           template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage;
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           // purely fixed-size matrix
         .               .              .                   .               .               .                   .               .               .           template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .               internal::plain_array<T,Size,_Options> m_data;
         .               .              .                   .               .               .                   .               .               .             public:
 2,019,800 ( 0.02%)  2,083 ( 0.00%)   484 ( 0.00%)    252,475 ( 0.01%)      0               0             757,425 ( 0.03%)      0               0               EIGEN_DEVICE_FUNC DenseStorage() {
         .               .              .                   .               .               .                   .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
   757,425 ( 0.01%)      0              0             504,950 ( 0.01%)      0               0                   0               0               0               }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC
         .               .              .                   .               .               .                   .               .               .               explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
         .               .              .                   .               .               .                   .               .               .                 : m_data(internal::constructor_without_unaligned_array_assert()) {}
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC 
17,562,300 ( 0.14%) 10,783 ( 0.02%)   641 ( 0.01%)  6,730,698 ( 0.20%) 22,926 ( 0.01%) 13,842 ( 0.01%)  8,097,666 ( 0.28%) 36,269 ( 0.01%) 27,254 ( 0.01%)      DenseStorage(const DenseStorage& other) : m_data(other.m_data) {
         .               .              .                   .               .               .                   .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
 4,100,904 ( 0.03%)      0              0           2,733,936 ( 0.08%)      0               0                   0               0               0               }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC 
         .               .              .                   .               .               .                   .               .               .               DenseStorage& operator=(const DenseStorage& other)
         .               .              .                   .               .               .                   .               .               .               { 
         .               .              .                   .               .               .                   .               .               .                 if (this != &other) m_data = other.m_data;
         .               .              .                   .               .               .                   .               .               .                 return *this; 
         .               .              .                   .               .               .                   .               .               .               }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {
         .               .              .                   .               .               .                   .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .               .              .                   .               .               .                   .               .               .                 eigen_internal_assert(size==rows*cols && rows==_Rows && cols==_Cols);
         .               .              .                   .               .               .                   .               .               .                 EIGEN_UNUSED_VARIABLE(size);
         .               .              .                   .               .               .                   .               .               .                 EIGEN_UNUSED_VARIABLE(rows);
         .               .              .                   .               .               .                   .               .               .                 EIGEN_UNUSED_VARIABLE(cols);
         .               .              .                   .               .               .                   .               .               .               }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }
83,380,506 ( 0.65%)  2,212 ( 0.00%)   945 ( 0.01%) 27,793,502 ( 0.82%)      0               0          13,896,751 ( 0.49%)      0               0               EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
83,105,388 ( 0.64%) 10,623 ( 0.02%)   906 ( 0.01%) 27,701,796 ( 0.82%)      0               0          13,850,898 ( 0.49%)      0               0               EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}
   914,660 ( 0.01%)    739 ( 0.00%)   436 ( 0.00%)    182,932 ( 0.01%)      0               0             457,330 ( 0.02%)      8 ( 0.00%)      0               EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}
91,675,745 ( 0.71%)  8,955 ( 0.01%) 2,245 ( 0.02%) 39,289,605 ( 1.16%)      0               0          26,193,070 ( 0.92%)      0               0               EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
 1,578,619 ( 0.01%)  1,908 ( 0.00%)   933 ( 0.01%)    676,551 ( 0.02%)      0               0             451,034 ( 0.02%)      0               0               EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
         .               .              .                   .               .               .                   .               .               .           };
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           // null matrix
         .               .              .                   .               .               .                   .               .               .           template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .             public:
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC DenseStorage() {}
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) {}
-- line 224 ----------------------------------------
-- line 336 ----------------------------------------
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           // purely dynamic matrix.
         .               .              .                   .               .               .                   .               .               .           template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .               T *m_data;
         .               .              .                   .               .               .                   .               .               .               Index m_rows;
         .               .              .                   .               .               .                   .               .               .               Index m_cols;
         .               .              .                   .               .               .                   .               .               .             public:
    12,285 ( 0.00%)    378 ( 0.00%)   189 ( 0.00%)      4,725 ( 0.00%)      0               0               4,725 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
         .               .              .                   .               .               .                   .               .               .                  : m_data(0), m_rows(0), m_cols(0) {}
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols)
         .               .              .                   .               .               .                   .               .               .                 : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows), m_cols(cols)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .               .              .                   .               .               .                   .               .               .                 eigen_internal_assert(size==rows*cols && rows>=0 && cols >=0);
         .               .              .                   .               .               .                   .               .               .               }
     1,134 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0               0               0                 567 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
     1,701 ( 0.00%)      0              0                 945 ( 0.00%)      0               0                 378 ( 0.00%)      0               0                 : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*other.m_cols))
       756 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)        567 ( 0.00%)      0               0                 189 ( 0.00%)      0               0                 , m_rows(other.m_rows)
       756 ( 0.00%)      0              0                 567 ( 0.00%)      0               0                 189 ( 0.00%)      0               0                 , m_cols(other.m_cols)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*m_cols)
     3,024 ( 0.00%)    189 ( 0.00%)     0               1,890 ( 0.00%)      0               0                 189 ( 0.00%)      0               0                 internal::smart_copy(other.m_data, other.m_data+other.m_rows*other.m_cols, m_data);
       567 ( 0.00%)      0              0                 378 ( 0.00%)      0               0                   0               0               0               }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 if (this != &other)
         .               .              .                   .               .               .                   .               .               .                 {
         .               .              .                   .               .               .                   .               .               .                   DenseStorage tmp(other);
         .               .              .                   .               .               .                   .               .               .                   this->swap(tmp);
         .               .              .                   .               .               .                   .               .               .                 }
         .               .              .                   .               .               .                   .               .               .                 return *this;
-- line 368 ----------------------------------------
-- line 383 ----------------------------------------
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 using std::swap;
         .               .              .                   .               .               .                   .               .               .                 swap(m_data, other.m_data);
         .               .              .                   .               .               .                   .               .               .                 swap(m_rows, other.m_rows);
         .               .              .                   .               .               .                   .               .               .                 swap(m_cols, other.m_cols);
         .               .              .                   .               .               .                   .               .               .                 return *this;
         .               .              .                   .               .               .                   .               .               .               }
         .               .              .                   .               .               .                   .               .               .           #endif
    21,546 ( 0.00%)    417 ( 0.00%)     0               9,072 ( 0.00%)      0               0               3,402 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC void swap(DenseStorage& other)
         .               .              .                   .               .               .                   .               .               .               { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
   363,880 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)    181,940 ( 0.01%)      0               0              90,970 ( 0.00%)     50 ( 0.00%)      0               EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
   215,832 ( 0.00%)    189 ( 0.00%)     0             107,916 ( 0.00%)      0               0              53,958 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
         .               .              .                   .               .               .                   .               .               .               void conservativeResize(Index size, Index rows, Index cols)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*m_cols);
         .               .              .                   .               .               .                   .               .               .                 m_rows = rows;
         .               .              .                   .               .               .                   .               .               .                 m_cols = cols;
         .               .              .                   .               .               .                   .               .               .               }
     8,960 ( 0.00%)    378 ( 0.00%)   189 ( 0.00%)          0               0               0               5,600 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC void resize(Index size, Index rows, Index cols)
         .               .              .                   .               .               .                   .               .               .               {
     7,840 ( 0.00%)    378 ( 0.00%)   189 ( 0.00%)      5,600 ( 0.00%)      0               0                   0               0               0                 if(size != m_rows*m_cols)
         .               .              .                   .               .               .                   .               .               .                 {
    12,320 ( 0.00%)      0              0               6,720 ( 0.00%)      0               0               1,120 ( 0.00%)      0               0                   internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols);
     2,240 ( 0.00%)    517 ( 0.00%)   189 ( 0.00%)      1,120 ( 0.00%)      0               0                   0               0               0                   if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative
     6,720 ( 0.00%)      0              0               2,240 ( 0.00%)      0               0               2,240 ( 0.00%)      0               0                     m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
         .               .              .                   .               .               .                   .               .               .                   else
         .               .              .                   .               .               .                   .               .               .                     m_data = 0;
         .               .              .                   .               .               .                   .               .               .                   EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .               .              .                   .               .               .                   .               .               .                 }
     3,360 ( 0.00%)      0              0               2,240 ( 0.00%)      0               0               1,120 ( 0.00%)      0               0                 m_rows = rows;
     3,360 ( 0.00%)      0              0               2,240 ( 0.00%)      0               0               1,120 ( 0.00%)      0               0                 m_cols = cols;
     3,360 ( 0.00%)    517 ( 0.00%)   189 ( 0.00%)      2,240 ( 0.00%)      0               0                   0               0               0               }
   118,440 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     59,220 ( 0.00%)      0               0              29,610 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC const T *data() const { return m_data; }
    13,208 ( 0.00%)    328 ( 0.00%)   189 ( 0.00%)      6,604 ( 0.00%)      0               0               3,302 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC T *data() { return m_data; }
         .               .              .                   .               .               .                   .               .               .           };
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           // matrix with dynamic width and fixed height (so that matrix has dynamic size).
         .               .              .                   .               .               .                   .               .               .           template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .               T *m_data;
         .               .              .                   .               .               .                   .               .               .               Index m_cols;
         .               .              .                   .               .               .                   .               .               .             public:
-- line 425 ----------------------------------------
-- line 492 ----------------------------------------
         .               .              .                   .               .               .                   .               .               .           };
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           // matrix with dynamic height and fixed width (so that matrix has dynamic size).
         .               .              .                   .               .               .                   .               .               .           template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>
         .               .              .                   .               .               .                   .               .               .           {
         .               .              .                   .               .               .                   .               .               .               T *m_data;
         .               .              .                   .               .               .                   .               .               .               Index m_rows;
         .               .              .                   .               .               .                   .               .               .             public:
     8,316 ( 0.00%)    478 ( 0.00%)   428 ( 0.00%)      3,024 ( 0.00%)      0               0               3,024 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0) {}
         .               .              .                   .               .               .                   .               .               .               explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .               .              .                   .               .               .                   .               .               .                 eigen_internal_assert(size==rows*cols && rows>=0 && cols == _Cols);
         .               .              .                   .               .               .                   .               .               .                 EIGEN_UNUSED_VARIABLE(cols);
         .               .              .                   .               .               .                   .               .               .               }
     2,268 ( 0.00%)      0              0                   0               0               0               1,134 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
     2,268 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)      1,134 ( 0.00%)      0               0                 756 ( 0.00%)      0               0                 : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(other.m_rows*_Cols))
     1,512 ( 0.00%)      0              0               1,134 ( 0.00%)      0               0                 378 ( 0.00%)      0               0                 , m_rows(other.m_rows)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*_Cols)
     4,914 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)      3,024 ( 0.00%)      0               0                 378 ( 0.00%)      0               0                 internal::smart_copy(other.m_data, other.m_data+other.m_rows*_Cols, m_data);
     1,134 ( 0.00%)      0              0                 756 ( 0.00%)      0               0                   0               0               0               }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 if (this != &other)
         .               .              .                   .               .               .                   .               .               .                 {
         .               .              .                   .               .               .                   .               .               .                   DenseStorage tmp(other);
         .               .              .                   .               .               .                   .               .               .                   this->swap(tmp);
         .               .              .                   .               .               .                   .               .               .                 }
         .               .              .                   .               .               .                   .               .               .                 return *this;
-- line 522 ----------------------------------------
-- line 534 ----------------------------------------
         .               .              .                   .               .               .                   .               .               .               DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 using std::swap;
         .               .              .                   .               .               .                   .               .               .                 swap(m_data, other.m_data);
         .               .              .                   .               .               .                   .               .               .                 swap(m_rows, other.m_rows);
         .               .              .                   .               .               .                   .               .               .                 return *this;
         .               .              .                   .               .               .                   .               .               .               }
         .               .              .                   .               .               .                   .               .               .           #endif
    18,144 ( 0.00%)    189 ( 0.00%)     0               6,804 ( 0.00%)      0               0               3,402 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }
         .               .              .                   .               .               .                   .               .               .               EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
    56,272 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)     28,136 ( 0.00%)      0               0              14,068 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
    45,606 ( 0.00%)      0              0              15,202 ( 0.00%)      0               0               7,601 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
         .               .              .                   .               .               .                   .               .               .               void conservativeResize(Index size, Index rows, Index)
         .               .              .                   .               .               .                   .               .               .               {
         .               .              .                   .               .               .                   .               .               .                 m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*_Cols);
         .               .              .                   .               .               .                   .               .               .                 m_rows = rows;
         .               .              .                   .               .               .                   .               .               .               }
     9,072 ( 0.00%)     83 ( 0.00%)    50 ( 0.00%)          0               0               0               5,670 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index rows, Index)
         .               .              .                   .               .               .                   .               .               .               {
     4,536 ( 0.00%)      0              0               3,402 ( 0.00%)      0               0                   0               0               0                 if(size != m_rows*_Cols)
         .               .              .                   .               .               .                   .               .               .                 {
     6,048 ( 0.00%)    567 ( 0.00%)   378 ( 0.00%)      3,024 ( 0.00%)      0               0                 756 ( 0.00%)      0               0                   internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows);
     1,512 ( 0.00%)      0              0                 756 ( 0.00%)      0               0                   0               0               0                   if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative
     4,536 ( 0.00%)      0              0               1,512 ( 0.00%)      0               0               1,512 ( 0.00%)      0               0                     m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
         .               .              .                   .               .               .                   .               .               .                   else
         .               .              .                   .               .               .                   .               .               .                     m_data = 0;
         .               .              .                   .               .               .                   .               .               .                   EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
         .               .              .                   .               .               .                   .               .               .                 }
     3,402 ( 0.00%)    189 ( 0.00%)     0               2,268 ( 0.00%)      0               0               1,134 ( 0.00%)      0               0                 m_rows = rows;
     3,402 ( 0.00%)    378 ( 0.00%)   189 ( 0.00%)      2,268 ( 0.00%)      0               0                   0               0               0               }
    41,152 ( 0.00%)      0              0              20,576 ( 0.00%)      0               0              10,288 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC const T *data() const { return m_data; }
    24,192 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)     12,096 ( 0.00%)      0               0               6,048 ( 0.00%)      0               0               EIGEN_DEVICE_FUNC T *data() { return m_data; }
         .               .              .                   .               .               .                   .               .               .           };
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           } // end namespace Eigen
         .               .              .                   .               .               .                   .               .               .           
         .               .              .                   .               .               .                   .               .               .           #endif // EIGEN_MATRIX_H

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/CoreEvaluators.h
--------------------------------------------------------------------------------
Ir                   I1mr             ILmr           Dr                  D1mr         DLmr         Dw                  D1mw           DLmw        

-- line 82 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename T, typename Shape = typename evaluator_traits<T>::Shape >
          .                .              .                   .            .            .                   .              .           .           struct evaluator_assume_aliasing {
          .                .              .                   .            .            .                   .              .           .             static const bool value = false;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // By default, we assume a unary expression:
          .                .              .                   .            .            .                   .              .           .           template<typename T>
    444,587 ( 0.00%)   1,919 ( 0.00%) 1,348 ( 0.01%)    121,251 ( 0.00%)   0            0             121,251 ( 0.00%)     0           0           struct evaluator : public unary_evaluator<T>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef unary_evaluator<T> Base;
    565,838 ( 0.00%)   3,805 ( 0.01%) 2,569 ( 0.02%)    161,668 ( 0.00%)   0            0             161,668 ( 0.01%)    21 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit evaluator(const T& xpr) : Base(xpr) {}
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // TODO: Think about const-correctness
          .                .              .                   .            .            .                   .              .           .           template<typename T>
  9,109,837 ( 0.07%)  52,651 ( 0.09%) 4,448 ( 0.04%)  2,484,501 ( 0.07%)   0            0           2,484,501 ( 0.09%)     0           0           struct evaluator<const T>
          .                .              .                   .            .            .                   .              .           .             : evaluator<T>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC
 11,594,338 ( 0.09%)  42,377 ( 0.07%) 6,849 ( 0.07%)  3,312,668 ( 0.10%)   0            0           3,312,668 ( 0.12%)     0           0             explicit evaluator(const T& xpr) : evaluator<T>(xpr) {}
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // ---------- base class for all evaluators ----------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename ExpressionType>
303,270,286 ( 2.35%)  71,446 ( 0.12%) 7,032 ( 0.07%) 82,710,078 ( 2.45%)   0            0          82,710,078 ( 2.91%) 1,331 ( 0.00%) 31 ( 0.00%)  struct evaluator_base : public noncopyable
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             // TODO that's not very nice to have to propagate all these traits. They are currently only needed to handle outer,inner indices.
          .                .              .                   .            .            .                   .              .           .             typedef traits<ExpressionType> ExpressionTraits;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               Alignment = 0
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           };
-- line 117 ----------------------------------------
-- line 119 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .           // -------------------- Matrix and Array --------------------
          .                .              .                   .            .            .                   .              .           .           //
          .                .              .                   .            .            .                   .              .           .           // evaluator<PlainObjectBase> is a common base class for the
          .                .              .                   .            .            .                   .              .           .           // Matrix and Array evaluators.
          .                .              .                   .            .            .                   .              .           .           // Here we directly specialize evaluator. This is not really a unary expression, and it is, by definition, dense,
          .                .              .                   .            .            .                   .              .           .           // so no need for more sophisticated dispatching.
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename Derived>
144,217,975 ( 1.12%)   2,082 ( 0.00%)   491 ( 0.00%) 39,332,175 ( 1.16%)   0            0          39,332,175 ( 1.38%)     0           0           struct evaluator<PlainObjectBase<Derived> >
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<Derived>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef PlainObjectBase<Derived> PlainObjectType;
          .                .              .                   .            .            .                   .              .           .             typedef typename PlainObjectType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .             typedef typename PlainObjectType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               IsRowMajor = PlainObjectType::IsRowMajor,
-- line 135 ----------------------------------------
-- line 146 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .               : m_data(0),
          .                .              .                   .            .            .                   .              .           .                 m_outerStride(IsVectorAtCompileTime  ? 0 
          .                .              .                   .            .            .                   .              .           .                                                      : int(IsRowMajor) ? ColsAtCompileTime 
          .                .              .                   .            .            .                   .              .           .                                                      : RowsAtCompileTime)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .             
 91,775,075 ( 0.71%)  17,585 ( 0.03%) 3,534 ( 0.03%)          0            0            0          52,442,900 ( 1.84%)   225 ( 0.00%)  9 ( 0.00%)    EIGEN_DEVICE_FUNC explicit evaluator(const PlainObjectType& m)
170,584,274 ( 1.32%)   6,152 ( 0.01%) 2,188 ( 0.02%) 52,491,183 ( 1.55%)   0            0          52,491,183 ( 1.85%)   450 ( 0.00%)  8 ( 0.00%)      : m_data(m.data()), m_outerStride(IsVectorAtCompileTime ? 0 : m.outerStride()) 
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
 52,442,900 ( 0.41%)   1,950 ( 0.00%)   265 ( 0.00%) 39,332,175 ( 1.16%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    438,824 ( 0.00%)   2,376 ( 0.00%)   898 ( 0.01%)          0            0            0             274,265 ( 0.01%)     1 ( 0.00%)  0             CoeffReturnType coeff(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               if (IsRowMajor)
          .                .              .                   .            .            .                   .              .           .                 return m_data[row * m_outerStride.value() + col];
          .                .              .                   .            .            .                   .              .           .               else
    501,837 ( 0.00%)       0              0             222,132 ( 0.01%)   0            0              54,853 ( 0.00%)     3 ( 0.00%)  0                 return m_data[row + col * m_outerStride.value()];
    164,559 ( 0.00%)       0              0             164,559 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 59,121,120 ( 0.46%)       0              0                   0            0            0          35,472,672 ( 1.25%)     0           0             CoeffReturnType coeff(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
 59,121,120 ( 0.46%)   1,569 ( 0.00%)   457 ( 0.00%) 35,472,672 ( 1.05%)   0            0                   0              0           0               return m_data[index];
 23,648,448 ( 0.18%)       0              0          23,648,448 ( 0.70%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
  2,880,208 ( 0.02%)  13,182 ( 0.02%)   959 ( 0.01%)          0            0            0           1,800,130 ( 0.06%)     0           0             Scalar& coeffRef(Index row, Index col)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               if (IsRowMajor)
          .                .              .                   .            .            .                   .              .           .                 return const_cast<Scalar*>(m_data)[row * m_outerStride.value() + col];
          .                .              .                   .            .            .                   .              .           .               else
  3,274,650 ( 0.03%)     874 ( 0.00%)   452 ( 0.00%)  1,451,576 ( 0.04%)   0            0             360,026 ( 0.01%)     0           0                 return const_cast<Scalar*>(m_data)[row + col * m_outerStride.value()];
  1,080,078 ( 0.01%)       0              0           1,080,078 ( 0.03%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
  3,018,500 ( 0.02%)     517 ( 0.00%)   378 ( 0.00%)          0            0            0           1,811,100 ( 0.06%)     0           0             Scalar& coeffRef(Index index)
          .                .              .                   .            .            .                   .              .           .             {
  3,018,500 ( 0.02%)     278 ( 0.00%)   139 ( 0.00%)  1,811,100 ( 0.05%)   0            0                   0              0           0               return const_cast<Scalar*>(m_data)[index];
  1,207,400 ( 0.01%)       0              0           1,207,400 ( 0.04%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
  4,975,952 ( 0.04%)   4,333 ( 0.01%) 1,039 ( 0.01%)          0            0            0           3,109,970 ( 0.11%)   450 ( 0.00%) 17 ( 0.00%)    PacketType packet(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               if (IsRowMajor)
          .                .              .                   .            .            .                   .              .           .                 return ploadt<PacketType, LoadMode>(m_data + row * m_outerStride.value() + col);
          .                .              .                   .            .            .                   .              .           .               else
  6,850,094 ( 0.05%)   5,173 ( 0.01%) 1,299 ( 0.01%)  2,490,696 ( 0.07%)   0            0           1,243,988 ( 0.04%)   100 ( 0.00%)  1 ( 0.00%)        return ploadt<PacketType, LoadMode>(m_data + row + col * m_outerStride.value());
  1,865,982 ( 0.01%)       0              0           1,865,982 ( 0.06%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     48,120 ( 0.00%)     100 ( 0.00%)    50 ( 0.00%)          0            0            0              24,060 ( 0.00%)     0           0             PacketType packet(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
     48,120 ( 0.00%)       0              0              24,060 ( 0.00%)   0            0               8,020 ( 0.00%)     0           0               return ploadt<PacketType, LoadMode>(m_data + index);
     16,040 ( 0.00%)       0              0              16,040 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int StoreMode,typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
    876,924 ( 0.01%)  39,494 ( 0.06%) 1,009 ( 0.01%)          0            0            0             584,616 ( 0.02%)     0           0             void writePacket(Index row, Index col, const PacketType& x)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               if (IsRowMajor)
          .                .              .                   .            .            .                   .              .           .                 return pstoret<Scalar, PacketType, StoreMode>
          .                .              .                   .            .            .                   .              .           .           	            (const_cast<Scalar*>(m_data) + row * m_outerStride.value() + col, x);
          .                .              .                   .            .            .                   .              .           .               else
          .                .              .                   .            .            .                   .              .           .                 return pstoret<Scalar, PacketType, StoreMode>
  1,266,668 ( 0.01%)  21,708 ( 0.04%)   620 ( 0.01%)    487,180 ( 0.01%)   0            0             292,308 ( 0.01%)     0           0                               (const_cast<Scalar*>(m_data) + row + col * m_outerStride.value(), x);
    292,308 ( 0.00%)       0              0             292,308 ( 0.01%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int StoreMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             void writePacket(Index index, const PacketType& x)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return pstoret<Scalar, PacketType, StoreMode>(const_cast<Scalar*>(m_data) + index, x);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
-- line 225 ----------------------------------------
-- line 228 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             // We do not need to know the outer stride for vectors
          .                .              .                   .            .            .                   .              .           .             variable_if_dynamic<Index, IsVectorAtCompileTime  ? 0 
          .                .              .                   .            .            .                   .              .           .                                                               : int(IsRowMajor) ? ColsAtCompileTime 
          .                .              .                   .            .            .                   .              .           .                                                               : RowsAtCompileTime> m_outerStride;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
144,217,975 ( 1.12%)  12,525 ( 0.02%) 1,863 ( 0.02%) 39,332,175 ( 1.16%)   0            0          39,332,175 ( 1.38%)     0           0           struct evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
          .                .              .                   .            .            .                   .              .           .             : evaluator<PlainObjectBase<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC evaluator() {}
          .                .              .                   .            .            .                   .              .           .           
 78,664,350 ( 0.61%)  14,889 ( 0.02%) 1,621 ( 0.02%)          0            0            0          39,332,175 ( 1.38%)    14 ( 0.00%)  1 ( 0.00%)    EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)
 65,553,625 ( 0.51%)       0              0          26,221,450 ( 0.78%)   0            0          13,110,725 ( 0.46%)    12 ( 0.00%)  8 ( 0.00%)      : evaluator<PlainObjectBase<XprType> >(m) 
 39,332,175 ( 0.31%)       0              0          26,221,450 ( 0.78%)   0            0                   0              0           0             { }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
          .                .              .                   .            .            .                   .              .           .           struct evaluator<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
          .                .              .                   .            .            .                   .              .           .             : evaluator<PlainObjectBase<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
          .                .              .                   .            .            .                   .              .           .           
-- line 253 ----------------------------------------
-- line 256 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)
          .                .              .                   .            .            .                   .              .           .               : evaluator<PlainObjectBase<XprType> >(m) 
          .                .              .                   .            .            .                   .              .           .             { }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- Transpose --------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename ArgType>
     26,850 ( 0.00%)     940 ( 0.00%)   898 ( 0.01%)      7,160 ( 0.00%)   0            0               7,160 ( 0.00%)     0           0           struct unary_evaluator<Transpose<ArgType>, IndexBased>
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<Transpose<ArgType> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Transpose<ArgType> XprType;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               CoeffReadCost = evaluator<ArgType>::CoeffReadCost,    
          .                .              .                   .            .            .                   .              .           .               Flags = evaluator<ArgType>::Flags ^ RowMajorBit,
          .                .              .                   .            .            .                   .              .           .               Alignment = evaluator<ArgType>::Alignment
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           
     39,380 ( 0.00%)   2,525 ( 0.00%) 2,320 ( 0.02%)     10,740 ( 0.00%)   0            0              12,530 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression()) {}
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     28,385 ( 0.00%)      50 ( 0.00%)     0                   0            0            0              16,220 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
     29,720 ( 0.00%)       0              0              12,165 ( 0.00%)   0            0               4,055 ( 0.00%)     0           0               return m_argImpl.coeff(col, row);
      9,445 ( 0.00%)       0              0               8,110 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             CoeffReturnType coeff(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.coeff(index);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             Scalar& coeffRef(Index row, Index col)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.coeffRef(col, row);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      8,010 ( 0.00%)       0              0                   0            0            0               4,005 ( 0.00%)     0           0             typename XprType::Scalar& coeffRef(Index index)
          .                .              .                   .            .            .                   .              .           .             {
      8,010 ( 0.00%)       0              0               2,670 ( 0.00%)   0            0               1,335 ( 0.00%)     0           0               return m_argImpl.coeffRef(index);
      2,670 ( 0.00%)       0              0               2,670 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             PacketType packet(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.template packet<LoadMode,PacketType>(col, row);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     16,320 ( 0.00%)       0              0                   0            0            0               8,160 ( 0.00%)     0           0             PacketType packet(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
     16,320 ( 0.00%)       0              0               5,440 ( 0.00%)   0            0               2,720 ( 0.00%)     0           0               return m_argImpl.template packet<LoadMode,PacketType>(index);
      5,440 ( 0.00%)       0              0               5,440 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int StoreMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             void writePacket(Index row, Index col, const PacketType& x)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               m_argImpl.template writePacket<StoreMode,PacketType>(col, row, x);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
-- line 324 ----------------------------------------
-- line 351 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j) const { return op.template packetOp<T>(i,j); }
          .                .              .                   .            .            .                   .              .           .             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const { return op.template packetOp<T>(i); }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename Scalar,typename NullaryOp>
          .                .              .                   .            .            .                   .              .           .           struct nullary_wrapper<Scalar,NullaryOp,true,false,false>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             template <typename IndexType>
    471,225 ( 0.00%)  11,199 ( 0.02%)   466 ( 0.00%)     94,245 ( 0.00%)   0            0             188,490 ( 0.01%)     2 ( 0.00%)  2 ( 0.00%)    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType=0, IndexType=0) const { return op(); }
  2,976,233 ( 0.02%)  15,070 ( 0.02%)   101 ( 0.00%)    686,823 ( 0.02%)   0            0           1,373,646 ( 0.05%)     0           0             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType=0, IndexType=0) const { return op.template packetOp<T>(); }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename Scalar,typename NullaryOp>
          .                .              .                   .            .            .                   .              .           .           struct nullary_wrapper<Scalar,NullaryOp,false,false,true>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             template <typename IndexType>
     54,432 ( 0.00%)     378 ( 0.00%)   378 ( 0.00%)     15,120 ( 0.00%)   0            0              18,144 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j=0) const { return op(i,j); }
          .                .              .                   .            .            .                   .              .           .             template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j=0) const { return op.template packetOp<T>(i,j); }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // We need the following specialization for vector-only functors assigned to a runtime vector,
          .                .              .                   .            .            .                   .              .           .           // for instance, using linspace and assigning a RowVectorXd to a MatrixXd or even a row of a MatrixXd.
          .                .              .                   .            .            .                   .              .           .           // In this case, i==0 and j is used for the actual iteration.
          .                .              .                   .            .            .                   .              .           .           template<typename Scalar,typename NullaryOp>
          .                .              .                   .            .            .                   .              .           .           struct nullary_wrapper<Scalar,NullaryOp,false,true,false>
-- line 375 ----------------------------------------
-- line 447 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .               has_nullary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
          .                .              .                   .            .            .                   .              .           .               has_unary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value,
          .                .              .                   .            .            .                   .              .           .               has_binary_operator<NullaryOp,nullary_wrapper_workaround_msvc<IndexType> >::value>().template packetOp<T>(op,i);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           #endif // MSVC workaround
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename NullaryOp, typename PlainObjectType>
  2,462,702 ( 0.02%)  19,742 ( 0.03%) 1,142 ( 0.01%)    671,646 ( 0.02%)   0            0             671,646 ( 0.02%)     0           0           struct evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType> >
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<CwiseNullaryOp<NullaryOp,PlainObjectType> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef CwiseNullaryOp<NullaryOp,PlainObjectType> XprType;
          .                .              .                   .            .            .                   .              .           .             typedef typename internal::remove_all<PlainObjectType>::type PlainObjectTypeCleaned;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               CoeffReadCost = internal::functor_traits<NullaryOp>::Cost,
          .                .              .                   .            .            .                   .              .           .               
-- line 463 ----------------------------------------
-- line 464 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .               Flags = (evaluator<PlainObjectTypeCleaned>::Flags
          .                .              .                   .            .            .                   .              .           .                     &  (  HereditaryBits
          .                .              .                   .            .            .                   .              .           .                         | (functor_has_linear_access<NullaryOp>::ret  ? LinearAccessBit : 0)
          .                .              .                   .            .            .                   .              .           .                         | (functor_traits<NullaryOp>::PacketAccess    ? PacketAccessBit : 0)))
          .                .              .                   .            .            .                   .              .           .                     | (functor_traits<NullaryOp>::IsRepeatable ? 0 : EvalBeforeNestingBit),
          .                .              .                   .            .            .                   .              .           .               Alignment = AlignedMax
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           
  1,567,174 ( 0.01%)  44,134 ( 0.07%) 2,681 ( 0.03%)          0            0            0             895,528 ( 0.03%)   331 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& n)
  2,238,820 ( 0.02%)   4,342 ( 0.01%) 2,132 ( 0.02%)    671,646 ( 0.02%)   0            0             671,646 ( 0.02%)    33 ( 0.00%) 15 ( 0.00%)      : m_functor(n.functor()), m_wrapper()
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
    895,528 ( 0.01%)       0              0             671,646 ( 0.02%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template <typename IndexType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    184,478 ( 0.00%)     804 ( 0.00%)     0                   0            0            0             105,416 ( 0.00%)     0           0             CoeffReturnType coeff(IndexType row, IndexType col) const
          .                .              .                   .            .            .                   .              .           .             {
    210,832 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)    105,416 ( 0.00%)   0            0              26,354 ( 0.00%)     0           0               return m_wrapper(m_functor, row, col);
     79,062 ( 0.00%)       0              0              52,708 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template <typename IndexType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     48,510 ( 0.00%)   2,454 ( 0.00%) 1,573 ( 0.02%)          0            0            0              24,255 ( 0.00%)     0           0             CoeffReturnType coeff(IndexType index) const
          .                .              .                   .            .            .                   .              .           .             {
     64,680 ( 0.00%)   1,718 ( 0.00%)   605 ( 0.01%)     24,255 ( 0.00%)   0            0               8,085 ( 0.00%)     0           0               return m_wrapper(m_functor,index);
     24,255 ( 0.00%)     925 ( 0.00%)   884 ( 0.01%)     16,170 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType, typename IndexType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
  1,552,684 ( 0.01%)  21,653 ( 0.03%)   881 ( 0.01%)          0            0            0             887,248 ( 0.03%)     0           0             PacketType packet(IndexType row, IndexType col) const
          .                .              .                   .            .            .                   .              .           .             {
  1,552,684 ( 0.01%)  20,953 ( 0.03%)   695 ( 0.01%)    887,248 ( 0.03%)   0            0             221,812 ( 0.01%)     0           0               return m_wrapper.template packetOp<PacketType>(m_functor, row, col);
    443,624 ( 0.00%)       0              0             443,624 ( 0.01%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType, typename IndexType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     42,774 ( 0.00%)     795 ( 0.00%)   467 ( 0.00%)          0            0            0              21,387 ( 0.00%)     0           0             PacketType packet(IndexType index) const
          .                .              .                   .            .            .                   .              .           .             {
     49,903 ( 0.00%)       0              0              21,387 ( 0.00%)   0            0               7,129 ( 0.00%)     0           0               return m_wrapper.template packetOp<PacketType>(m_functor, index);
     14,258 ( 0.00%)       0              0              14,258 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           protected:
          .                .              .                   .            .            .                   .              .           .             const NullaryOp m_functor;
          .                .              .                   .            .            .                   .              .           .             const internal::nullary_wrapper<CoeffReturnType,NullaryOp> m_wrapper;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- CwiseUnaryOp --------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename UnaryOp, typename ArgType>
    579,405 ( 0.00%)  19,200 ( 0.03%) 1,049 ( 0.01%)    154,508 ( 0.00%)   0            0             154,508 ( 0.01%)     0           0           struct unary_evaluator<CwiseUnaryOp<UnaryOp, ArgType>, IndexBased >
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<CwiseUnaryOp<UnaryOp, ArgType> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,
          .                .              .                   .            .            .                   .              .           .               
          .                .              .                   .            .            .                   .              .           .               Flags = evaluator<ArgType>::Flags
          .                .              .                   .            .            .                   .              .           .                     & (HereditaryBits | LinearAccessBit | (functor_traits<UnaryOp>::PacketAccess ? PacketAccessBit : 0)),
          .                .              .                   .            .            .                   .              .           .               Alignment = evaluator<ArgType>::Alignment
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    270,389 ( 0.00%)   3,353 ( 0.01%) 1,069 ( 0.01%)          0            0            0             154,508 ( 0.01%)    16 ( 0.00%)  0             explicit unary_evaluator(const XprType& op)
    270,389 ( 0.00%)     634 ( 0.00%)   613 ( 0.01%)     77,254 ( 0.00%)   0            0              77,254 ( 0.00%)     0           0               : m_functor(op.functor()), 
    424,897 ( 0.00%)   2,139 ( 0.00%)   677 ( 0.01%)    115,881 ( 0.00%)   0            0             115,881 ( 0.00%)   408 ( 0.00%)  0                 m_argImpl(op.nestedExpression()) 
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<UnaryOp>::Cost);
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
    154,508 ( 0.00%)     634 ( 0.00%)   613 ( 0.01%)    115,881 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     25,800 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)          0            0            0              16,125 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
     38,700 ( 0.00%)       0              0              12,900 ( 0.00%)   0            0               6,450 ( 0.00%)     0           0               return m_functor(m_argImpl.coeff(row, col));
     12,900 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      9,675 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             CoeffReturnType coeff(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return m_functor(m_argImpl.coeff(index));
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
    413,160 ( 0.00%)  21,699 ( 0.04%) 1,106 ( 0.01%)     37,560 ( 0.00%)   0            0             225,360 ( 0.01%)     0           0             PacketType packet(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
    488,280 ( 0.00%)     264 ( 0.00%)    11 ( 0.00%)    150,240 ( 0.00%)   0            0             112,680 ( 0.00%)     0           0               return m_functor.packetOp(m_argImpl.template packet<LoadMode, PacketType>(row, col));
    225,360 ( 0.00%)     909 ( 0.00%)   220 ( 0.00%)    187,800 ( 0.01%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     15,120 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      1,512 ( 0.00%)   0            0               7,560 ( 0.00%)     0           0             PacketType packet(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
     18,144 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      4,536 ( 0.00%)   0            0               4,536 ( 0.00%)     0           0               return m_functor.packetOp(m_argImpl.template packet<LoadMode, PacketType>(index));
      9,072 ( 0.00%)       0              0               7,560 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           protected:
          .                .              .                   .            .            .                   .              .           .             const UnaryOp m_functor;
          .                .              .                   .            .            .                   .              .           .             evaluator<ArgType> m_argImpl;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- CwiseTernaryOp --------------------
          .                .              .                   .            .            .                   .              .           .           
-- line 572 ----------------------------------------
-- line 657 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             evaluator<Arg2> m_arg2Impl;
          .                .              .                   .            .            .                   .              .           .             evaluator<Arg3> m_arg3Impl;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- CwiseBinaryOp --------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // this is a binary expression
          .                .              .                   .            .            .                   .              .           .           template<typename BinaryOp, typename Lhs, typename Rhs>
  4,324,859 ( 0.03%)  55,939 ( 0.09%) 2,481 ( 0.02%)  1,179,507 ( 0.03%)   0            0           1,179,507 ( 0.04%)     0           0           struct evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
          .                .              .                   .            .            .                   .              .           .             : public binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
          .                .              .                   .            .            .                   .              .           .             typedef binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> > Base;
          .                .              .                   .            .            .                   .              .           .             
  5,504,366 ( 0.04%) 110,092 ( 0.18%) 4,833 ( 0.05%)  1,572,676 ( 0.05%)   0            0           1,572,676 ( 0.06%)    10 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr) : Base(xpr) {}
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename BinaryOp, typename Lhs, typename Rhs>
  7,470,211 ( 0.06%) 103,008 ( 0.17%) 3,476 ( 0.03%)  1,965,845 ( 0.06%)   0            0           1,965,845 ( 0.07%)     0           0           struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IndexBased>
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
          .                .              .                   .            .            .                   .              .           .               
          .                .              .                   .            .            .                   .              .           .               LhsFlags = evaluator<Lhs>::Flags,
-- line 683 ----------------------------------------
-- line 691 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .                      | (functor_traits<BinaryOp>::PacketAccess && StorageOrdersAgree && SameType ? PacketAccessBit : 0)
          .                .              .                   .            .            .                   .              .           .                      )
          .                .              .                   .            .            .                   .              .           .                   )
          .                .              .                   .            .            .                   .              .           .                ),
          .                .              .                   .            .            .                   .              .           .               Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),
          .                .              .                   .            .            .                   .              .           .               Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<Lhs>::Alignment,evaluator<Rhs>::Alignment)
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           
  2,752,183 ( 0.02%)  79,493 ( 0.13%) 4,804 ( 0.05%)          0            0            0           1,572,676 ( 0.06%)   206 ( 0.00%)  6 ( 0.00%)    EIGEN_DEVICE_FUNC explicit binary_evaluator(const XprType& xpr)
  2,752,183 ( 0.02%)  11,648 ( 0.02%)   760 ( 0.01%)    786,338 ( 0.02%)   0            0             786,338 ( 0.03%)     0           0               : m_functor(xpr.functor()),
  3,145,352 ( 0.02%)  62,180 ( 0.10%) 3,523 ( 0.03%)    786,338 ( 0.02%)   0            0             786,338 ( 0.03%)     0           0                 m_lhsImpl(xpr.lhs()), 
  4,324,859 ( 0.03%)  40,398 ( 0.07%) 2,925 ( 0.03%)  1,179,507 ( 0.03%)   0            0           1,179,507 ( 0.04%)     7 ( 0.00%)  0                 m_rhsImpl(xpr.rhs())  
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<BinaryOp>::Cost);
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
  1,572,676 ( 0.01%)  32,674 ( 0.05%) 4,302 ( 0.04%)  1,179,507 ( 0.03%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    444,987 ( 0.00%)   2,450 ( 0.00%)   665 ( 0.01%)     36,773 ( 0.00%)   0            0             255,404 ( 0.01%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
    935,576 ( 0.01%)   6,115 ( 0.01%) 1,591 ( 0.02%)    270,753 ( 0.01%)   0            0             165,808 ( 0.01%)     0           0               return m_functor(m_lhsImpl.coeff(row, col), m_rhsImpl.coeff(row, col));
    315,507 ( 0.00%)     846 ( 0.00%)   651 ( 0.01%)    214,819 ( 0.01%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     21,666 ( 0.00%)   1,268 ( 0.00%) 1,037 ( 0.01%)      2,091 ( 0.00%)   0            0              11,211 ( 0.00%)     0           0             CoeffReturnType coeff(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
     46,002 ( 0.00%)     823 ( 0.00%)   613 ( 0.01%)     10,455 ( 0.00%)   0            0               8,364 ( 0.00%)     0           0               return m_functor(m_lhsImpl.coeff(index), m_rhsImpl.coeff(index));
     16,149 ( 0.00%)     378 ( 0.00%)   189 ( 0.00%)     11,211 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
  4,293,795 ( 0.03%)  43,199 ( 0.07%) 2,689 ( 0.03%)    390,345 ( 0.01%)   0            0           2,342,070 ( 0.08%)   294 ( 0.00%) 14 ( 0.00%)    PacketType packet(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
  5,464,830 ( 0.04%)  55,564 ( 0.09%) 2,227 ( 0.02%)  1,561,380 ( 0.05%)   0            0           1,171,035 ( 0.04%)     0           0               return m_functor.packetOp(m_lhsImpl.template packet<LoadMode,PacketType>(row, col),
  3,122,760 ( 0.02%)  66,140 ( 0.11%) 2,810 ( 0.03%)  1,171,035 ( 0.03%)   0            0             780,690 ( 0.03%)     8 ( 0.00%)  0                                         m_rhsImpl.template packet<LoadMode,PacketType>(row, col));
  2,342,070 ( 0.02%)  24,320 ( 0.04%)   793 ( 0.01%)  1,951,725 ( 0.06%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     36,650 ( 0.00%)      50 ( 0.00%)    50 ( 0.00%)      3,665 ( 0.00%)   0            0              18,325 ( 0.00%)     0           0             PacketType packet(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
     47,645 ( 0.00%)      50 ( 0.00%)    50 ( 0.00%)     10,995 ( 0.00%)   0            0              10,995 ( 0.00%)     0           0               return m_functor.packetOp(m_lhsImpl.template packet<LoadMode,PacketType>(index),
     25,655 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      7,330 ( 0.00%)   0            0               7,330 ( 0.00%)     0           0                                         m_rhsImpl.template packet<LoadMode,PacketType>(index));
     21,990 ( 0.00%)     239 ( 0.00%)   239 ( 0.00%)     18,325 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           protected:
          .                .              .                   .            .            .                   .              .           .             const BinaryOp m_functor;
          .                .              .                   .            .            .                   .              .           .             evaluator<Lhs> m_lhsImpl;
          .                .              .                   .            .            .                   .              .           .             evaluator<Rhs> m_rhsImpl;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- CwiseUnaryView --------------------
-- line 744 ----------------------------------------
-- line 800 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .           // -------------------- Map --------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // FIXME perhaps the PlainObjectType could be provided by Derived::PlainObject ?
          .                .              .                   .            .            .                   .              .           .           // but that might complicate template specialization
          .                .              .                   .            .            .                   .              .           .           template<typename Derived, typename PlainObjectType>
          .                .              .                   .            .            .                   .              .           .           struct mapbase_evaluator;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename Derived, typename PlainObjectType>
    145,200 ( 0.00%)   2,658 ( 0.00%) 1,743 ( 0.02%)     39,600 ( 0.00%)   0            0              39,600 ( 0.00%)     0           0           struct mapbase_evaluator : evaluator_base<Derived>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Derived  XprType;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::PointerType PointerType;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               IsRowMajor = XprType::RowsAtCompileTime,
          .                .              .                   .            .            .                   .              .           .               ColsAtCompileTime = XprType::ColsAtCompileTime,
          .                .              .                   .            .            .                   .              .           .               CoeffReadCost = NumTraits<Scalar>::ReadCost
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           
     92,400 ( 0.00%)   7,708 ( 0.01%) 6,510 ( 0.06%)          0            0            0              52,800 ( 0.00%)   472 ( 0.00%)  6 ( 0.00%)    EIGEN_DEVICE_FUNC explicit mapbase_evaluator(const XprType& map)
     66,000 ( 0.00%)   2,035 ( 0.00%) 1,918 ( 0.02%)     26,400 ( 0.00%)   0            0              26,400 ( 0.00%)    48 ( 0.00%)  0               : m_data(const_cast<PointerType>(map.data())),
    105,600 ( 0.00%)   1,991 ( 0.00%) 1,932 ( 0.02%)     26,400 ( 0.00%)   0            0              26,400 ( 0.00%)     0           0                 m_innerStride(map.innerStride()),
    145,200 ( 0.00%)   3,655 ( 0.01%) 1,887 ( 0.02%)     39,600 ( 0.00%)   0            0              39,600 ( 0.00%)   104 ( 0.00%) 15 ( 0.00%)        m_outerStride(map.outerStride())
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(evaluator<Derived>::Flags&PacketAccessBit, internal::inner_stride_at_compile_time<Derived>::ret==1),
          .                .              .                   .            .            .                   .              .           .                                   PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1);
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     52,800 ( 0.00%)     890 ( 0.00%)   834 ( 0.01%)     39,600 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     71,307 ( 0.00%)   2,414 ( 0.00%) 2,309 ( 0.02%)          0            0            0              47,538 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
    117,152 ( 0.00%)   1,717 ( 0.00%) 1,653 ( 0.02%)     50,653 ( 0.00%) 402 ( 0.00%) 402 ( 0.00%)     15,846 ( 0.00%)     0           0               return m_data[col * colStride() + row * rowStride()];
     42,730 ( 0.00%)       0              0              31,692 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      7,140 ( 0.00%)      33 ( 0.00%)    33 ( 0.00%)          0            0            0               4,080 ( 0.00%)     0           0             CoeffReturnType coeff(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
      6,912 ( 0.00%)       0              0               3,324 ( 0.00%)   0            0               1,020 ( 0.00%)     0           0               return m_data[index * m_innerStride.value()];
      3,060 ( 0.00%)       0              0               3,060 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     37,692 ( 0.00%)   1,402 ( 0.00%) 1,322 ( 0.01%)          0            0            0              25,128 ( 0.00%)     0           0             Scalar& coeffRef(Index row, Index col)
          .                .              .                   .            .            .                   .              .           .             {
     58,632 ( 0.00%)     894 ( 0.00%)   851 ( 0.01%)     25,128 ( 0.00%)   0            0               8,376 ( 0.00%)     0           0               return m_data[col * colStride() + row * rowStride()];
     20,940 ( 0.00%)       0              0              16,752 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     78,792 ( 0.00%)     567 ( 0.00%)   567 ( 0.01%)          0            0            0              45,024 ( 0.00%)     0           0             Scalar& coeffRef(Index index)
          .                .              .                   .            .            .                   .              .           .             {
     77,400 ( 0.00%)       0              0              37,056 ( 0.00%)   0            0              11,256 ( 0.00%)     0           0               return m_data[index * m_innerStride.value()];
     33,768 ( 0.00%)     378 ( 0.00%)   378 ( 0.00%)     33,768 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     20,061 ( 0.00%)     894 ( 0.00%)   851 ( 0.01%)          0            0            0              13,374 ( 0.00%)   420 ( 0.00%)  0             PacketType packet(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             {
     37,893 ( 0.00%)   1,339 ( 0.00%) 1,275 ( 0.01%)     15,603 ( 0.00%)   0            0               8,916 ( 0.00%)   394 ( 0.00%)  0               PointerType ptr = m_data + row * rowStride() + col * colStride();
          .                .              .                   .            .            .                   .              .           .               return internal::ploadt<PacketType, LoadMode>(ptr);
     11,145 ( 0.00%)       0              0               8,916 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     44,695 ( 0.00%)     428 ( 0.00%)   239 ( 0.00%)          0            0            0              25,540 ( 0.00%)     0           0             PacketType packet(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
     44,695 ( 0.00%)      50 ( 0.00%)    50 ( 0.00%)     19,155 ( 0.00%)   0            0              12,770 ( 0.00%)     0           0               return internal::ploadt<PacketType, LoadMode>(m_data + index * m_innerStride.value());
     19,155 ( 0.00%)       0              0              19,155 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int StoreMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             void writePacket(Index row, Index col, const PacketType& x)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               PointerType ptr = m_data + row * rowStride() + col * colStride();
          .                .              .                   .            .            .                   .              .           .               return internal::pstoret<Scalar, PacketType, StoreMode>(ptr, x);
          .                .              .                   .            .            .                   .              .           .             }
-- line 876 ----------------------------------------
-- line 878 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             template<int StoreMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             void writePacket(Index index, const PacketType& x)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               internal::pstoret<Scalar, PacketType, StoreMode>(m_data + index * m_innerStride.value(), x);
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           protected:
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC
    114,720 ( 0.00%)   1,784 ( 0.00%) 1,685 ( 0.02%)     28,680 ( 0.00%)   0            0              43,020 ( 0.00%)   425 ( 0.00%)  0             inline Index rowStride() const { return XprType::IsRowMajor ? m_outerStride.value() : m_innerStride.value(); }
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC
    123,792 ( 0.00%)   2,946 ( 0.00%) 1,871 ( 0.02%)     31,704 ( 0.00%)   0            0              43,020 ( 0.00%)   409 ( 0.00%)  0             inline Index colStride() const { return XprType::IsRowMajor ? m_innerStride.value() : m_outerStride.value(); }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             PointerType m_data;
          .                .              .                   .            .            .                   .              .           .             const internal::variable_if_dynamic<Index, XprType::InnerStrideAtCompileTime> m_innerStride;
          .                .              .                   .            .            .                   .              .           .             const internal::variable_if_dynamic<Index, XprType::OuterStrideAtCompileTime> m_outerStride;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename PlainObjectType, int MapOptions, typename StrideType> 
          .                .              .                   .            .            .                   .              .           .           struct evaluator<Map<PlainObjectType, MapOptions, StrideType> >
-- line 896 ----------------------------------------
-- line 944 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- Block --------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel,
          .                .              .                   .            .            .                   .              .           .                    bool HasDirectAccess = internal::has_direct_access<ArgType>::ret> struct block_evaluator;
          .                .              .                   .            .            .                   .              .           .                    
          .                .              .                   .            .            .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel> 
    166,727 ( 0.00%)   6,156 ( 0.01%) 4,724 ( 0.05%)     45,471 ( 0.00%)   0            0              45,471 ( 0.00%)     0           0           struct evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
          .                .              .                   .            .            .                   .              .           .             : block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .             // TODO: should check for smaller packet types once we can handle multi-sized packet types
          .                .              .                   .            .            .                   .              .           .             typedef typename packet_traits<Scalar>::type PacketScalar;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
-- line 960 ----------------------------------------
-- line 988 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .               
          .                .              .                   .            .            .                   .              .           .               PacketAlignment = unpacket_traits<PacketScalar>::alignment,
          .                .              .                   .            .            .                   .              .           .               Alignment0 = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic)
          .                .              .                   .            .            .                   .              .           .                                        && (OuterStrideAtCompileTime!=0)
          .                .              .                   .            .            .                   .              .           .                                        && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % int(PacketAlignment)) == 0)) ? int(PacketAlignment) : 0,
          .                .              .                   .            .            .                   .              .           .               Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ArgType>::Alignment, Alignment0)
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .             typedef block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel> block_evaluator_type;
    166,727 ( 0.00%)   6,355 ( 0.01%) 5,717 ( 0.05%)     30,314 ( 0.00%)   0            0              60,628 ( 0.00%)   840 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& block) : block_evaluator_type(block)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
     45,471 ( 0.00%)     222 ( 0.00%)   222 ( 0.00%)     30,314 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // no direct-access => dispatch to a unary evaluator
          .                .              .                   .            .            .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
     21,527 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      5,871 ( 0.00%)   0            0               5,871 ( 0.00%)     0           0           struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, /*HasDirectAccess*/ false>
          .                .              .                   .            .            .                   .              .           .             : unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .                .              .                   .            .            .                   .              .           .           
     11,742 ( 0.00%)   1,062 ( 0.00%) 1,041 ( 0.01%)          0            0            0               5,871 ( 0.00%)    16 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)
      9,785 ( 0.00%)     445 ( 0.00%)   424 ( 0.00%)      3,914 ( 0.00%)   0            0               1,957 ( 0.00%)     8 ( 0.00%)  0               : unary_evaluator<XprType>(block) 
      5,871 ( 0.00%)       0              0               3,914 ( 0.00%)   0            0                   0              0           0             {}
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
     29,355 ( 0.00%)     634 ( 0.00%)   613 ( 0.01%)      7,828 ( 0.00%)   0            0               7,828 ( 0.00%)     0           0           struct unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>, IndexBased>
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .                .              .                   .            .            .                   .              .           .           
     14,455 ( 0.00%)     378 ( 0.00%)   378 ( 0.00%)          0            0            0               8,584 ( 0.00%)   405 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& block)
     15,656 ( 0.00%)     378 ( 0.00%)   378 ( 0.00%)      3,914 ( 0.00%)   0            0               3,914 ( 0.00%)     0           0               : m_argImpl(block.nestedExpression()), 
     15,656 ( 0.00%)     445 ( 0.00%)   424 ( 0.00%)      3,914 ( 0.00%)   0            0               3,914 ( 0.00%)     0           0                 m_startRow(block.startRow()), 
     15,656 ( 0.00%)     378 ( 0.00%)   378 ( 0.00%)      3,914 ( 0.00%)   0            0               3,914 ( 0.00%)     0           0                 m_startCol(block.startCol()),
     21,704 ( 0.00%)     445 ( 0.00%)   424 ( 0.00%)      5,426 ( 0.00%)   0            0               5,426 ( 0.00%)    19 ( 0.00%)  0                 m_linear_offset(InnerPanel?(XprType::IsRowMajor ? block.startRow()*block.cols() : block.startCol()*block.rows()):0)
      9,340 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      6,627 ( 0.00%)   0            0                   0              0           0             { }
          .                .              .                   .            .            .                   .              .           .            
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               RowsAtCompileTime = XprType::RowsAtCompileTime,
          .                .              .                   .            .            .                   .              .           .               ForwardLinearAccess = InnerPanel && bool(evaluator<ArgType>::Flags&LinearAccessBit)
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .            
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     39,231 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)          0            0            0              26,154 ( 0.00%)     0           0             CoeffReturnType coeff(Index row, Index col) const
          .                .              .                   .            .            .                   .              .           .             { 
     82,821 ( 0.00%)     634 ( 0.00%)   613 ( 0.01%)     21,795 ( 0.00%)   0            0              13,077 ( 0.00%)     0           0               return m_argImpl.coeff(m_startRow.value() + row, m_startCol.value() + col); 
     26,154 ( 0.00%)       0              0              17,436 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     18,144 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)          0            0            0               9,072 ( 0.00%)     0           0             CoeffReturnType coeff(Index index) const
          .                .              .                   .            .            .                   .              .           .             { 
          .                .              .                   .            .            .                   .              .           .               if (ForwardLinearAccess)
          .                .              .                   .            .            .                   .              .           .                 return m_argImpl.coeff(m_linear_offset.value() + index); 
          .                .              .                   .            .            .                   .              .           .               else
     21,168 ( 0.00%)       0              0               6,048 ( 0.00%)   0            0               3,024 ( 0.00%)     0           0                 return coeff(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
      9,072 ( 0.00%)       0              0               6,048 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             Scalar& coeffRef(Index row, Index col)
          .                .              .                   .            .            .                   .              .           .             { 
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.coeffRef(m_startRow.value() + row, m_startCol.value() + col); 
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
-- line 1056 ----------------------------------------
-- line 1066 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             PacketType packet(Index row, Index col) const 
          .                .              .                   .            .            .                   .              .           .             { 
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.template packet<LoadMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col); 
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             template<int LoadMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
     10,584 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)          0            0            0               6,048 ( 0.00%)     0           0             PacketType packet(Index index) const 
          .                .              .                   .            .            .                   .              .           .             { 
          .                .              .                   .            .            .                   .              .           .               if (ForwardLinearAccess)
     18,144 ( 0.00%)       0              0               4,536 ( 0.00%)   0            0               3,024 ( 0.00%)     0           0                 return m_argImpl.template packet<LoadMode,PacketType>(m_linear_offset.value() + index);
          .                .              .                   .            .            .                   .              .           .               else
          .                .              .                   .            .            .                   .              .           .                 return packet<LoadMode,PacketType>(RowsAtCompileTime == 1 ? 0 : index,
          .                .              .                   .            .            .                   .              .           .                                                    RowsAtCompileTime == 1 ? index : 0);
      4,536 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      4,536 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             template<int StoreMode, typename PacketType>
          .                .              .                   .            .            .                   .              .           .             EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             void writePacket(Index row, Index col, const PacketType& x) 
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.template writePacket<StoreMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col, x); 
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .             
-- line 1089 ----------------------------------------
-- line 1105 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             const variable_if_dynamic<Index, (ArgType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;
          .                .              .                   .            .            .                   .              .           .             const variable_if_dynamic<Index, InnerPanel ? Dynamic : 0> m_linear_offset;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // TODO: This evaluator does not actually use the child evaluator; 
          .                .              .                   .            .            .                   .              .           .           // all action is via the data() as returned by the Block expression.
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel> 
    145,200 ( 0.00%)   2,243 ( 0.00%) 1,741 ( 0.02%)     39,600 ( 0.00%)   0            0              39,600 ( 0.00%)     0           0           struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, /* HasDirectAccess */ true>
          .                .              .                   .            .            .                   .              .           .             : mapbase_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>,
          .                .              .                   .            .            .                   .              .           .                                 typename Block<ArgType, BlockRows, BlockCols, InnerPanel>::PlainObject>
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .           
     79,200 ( 0.00%)   6,436 ( 0.01%) 4,118 ( 0.04%)          0            0            0              39,600 ( 0.00%)    71 ( 0.00%)  0             EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)
     66,000 ( 0.00%)     923 ( 0.00%)   902 ( 0.01%)     26,400 ( 0.00%)   0            0              13,200 ( 0.00%)     8 ( 0.00%)  0               : mapbase_evaluator<XprType, typename XprType::PlainObject>(block) 
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               // TODO: for the 3.3 release, this should be turned to an internal assertion, but let's keep it as is for the beta lifetime
     43,710 ( 0.00%)     480 ( 0.00%)   458 ( 0.00%)     13,200 ( 0.00%)   0            0              13,200 ( 0.00%)     0           0               eigen_assert(((internal::UIntPtr(block.data()) % EIGEN_PLAIN_ENUM_MAX(1,evaluator<XprType>::Alignment)) == 0) && "data is not aligned");
     39,600 ( 0.00%)     856 ( 0.00%)   646 ( 0.01%)     26,400 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- Select --------------------
          .                .              .                   .            .            .                   .              .           .           // NOTE shall we introduce a ternary_evaluator?
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // TODO enable vectorization for Select
          .                .              .                   .            .            .                   .              .           .           template<typename ConditionMatrixType, typename ThenMatrixType, typename ElseMatrixType>
-- line 1133 ----------------------------------------
-- line 1265 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             const variable_if_dynamic<Index, ArgType::RowsAtCompileTime> m_rows;
          .                .              .                   .            .            .                   .              .           .             const variable_if_dynamic<Index, ArgType::ColsAtCompileTime> m_cols;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- PartialReduxExpr --------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template< typename ArgType, typename MemberOp, int Direction>
      2,079 ( 0.00%)       0              0                 567 ( 0.00%)   0            0                 567 ( 0.00%)     0           0           struct evaluator<PartialReduxExpr<ArgType, MemberOp, Direction> >
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<PartialReduxExpr<ArgType, MemberOp, Direction> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef PartialReduxExpr<ArgType, MemberOp, Direction> XprType;
          .                .              .                   .            .            .                   .              .           .             typedef typename internal::nested_eval<ArgType,1>::type ArgTypeNested;
          .                .              .                   .            .            .                   .              .           .             typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;
          .                .              .                   .            .            .                   .              .           .             typedef typename ArgType::Scalar InputScalar;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .             enum {
-- line 1281 ----------------------------------------
-- line 1286 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .               CoeffReadCost = TraversalSize==Dynamic ? HugeCost
          .                .              .                   .            .            .                   .              .           .                             : TraversalSize * evaluator<ArgType>::CoeffReadCost + int(CostOpType::value),
          .                .              .                   .            .            .                   .              .           .               
          .                .              .                   .            .            .                   .              .           .               Flags = (traits<XprType>::Flags&RowMajorBit) | (evaluator<ArgType>::Flags&(HereditaryBits&(~RowMajorBit))) | LinearAccessBit,
          .                .              .                   .            .            .                   .              .           .               
          .                .              .                   .            .            .                   .              .           .               Alignment = 0 // FIXME this will need to be improved once PartialReduxExpr is vectorized
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           
      1,890 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)        189 ( 0.00%)   0            0                 945 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType xpr)
      3,024 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)        945 ( 0.00%)   0            0                 756 ( 0.00%)     0           0               : m_arg(xpr.nestedExpression()), m_functor(xpr.functor())
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(TraversalSize==Dynamic ? HugeCost : int(CostOpType::value));
          .                .              .                   .            .            .                   .              .           .               EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
      1,323 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)        945 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
      8,316 ( 0.00%)       0              0                 756 ( 0.00%)   0            0               4,536 ( 0.00%)     0           0             const Scalar coeff(Index i, Index j) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               if (Direction==Vertical)
     10,584 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      2,268 ( 0.00%)   0            0               1,512 ( 0.00%)     0           0                 return m_functor(m_arg.col(j));
          .                .              .                   .            .            .                   .              .           .               else
          .                .              .                   .            .            .                   .              .           .                 return m_functor(m_arg.row(i));
      5,292 ( 0.00%)     189 ( 0.00%)   189 ( 0.00%)      3,780 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             const Scalar coeff(Index index) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               if (Direction==Vertical)
          .                .              .                   .            .            .                   .              .           .                 return m_functor(m_arg.col(index));
          .                .              .                   .            .            .                   .              .           .               else
          .                .              .                   .            .            .                   .              .           .                 return m_functor(m_arg.row(index));
-- line 1318 ----------------------------------------
-- line 1549 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .             const variable_if_dynamic<Index, ReverseRow ? ArgType::RowsAtCompileTime : 1> m_rows;
          .                .              .                   .            .            .                   .              .           .             const variable_if_dynamic<Index, ReverseCol ? ArgType::ColsAtCompileTime : 1> m_cols;
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- Diagonal --------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           template<typename ArgType, int DiagIndex>
      7,200 ( 0.00%)     480 ( 0.00%)   460 ( 0.00%)      1,920 ( 0.00%)   0            0               1,920 ( 0.00%)     0           0           struct evaluator<Diagonal<ArgType, DiagIndex> >
          .                .              .                   .            .            .                   .              .           .             : evaluator_base<Diagonal<ArgType, DiagIndex> >
          .                .              .                   .            .            .                   .              .           .           {
          .                .              .                   .            .            .                   .              .           .             typedef Diagonal<ArgType, DiagIndex> XprType;
          .                .              .                   .            .            .                   .              .           .             
          .                .              .                   .            .            .                   .              .           .             enum {
          .                .              .                   .            .            .                   .              .           .               CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
          .                .              .                   .            .            .                   .              .           .               
          .                .              .                   .            .            .                   .              .           .               Flags = (unsigned int)(evaluator<ArgType>::Flags & (HereditaryBits | DirectAccessBit) & ~RowMajorBit) | LinearAccessBit,
          .                .              .                   .            .            .                   .              .           .               
          .                .              .                   .            .            .                   .              .           .               Alignment = 0
          .                .              .                   .            .            .                   .              .           .             };
          .                .              .                   .            .            .                   .              .           .           
      3,360 ( 0.00%)     480 ( 0.00%)   463 ( 0.00%)          0            0            0               1,920 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC explicit evaluator(const XprType& diagonal)
      3,840 ( 0.00%)     480 ( 0.00%)   460 ( 0.00%)        960 ( 0.00%)   0            0                 960 ( 0.00%)     0           0               : m_argImpl(diagonal.nestedExpression()),
      5,280 ( 0.00%)       0              0               1,440 ( 0.00%)   0            0               1,440 ( 0.00%)     0           0                 m_index(diagonal.index())
      1,920 ( 0.00%)     480 ( 0.00%)   463 ( 0.00%)      1,440 ( 0.00%)   0            0                   0              0           0             { }
          .                .              .                   .            .            .                   .              .           .            
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::Scalar Scalar;
          .                .              .                   .            .            .                   .              .           .             typedef typename XprType::CoeffReturnType CoeffReturnType;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             CoeffReturnType coeff(Index row, Index) const
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.coeff(row + rowOffset(), row + colOffset());
-- line 1581 ----------------------------------------
-- line 1589 ----------------------------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
          .                .              .                   .            .            .                   .              .           .             Scalar& coeffRef(Index row, Index)
          .                .              .                   .            .            .                   .              .           .             {
          .                .              .                   .            .            .                   .              .           .               return m_argImpl.coeffRef(row + rowOffset(), row + colOffset());
          .                .              .                   .            .            .                   .              .           .             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     11,520 ( 0.00%)     480 ( 0.00%)   462 ( 0.00%)          0            0            0               7,200 ( 0.00%)     0           0             Scalar& coeffRef(Index index)
          .                .              .                   .            .            .                   .              .           .             {
     23,040 ( 0.00%)       0              0               7,200 ( 0.00%)   0            0               4,320 ( 0.00%)     0           0               return m_argImpl.coeffRef(index + rowOffset(), index + colOffset());
      7,200 ( 0.00%)       0              0               5,760 ( 0.00%)   0            0                   0              0           0             }
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           protected:
          .                .              .                   .            .            .                   .              .           .             evaluator<ArgType> m_argImpl;
          .                .              .                   .            .            .                   .              .           .             const internal::variable_if_dynamicindex<Index, XprType::DiagIndex> m_index;
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           private:
     18,720 ( 0.00%)       0              0               2,880 ( 0.00%)   0            0               5,760 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value() > 0 ? 0 : -m_index.value(); }
     15,840 ( 0.00%)     480 ( 0.00%)   477 ( 0.00%)      2,880 ( 0.00%)   0            0               4,320 ( 0.00%)     0           0             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value() > 0 ? m_index.value() : 0; }
          .                .              .                   .            .            .                   .              .           .           };
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           //----------------------------------------------------------------------
          .                .              .                   .            .            .                   .              .           .           // deprecated code
          .                .              .                   .            .            .                   .              .           .           //----------------------------------------------------------------------
          .                .              .                   .            .            .                   .              .           .           
          .                .              .                   .            .            .                   .              .           .           // -------------------- EvalToTemp --------------------
-- line 1616 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/EigenBase.h
--------------------------------------------------------------------------------
Ir                   I1mr            ILmr           Dr                   D1mr       DLmr       Dw                  D1mw         DLmw        

-- line 37 ----------------------------------------
          .               .              .                    .          .          .                   .            .           .               */
          .               .              .                    .          .          .                   .            .           .             typedef Eigen::Index Index;
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             // FIXME is it needed?
          .               .              .                    .          .          .                   .            .           .             typedef typename internal::traits<Derived>::StorageKind StorageKind;
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             /** \returns a reference to the derived object */
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
  8,617,287 ( 0.07%) 17,214 ( 0.03%) 3,836 ( 0.04%)   3,693,123 ( 0.11%) 0          0           2,462,082 ( 0.09%) 207 ( 0.00%) 15 ( 0.00%)    Derived& derived() { return *static_cast<Derived*>(this); }
          .               .              .                    .          .          .                   .            .           .             /** \returns a const reference to the derived object */
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
269,952,193 ( 2.09%) 38,023 ( 0.06%) 8,632 ( 0.08%) 115,693,797 ( 3.43%) 0          0          77,129,198 ( 2.71%)  22 ( 0.00%)  1 ( 0.00%)    const Derived& derived() const { return *static_cast<const Derived*>(this); }
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
    984,360 ( 0.01%) 12,452 ( 0.02%) 1,534 ( 0.01%)           0          0          0             492,180 ( 0.02%)   0           0             inline Derived& const_cast_derived() const
    738,270 ( 0.01%)  1,295 ( 0.00%)   805 ( 0.01%)     738,270 ( 0.02%) 0          0                   0            0           0             { return *static_cast<Derived*>(const_cast<EigenBase*>(this)); }
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
          .               .              .                    .          .          .                   .            .           .             inline const Derived& const_derived() const
          .               .              .                    .          .          .                   .            .           .             { return *static_cast<const Derived*>(this); }
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             /** \returns the number of rows. \sa cols(), RowsAtCompileTime */
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
151,444,104 ( 1.17%) 47,505 ( 0.08%) 5,465 ( 0.05%)  37,861,026 ( 1.12%) 0          0          50,481,368 ( 1.77%) 478 ( 0.00%) 31 ( 0.00%)    inline Index rows() const { return derived().rows(); }
          .               .              .                    .          .          .                   .            .           .             /** \returns the number of columns. \sa rows(), ColsAtCompileTime*/
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
150,674,976 ( 1.17%) 23,938 ( 0.04%) 4,561 ( 0.04%)  37,668,744 ( 1.12%) 0          0          50,224,992 ( 1.77%)   0           0             inline Index cols() const { return derived().cols(); }
          .               .              .                    .          .          .                   .            .           .             /** \returns the number of coefficients, which is rows()*cols().
          .               .              .                    .          .          .                   .            .           .               * \sa rows(), cols(), SizeAtCompileTime. */
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
211,297,624 ( 1.64%) 19,750 ( 0.03%) 3,956 ( 0.04%)  62,146,360 ( 1.84%) 0          0          62,146,360 ( 2.19%)   6 ( 0.00%)  0             inline Index size() const { return rows() * cols(); }
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst = *this; \endcode */
          .               .              .                    .          .          .                   .            .           .             template<typename Dest>
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
          .               .              .                    .          .          .                   .            .           .             inline void evalTo(Dest& dst) const
          .               .              .                    .          .          .                   .            .           .             { derived().evalTo(dst); }
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst += *this; \endcode */
-- line 74 ----------------------------------------
-- line 92 ----------------------------------------
          .               .              .                    .          .          .                   .            .           .               // derived class can reimplement it in a more optimized way.
          .               .              .                    .          .          .                   .            .           .               typename Dest::PlainObject res(rows(),cols());
          .               .              .                    .          .          .                   .            .           .               evalTo(res);
          .               .              .                    .          .          .                   .            .           .               dst -= res;
          .               .              .                    .          .          .                   .            .           .             }
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst.applyOnTheRight(*this); \endcode */
          .               .              .                    .          .          .                   .            .           .             template<typename Dest>
      1,701 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)         189 ( 0.00%) 0          0                 756 ( 0.00%)   0           0             EIGEN_DEVICE_FUNC inline void applyThisOnTheRight(Dest& dst) const
          .               .              .                    .          .          .                   .            .           .             {
          .               .              .                    .          .          .                   .            .           .               // This is the default implementation,
          .               .              .                    .          .          .                   .            .           .               // derived class can reimplement it in a more optimized way.
      2,835 ( 0.00%)    189 ( 0.00%)     0                  567 ( 0.00%) 0          0                 945 ( 0.00%)   0           0               dst = dst * this->derived();
      1,134 ( 0.00%)      0              0                  756 ( 0.00%) 0          0                   0            0           0             }
          .               .              .                    .          .          .                   .            .           .           
          .               .              .                    .          .          .                   .            .           .             /** \internal Don't use it, but do the equivalent: \code dst.applyOnTheLeft(*this); \endcode */
          .               .              .                    .          .          .                   .            .           .             template<typename Dest>
          .               .              .                    .          .          .                   .            .           .             EIGEN_DEVICE_FUNC inline void applyThisOnTheLeft(Dest& dst) const
          .               .              .                    .          .          .                   .            .           .             {
          .               .              .                    .          .          .                   .            .           .               // This is the default implementation,
          .               .              .                    .          .          .                   .            .           .               // derived class can reimplement it in a more optimized way.
          .               .              .                    .          .          .                   .            .           .               dst = this->derived() * dst;
-- line 113 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/XprHelper.h
--------------------------------------------------------------------------------
Ir                   I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw         DLmw        

-- line 118 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           /** \internal If the template parameter Value is Dynamic, this class is just a wrapper around a T variable that
          .               .              .                   .          .          .                   .            .           .             * can be accessed using value() and setValue().
          .               .              .                   .          .          .                   .            .           .             * Otherwise, this class is an empty structure and value() just returns the template parameter Value.
          .               .              .                   .          .          .                   .            .           .             */
          .               .              .                   .          .          .                   .            .           .           template<typename T, int Value> class variable_if_dynamic
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .             public:
  7,790,192 ( 0.06%)  2,038 ( 0.00%)   850 ( 0.01%)  1,947,548 ( 0.06%) 0          0           2,921,322 ( 0.10%) 945 ( 0.00%) 48 ( 0.00%)      EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamic)
149,759,687 ( 1.16%) 32,035 ( 0.05%) 5,271 ( 0.05%) 40,843,551 ( 1.21%) 0          0          40,843,551 ( 1.44%)   0           0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }
 15,353,700 ( 0.12%)  4,768 ( 0.01%) 1,369 ( 0.01%)  5,117,900 ( 0.15%) 0          0           2,558,950 ( 0.09%)   0           0               EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<typename T> class variable_if_dynamic<T, Dynamic>
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .               T m_value;
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC variable_if_dynamic() { eigen_assert(false); }
          .               .              .                   .          .          .                   .            .           .             public:
    789,811 ( 0.01%)  1,367 ( 0.00%)   468 ( 0.00%)    287,204 ( 0.01%) 0          0             287,204 ( 0.01%) 109 ( 0.00%)  0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T value) : m_value(value) {}
    664,312 ( 0.01%)    445 ( 0.00%)   424 ( 0.00%)    332,156 ( 0.01%) 0          0             166,078 ( 0.01%)   3 ( 0.00%)  0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T value() const { return m_value; }
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T value) { m_value = value; }
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           /** \internal like variable_if_dynamic but for DynamicIndex
          .               .              .                   .          .          .                   .            .           .             */
          .               .              .                   .          .          .                   .            .           .           template<typename T, int Value> class variable_if_dynamicindex
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .             public:
          .               .              .                   .          .          .                   .            .           .               EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamicindex)
     10,560 ( 0.00%)    480 ( 0.00%)    82 ( 0.00%)      2,880 ( 0.00%) 0          0               2,880 ( 0.00%)   0           0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamicindex(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }
     46,080 ( 0.00%)      0              0              15,360 ( 0.00%) 0          0               7,680 ( 0.00%)   0           0               EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<typename T> class variable_if_dynamicindex<T, DynamicIndex>
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .               T m_value;
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC variable_if_dynamicindex() { eigen_assert(false); }
          .               .              .                   .          .          .                   .            .           .             public:
-- line 157 ----------------------------------------
-- line 676 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<typename T1, typename T2>
          .               .              .                   .          .          .                   .            .           .           bool is_same_dense(const T1 &mat1, const T2 &mat2, typename enable_if<has_direct_access<T1>::ret&&has_direct_access<T2>::ret, T1>::type * = 0)
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .             return (mat1.data()==mat2.data()) && (mat1.innerStride()==mat2.innerStride()) && (mat1.outerStride()==mat2.outerStride());
          .               .              .                   .          .          .                   .            .           .           }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<typename T1, typename T2>
      1,134 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0          0          0                 756 ( 0.00%)   0           0           bool is_same_dense(const T1 &, const T2 &, typename enable_if<!(has_direct_access<T1>::ret&&has_direct_access<T2>::ret), T1>::type * = 0)
          .               .              .                   .          .          .                   .            .           .           {
        189 ( 0.00%)      0              0                   0          0          0                   0            0           0             return false;
        378 ( 0.00%)      0              0                 378 ( 0.00%) 0          0                   0            0           0           }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           // Internal helper defining the cost of a scalar division for the type T.
          .               .              .                   .          .          .                   .            .           .           // The default heuristic can be specialized for each scalar type and architecture.
          .               .              .                   .          .          .                   .            .           .           template<typename T,bool Vectorized=false,typename EnaleIf = void>
          .               .              .                   .          .          .                   .            .           .           struct scalar_div_cost {
          .               .              .                   .          .          .                   .            .           .             enum { value = 8*NumTraits<T>::MulCost };
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
-- line 695 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                  D1mr           DLmr           Dw                  D1mw           DLmw           

-- line 89 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                  	pointer;
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 struct _Vector_impl_data
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	pointer _M_start;
         .               .              .                   .              .              .                   .              .              .           	pointer _M_finish;
         .               .              .                   .              .              .                   .              .              .           	pointer _M_end_of_storage;
         .               .              .                   .              .              .                   .              .              .           
    17,432 ( 0.00%)  1,070 ( 0.00%)   224 ( 0.00%)          0              0              0               8,730 ( 0.00%)     0              0           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
    26,190 ( 0.00%)    898 ( 0.00%)   408 ( 0.00%)     13,095 ( 0.00%)     0              0              13,095 ( 0.00%) 1,571 ( 0.00%) 1,062 ( 0.00%)  	: _M_start(), _M_finish(), _M_end_of_storage()
    13,095 ( 0.00%)      0              0               8,730 ( 0.00%)     0              0                   0              0              0           	{ }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
     1,815 ( 0.00%)     25 ( 0.00%)    10 ( 0.00%)          0              0              0               1,089 ( 0.00%)     0              0           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
     2,904 ( 0.00%)    121 ( 0.00%)    60 ( 0.00%)      2,178 ( 0.00%)     0              0                 726 ( 0.00%)    57 ( 0.00%)    51 ( 0.00%)  	: _M_start(__x._M_start), _M_finish(__x._M_finish),
     1,452 ( 0.00%)     25 ( 0.00%)    10 ( 0.00%)      1,089 ( 0.00%)     0              0                 363 ( 0.00%)    39 ( 0.00%)    33 ( 0.00%)  	  _M_end_of_storage(__x._M_end_of_storage)
     4,719 ( 0.00%)     25 ( 0.00%)    10 ( 0.00%)      3,267 ( 0.00%)     0              0               1,089 ( 0.00%)     0              0           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           	void
       720 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)          0              0              0                 432 ( 0.00%)     0              0           	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .           	{
       576 ( 0.00%)     10 ( 0.00%)    10 ( 0.00%)        432 ( 0.00%)     0              0                 144 ( 0.00%)     0              0           	  _M_start = __x._M_start;
       576 ( 0.00%)      0              0                 432 ( 0.00%)     0              0                 144 ( 0.00%)     0              0           	  _M_finish = __x._M_finish;
       576 ( 0.00%)      0              0                 432 ( 0.00%)     0              0                 144 ( 0.00%)     0              0           	  _M_end_of_storage = __x._M_end_of_storage;
       432 ( 0.00%)      0              0                 288 ( 0.00%)     0              0                   0              0              0           	}
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           	void
       432 ( 0.00%)     24 ( 0.00%)    24 ( 0.00%)         48 ( 0.00%)     0              0                 192 ( 0.00%)     0              0           	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .           	{
         .               .              .                   .              .              .                   .              .              .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
         .               .              .                   .              .              .                   .              .              .           	  // information used by TBAA.
       144 ( 0.00%)      0              0                   0              0              0                  48 ( 0.00%)     0              0           	  _Vector_impl_data __tmp;
       240 ( 0.00%)      0              0                  48 ( 0.00%)     0              0                  48 ( 0.00%)     0              0           	  __tmp._M_copy_data(*this);
       240 ( 0.00%)      0              0                  96 ( 0.00%)     0              0                  48 ( 0.00%)     0              0           	  _M_copy_data(__x);
       240 ( 0.00%)     24 ( 0.00%)    24 ( 0.00%)         48 ( 0.00%)     0              0                  48 ( 0.00%)     0              0           	  __x._M_copy_data(__tmp);
       288 ( 0.00%)      0              0                 192 ( 0.00%)     0              0                   0              0              0           	}
         .               .              .                   .              .              .                   .              .              .                 };
         .               .              .                   .              .              .                   .              .              .           
    49,747 ( 0.00%)  1,619 ( 0.00%)   200 ( 0.00%)     13,575 ( 0.00%)     0              0              13,575 ( 0.00%)     0              0                 struct _Vector_impl
         .               .              .                   .              .              .                   .              .              .           	: public _Tp_alloc_type, public _Vector_impl_data
         .               .              .                   .              .              .                   .              .              .                 {
    12,807 ( 0.00%)  1,464 ( 0.00%)   492 ( 0.00%)          0              0              0               5,134 ( 0.00%)     0              0           	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
         .               .              .                   .              .              .                   .              .              .           	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
    15,402 ( 0.00%)    355 ( 0.00%)   300 ( 0.00%)      5,134 ( 0.00%)     0              0               5,134 ( 0.00%)     1 ( 0.00%)     0           	: _Tp_alloc_type()
     7,701 ( 0.00%)      0              0               5,134 ( 0.00%)     0              0                   0              0              0           	{ }
         .               .              .                   .              .              .                   .              .              .           
    10,500 ( 0.00%)     89 ( 0.00%)    36 ( 0.00%)          0              0              0               5,250 ( 0.00%)     0              0           	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
    14,000 ( 0.00%)    706 ( 0.00%)    94 ( 0.00%)      5,250 ( 0.00%)     0              0               3,500 ( 0.00%)     0              0           	: _Tp_alloc_type(__a)
     5,250 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)      3,500 ( 0.00%)     0              0                   0              0              0           	{ }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
         .               .              .                   .              .              .                   .              .              .           	// Not defaulted, to enforce noexcept(true) even when
         .               .              .                   .              .              .                   .              .              .           	// !is_nothrow_move_constructible<_Tp_alloc_type>.
     2,541 ( 0.00%)    113 ( 0.00%)    50 ( 0.00%)          0              0              0               1,452 ( 0.00%)     0              0           	_Vector_impl(_Vector_impl&& __x) noexcept
     5,445 ( 0.00%)    125 ( 0.00%)    50 ( 0.00%)      1,452 ( 0.00%)     0              0               1,452 ( 0.00%)     0              0           	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
     1,452 ( 0.00%)     10 ( 0.00%)    10 ( 0.00%)      1,089 ( 0.00%)     0              0                   0              0              0           	{ }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           	_Vector_impl(_Tp_alloc_type&& __a) noexcept
         .               .              .                   .              .              .                   .              .              .           	: _Tp_alloc_type(std::move(__a))
         .               .              .                   .              .              .                   .              .              .           	{ }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
         .               .              .                   .              .              .                   .              .              .           	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
         .               .              .                   .              .              .                   .              .              .           	{ }
-- line 153 ----------------------------------------
-- line 268 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .           #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
         .               .              .                   .              .              .                   .              .              .           #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
         .               .              .                   .              .              .                   .              .              .                 };
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .               public:
         .               .              .                   .              .              .                   .              .              .                 typedef _Alloc allocator_type;
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 _Tp_alloc_type&
    51,420 ( 0.00%)  3,441 ( 0.01%)   961 ( 0.01%)          0              0              0              25,770 ( 0.00%)     1 ( 0.00%)     0                 _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
    38,655 ( 0.00%)    130 ( 0.00%)    43 ( 0.00%)     38,655 ( 0.00%)     0              0                   0              0              0                 { return this->_M_impl; }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 const _Tp_alloc_type&
    31,700 ( 0.00%)  3,292 ( 0.01%)   897 ( 0.01%)          0              0              0              15,896 ( 0.00%)     5 ( 0.00%)     0                 _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
    23,844 ( 0.00%)     68 ( 0.00%)    23 ( 0.00%)     23,844 ( 0.00%)     0              0                   0              0              0                 { return this->_M_impl; }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 allocator_type
       144 ( 0.00%)     23 ( 0.00%)    14 ( 0.00%)          0              0              0                  72 ( 0.00%)     0              0                 get_allocator() const _GLIBCXX_NOEXCEPT
       264 ( 0.00%)      0              0                 120 ( 0.00%)     0              0                  48 ( 0.00%)     0              0                 { return allocator_type(_M_get_Tp_allocator()); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
    28,209 ( 0.00%)    505 ( 0.00%)   165 ( 0.00%)      7,701 ( 0.00%)     0              0               7,701 ( 0.00%)     3 ( 0.00%)     0                 _Vector_base() = default;
         .               .              .                   .              .              .                   .              .              .           #else
         .               .              .                   .              .              .                   .              .              .                 _Vector_base() { }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
       144 ( 0.00%)     10 ( 0.00%)    10 ( 0.00%)          0              0              0                  72 ( 0.00%)     0              0                 _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       192 ( 0.00%)      0              0                  96 ( 0.00%)     0              0                  24 ( 0.00%)     0              0                 : _M_impl(__a) { }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Kept for ABI compatibility.
         .               .              .                   .              .              .                   .              .              .           #if !_GLIBCXX_INLINE_VERSION
         .               .              .                   .              .              .                   .              .              .                 _Vector_base(size_t __n)
         .               .              .                   .              .              .                   .              .              .                 : _M_impl()
         .               .              .                   .              .              .                   .              .              .                 { _M_create_storage(__n); }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
    13,808 ( 0.00%)    426 ( 0.00%)    74 ( 0.00%)          0              0              0               8,630 ( 0.00%)     0              0                 _Vector_base(size_t __n, const allocator_type& __a)
     8,630 ( 0.00%)    349 ( 0.00%)    50 ( 0.00%)      3,452 ( 0.00%)     0              0               1,726 ( 0.00%)     0              0                 : _M_impl(__a)
    15,534 ( 0.00%)    819 ( 0.00%)   135 ( 0.00%)      8,630 ( 0.00%)     7 ( 0.00%)     0               1,726 ( 0.00%)     0              0                 { _M_create_storage(__n); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
     5,082 ( 0.00%)     68 ( 0.00%)    20 ( 0.00%)      1,452 ( 0.00%)     0              0               1,452 ( 0.00%)     0              0                 _Vector_base(_Vector_base&&) = default;
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Kept for ABI compatibility.
         .               .              .                   .              .              .                   .              .              .           # if !_GLIBCXX_INLINE_VERSION
         .               .              .                   .              .              .                   .              .              .                 _Vector_base(_Tp_alloc_type&& __a) noexcept
         .               .              .                   .              .              .                   .              .              .                 : _M_impl(std::move(__a)) { }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 _Vector_base(_Vector_base&& __x, const allocator_type& __a)
         .               .              .                   .              .              .                   .              .              .                 : _M_impl(__a)
-- line 316 ----------------------------------------
-- line 325 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                 }
         .               .              .                   .              .              .                   .              .              .           # endif
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
         .               .              .                   .              .              .                   .              .              .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
         .               .              .                   .              .              .                   .              .              .                 { }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
    22,597 ( 0.00%)  1,329 ( 0.00%)   147 ( 0.00%)          0              0              0               9,050 ( 0.00%)     0              0                 ~_Vector_base() _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
    31,675 ( 0.00%)      0              0              13,575 ( 0.00%)     0              0               4,525 ( 0.00%)     0              0           	_M_deallocate(_M_impl._M_start,
    36,664 ( 0.00%)    411 ( 0.00%)    73 ( 0.00%)     18,100 ( 0.00%)   128 ( 0.00%)    51 ( 0.00%)          0              0              0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
    27,150 ( 0.00%)     48 ( 0.00%)    29 ( 0.00%)     13,575 ( 0.00%)     0              0               4,525 ( 0.00%)     0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .               public:
         .               .              .                   .              .              .                   .              .              .                 _Vector_impl _M_impl;
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 pointer
    29,054 ( 0.00%)  1,457 ( 0.00%)   472 ( 0.00%)          0              0              0              14,550 ( 0.00%)    11 ( 0.00%)     0                 _M_allocate(size_t __n)
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
    32,765 ( 0.00%)    890 ( 0.00%)   300 ( 0.00%)     12,136 ( 0.00%)     0              0               3,643 ( 0.00%)     0              0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
     9,700 ( 0.00%)    734 ( 0.00%)   188 ( 0.00%)      9,700 ( 0.00%)    28 ( 0.00%)     0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 void
    53,469 ( 0.00%)  2,075 ( 0.00%)   363 ( 0.00%)          0              0              0              30,596 ( 0.00%)     0              0                 _M_deallocate(pointer __p, size_t __n)
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
    15,298 ( 0.00%)    276 ( 0.00%)    60 ( 0.00%)      7,649 ( 0.00%)     0              0                   0              0              0           	if (__p)
    21,642 ( 0.00%)     52 ( 0.00%)     0              10,821 ( 0.00%)     0              0               3,607 ( 0.00%)     0              0           	  _Tr::deallocate(_M_impl, __p, __n);
    22,947 ( 0.00%)    246 ( 0.00%)    16 ( 0.00%)     15,298 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .               protected:
         .               .              .                   .              .              .                   .              .              .                 void
    10,356 ( 0.00%)    392 ( 0.00%)    59 ( 0.00%)          0              0              0               5,178 ( 0.00%)     0              0                 _M_create_storage(size_t __n)
         .               .              .                   .              .              .                   .              .              .                 {
    12,082 ( 0.00%)    345 ( 0.00%)    48 ( 0.00%)      5,178 ( 0.00%)     1 ( 0.00%)     0               3,452 ( 0.00%)     4 ( 0.00%)     0           	this->_M_impl._M_start = this->_M_allocate(__n);
     6,904 ( 0.00%)    168 ( 0.00%)    44 ( 0.00%)      5,178 ( 0.00%)     0              0               1,726 ( 0.00%)     0              0           	this->_M_impl._M_finish = this->_M_impl._M_start;
    13,837 ( 0.00%)    483 ( 0.00%)    60 ( 0.00%)      6,904 ( 0.00%)     0              0               1,726 ( 0.00%)     0              0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
     5,178 ( 0.00%)      0              0               3,452 ( 0.00%)     1 ( 0.00%)     0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .               };
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .             /**
         .               .              .                   .              .              .                   .              .              .              *  @brief A standard container which offers fixed time access to
         .               .              .                   .              .              .                   .              .              .              *  individual elements in any order.
         .               .              .                   .              .              .                   .              .              .              *
         .               .              .                   .              .              .                   .              .              .              *  @ingroup sequences
         .               .              .                   .              .              .                   .              .              .              *
-- line 372 ----------------------------------------
-- line 445 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	// Instantiating std::__relocate_a might cause an error outside the
         .               .              .                   .              .              .                   .              .              .           	// immediate context (in __relocate_object_a's noexcept-specifier),
         .               .              .                   .              .              .                   .              .              .           	// so only do it if we know the type can be move-inserted into *this.
         .               .              .                   .              .              .                   .              .              .           	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
         .               .              .                   .              .              .                   .              .              .                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 static pointer
    49,492 ( 0.00%)    457 ( 0.00%)   271 ( 0.00%)          0              0              0              30,990 ( 0.00%)     0              0                 _S_do_relocate(pointer __first, pointer __last, pointer __result,
         .               .              .                   .              .              .                   .              .              .           		     _Tp_alloc_type& __alloc, true_type) noexcept
         .               .              .                   .              .              .                   .              .              .                 {
    37,188 ( 0.00%)  1,453 ( 0.00%)   283 ( 0.00%)     24,792 ( 0.00%)     0              0               6,198 ( 0.00%)     0              0           	return std::__relocate_a(__first, __last, __result, __alloc);
    12,396 ( 0.00%)      0              0              12,396 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 static pointer
         .               .              .                   .              .              .                   .              .              .                 _S_do_relocate(pointer, pointer, pointer __result,
         .               .              .                   .              .              .                   .              .              .           		     _Tp_alloc_type&, false_type) noexcept
         .               .              .                   .              .              .                   .              .              .                 { return __result; }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 static pointer
    49,492 ( 0.00%)     52 ( 0.00%)    42 ( 0.00%)          0              0              0              30,990 ( 0.00%)     0              0                 _S_relocate(pointer __first, pointer __last, pointer __result,
         .               .              .                   .              .              .                   .              .              .           		  _Tp_alloc_type& __alloc) noexcept
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	using __do_it = __bool_constant<_S_use_relocate()>;
    37,188 ( 0.00%)      0              0              24,792 ( 0.00%)     0              0               6,198 ( 0.00%)     0              0           	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
    12,396 ( 0.00%)     35 ( 0.00%)    16 ( 0.00%)     12,396 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           #endif // C++11
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .               protected:
         .               .              .                   .              .              .                   .              .              .                 using _Base::_M_allocate;
         .               .              .                   .              .              .                   .              .              .                 using _Base::_M_deallocate;
         .               .              .                   .              .              .                   .              .              .                 using _Base::_M_impl;
         .               .              .                   .              .              .                   .              .              .                 using _Base::_M_get_Tp_allocator;
         .               .              .                   .              .              .                   .              .              .           
-- line 478 ----------------------------------------
-- line 479 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .               public:
         .               .              .                   .              .              .                   .              .              .                 // [23.2.4.1] construct/copy/destroy
         .               .              .                   .              .              .                   .              .              .                 // (assign() and get_allocator() are also listed in this section)
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Creates a %vector with no elements.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
    28,209 ( 0.00%)  1,649 ( 0.00%)   774 ( 0.01%)      7,701 ( 0.00%)     0              0               7,701 ( 0.00%)     0              0                 vector() = default;
         .               .              .                   .              .              .                   .              .              .           #else
         .               .              .                   .              .              .                   .              .              .                 vector() { }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Creates a %vector with no elements.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __a  An allocator object.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 explicit
       144 ( 0.00%)     24 ( 0.00%)    24 ( 0.00%)          0              0              0                  72 ( 0.00%)     0              0                 vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       192 ( 0.00%)      0              0                  96 ( 0.00%)     0              0                  24 ( 0.00%)     0              0                 : _Base(__a) { }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Creates a %vector with default constructed elements.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __n  The number of elements to initially create.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __a  An allocator.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This constructor fills the %vector with @a __n default
-- line 506 ----------------------------------------
-- line 514 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Creates a %vector with copies of an exemplar element.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __n  The number of elements to initially create.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __value  An element to copy.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __a  An allocator.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This constructor fills the %vector with @a __n copies of @a __value.
         .               .              .                   .              .              .                   .              .              .                  */
       378 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)          0              0              0                 252 ( 0.00%)     0              0                 vector(size_type __n, const value_type& __value,
         .               .              .                   .              .              .                   .              .              .           	     const allocator_type& __a = allocator_type())
       504 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        168 ( 0.00%)     0              0                  84 ( 0.00%)     0              0                 : _Base(_S_check_init_len(__n, __a), __a)
       420 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)        252 ( 0.00%)     0              0                  42 ( 0.00%)     0              0                 { _M_fill_initialize(__n, __value); }
         .               .              .                   .              .              .                   .              .              .           #else
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Creates a %vector with copies of an exemplar element.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __n  The number of elements to initially create.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __value  An element to copy.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __a  An allocator.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 533 ----------------------------------------
-- line 545 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  All the elements of @a __x are copied, but any unused capacity in
         .               .              .                   .              .              .                   .              .              .                  *  @a __x  will not be copied
         .               .              .                   .              .              .                   .              .              .                  *  (i.e. capacity() == size() in the new %vector).
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  The newly-created %vector uses a copy of the allocator object used
         .               .              .                   .              .              .                   .              .              .                  *  by @a __x (unless the allocator traits dictate a different object).
         .               .              .                   .              .              .                   .              .              .                  */
    20,208 ( 0.00%)    828 ( 0.00%)   131 ( 0.00%)      1,684 ( 0.00%)     0              0              11,788 ( 0.00%)    14 ( 0.00%)     0                 vector(const vector& __x)
         .               .              .                   .              .              .                   .              .              .                 : _Base(__x.size(),
    35,364 ( 0.00%)  1,539 ( 0.00%)   183 ( 0.00%)      5,052 ( 0.00%)     0              0               8,420 ( 0.00%)     0              0           	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
         .               .              .                   .              .              .                   .              .              .                 {
     3,368 ( 0.00%)     34 ( 0.00%)    15 ( 0.00%)      1,684 ( 0.00%)     0              0               1,684 ( 0.00%)     0              0           	this->_M_impl._M_finish =
    23,576 ( 0.00%)  1,046 ( 0.00%)   111 ( 0.00%)      6,736 ( 0.00%)     0              0               5,052 ( 0.00%)     0              0           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
         .               .              .                   .              .              .                   .              .              .           				      this->_M_impl._M_start,
     6,736 ( 0.00%)    180 ( 0.00%)    43 ( 0.00%)      1,684 ( 0.00%)     0              0               1,684 ( 0.00%)     0              0           				      _M_get_Tp_allocator());
    16,840 ( 0.00%)  1,246 ( 0.00%)   123 ( 0.00%)     11,788 ( 0.00%)     8 ( 0.00%)     0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  %Vector move constructor.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  The newly-created %vector contains the exact contents of the
         .               .              .                   .              .              .                   .              .              .                  *  moved instance.
         .               .              .                   .              .              .                   .              .              .                  *  The contents of the moved instance are a valid, but unspecified
         .               .              .                   .              .              .                   .              .              .                  *  %vector.
         .               .              .                   .              .              .                   .              .              .                  */
     5,082 ( 0.00%)    257 ( 0.00%)   100 ( 0.00%)      1,452 ( 0.00%)     0              0               1,452 ( 0.00%)     0              0                 vector(vector&&) noexcept = default;
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /// Copy constructor with alternative allocator
         .               .              .                   .              .              .                   .              .              .                 vector(const vector& __x, const allocator_type& __a)
         .               .              .                   .              .              .                   .              .              .                 : _Base(__x.size(), __a)
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	this->_M_impl._M_finish =
         .               .              .                   .              .              .                   .              .              .           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
         .               .              .                   .              .              .                   .              .              .           				      this->_M_impl._M_start,
-- line 580 ----------------------------------------
-- line 670 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  The dtor only erases the elements, and note that if the
         .               .              .                   .              .              .                   .              .              .                  *  elements themselves are pointers, the pointed-to memory is
         .               .              .                   .              .              .                   .              .              .                  *  not touched in any way.  Managing the pointer is the user's
         .               .              .                   .              .              .                   .              .              .                  *  responsibility.
         .               .              .                   .              .              .                   .              .              .                  */
    22,597 ( 0.00%)  1,336 ( 0.00%)   480 ( 0.00%)          0              0              0               9,050 ( 0.00%)     0              0                 ~vector() _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
    31,675 ( 0.00%)    124 ( 0.00%)    43 ( 0.00%)     18,100 ( 0.00%) 1,853 ( 0.00%) 1,540 ( 0.00%)      4,525 ( 0.00%)     0              0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
    18,100 ( 0.00%)    735 ( 0.00%)    76 ( 0.00%)      4,525 ( 0.00%)     0              0               4,525 ( 0.00%)     0              0           		      _M_get_Tp_allocator());
         .               .              .                   .              .              .                   .              .              .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
    27,150 ( 0.00%)     55 ( 0.00%)    20 ( 0.00%)     13,575 ( 0.00%)     0              0               4,525 ( 0.00%)     0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  %Vector assignment operator.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __x  A %vector of identical element and allocator types.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  All the elements of @a __x are copied, but any unused capacity in
         .               .              .                   .              .              .                   .              .              .                  *  @a __x will not be copied.
         .               .              .                   .              .              .                   .              .              .                  *
-- line 691 ----------------------------------------
-- line 701 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  The contents of @a __x are moved into this %vector (without copying,
         .               .              .                   .              .              .                   .              .              .                  *  if the allocators permit it).
         .               .              .                   .              .              .                   .              .              .                  *  Afterwards @a __x is a valid, but unspecified %vector.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  Whether the allocator is moved depends on the allocator traits.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 vector&
       144 ( 0.00%)     24 ( 0.00%)    19 ( 0.00%)          0              0              0                  72 ( 0.00%)     0              0                 operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
         .               .              .                   .              .              .                   .              .              .                 {
        24 ( 0.00%)      0              0                   0              0              0                  24 ( 0.00%)     0              0           	constexpr bool __move_storage =
         .               .              .                   .              .              .                   .              .              .           	  _Alloc_traits::_S_propagate_on_move_assign()
         .               .              .                   .              .              .                   .              .              .           	  || _Alloc_traits::_S_always_equal();
       192 ( 0.00%)     10 ( 0.00%)     7 ( 0.00%)         48 ( 0.00%)     0              0                  48 ( 0.00%)     0              0           	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
        24 ( 0.00%)      0              0                  24 ( 0.00%)     0              0                   0              0              0           	return *this;
        48 ( 0.00%)      0              0                  48 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  %Vector list assignment operator.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __l  An initializer_list.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This function fills a %vector with copies of the elements in the
         .               .              .                   .              .              .                   .              .              .                  *  initializer list @a __l.
         .               .              .                   .              .              .                   .              .              .                  *
-- line 724 ----------------------------------------
-- line 803 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // iterators
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read/write iterator that points to the first
         .               .              .                   .              .              .                   .              .              .                  *  element in the %vector.  Iteration is done in ordinary
         .               .              .                   .              .              .                   .              .              .                  *  element order.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 iterator
    26,988 ( 0.00%)    489 ( 0.00%)   325 ( 0.00%)      3,381 ( 0.00%)     0              0              10,143 ( 0.00%)     0              0                 begin() _GLIBCXX_NOEXCEPT
    37,191 ( 0.00%)    959 ( 0.00%)   592 ( 0.01%)     20,286 ( 0.00%)     0              0               3,381 ( 0.00%)     0              0                 { return iterator(this->_M_impl._M_start); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read-only (constant) iterator that points to the
         .               .              .                   .              .              .                   .              .              .                  *  first element in the %vector.  Iteration is done in ordinary
         .               .              .                   .              .              .                   .              .              .                  *  element order.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 const_iterator
    17,000 ( 0.00%)    421 ( 0.00%)    90 ( 0.00%)      2,125 ( 0.00%)     0              0               6,375 ( 0.00%)     0              0                 begin() const _GLIBCXX_NOEXCEPT
    23,375 ( 0.00%)     70 ( 0.00%)    35 ( 0.00%)     12,750 ( 0.00%)     0              0               2,125 ( 0.00%)     0              0                 { return const_iterator(this->_M_impl._M_start); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read/write iterator that points one past the last
         .               .              .                   .              .              .                   .              .              .                  *  element in the %vector.  Iteration is done in ordinary
         .               .              .                   .              .              .                   .              .              .                  *  element order.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 iterator
   392,709 ( 0.00%)  3,679 ( 0.01%) 1,344 ( 0.01%)     49,106 ( 0.00%)     0              0             147,318 ( 0.01%)    22 ( 0.00%)     0                 end() _GLIBCXX_NOEXCEPT
   589,272 ( 0.00%) 11,700 ( 0.02%)   982 ( 0.01%)    294,636 ( 0.01%)     0              0              49,106 ( 0.00%)     0              0                 { return iterator(this->_M_impl._M_finish); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read-only (constant) iterator that points one past
         .               .              .                   .              .              .                   .              .              .                  *  the last element in the %vector.  Iteration is done in
         .               .              .                   .              .              .                   .              .              .                  *  ordinary element order.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 const_iterator
    16,072 ( 0.00%)  1,773 ( 0.00%)   217 ( 0.00%)      2,009 ( 0.00%)     5 ( 0.00%)     0               6,027 ( 0.00%)    11 ( 0.00%)     0                 end() const _GLIBCXX_NOEXCEPT
    24,108 ( 0.00%)    962 ( 0.00%)   116 ( 0.00%)     12,054 ( 0.00%)     0              0               2,009 ( 0.00%)     0              0                 { return const_iterator(this->_M_impl._M_finish); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read/write reverse iterator that points to the
         .               .              .                   .              .              .                   .              .              .                  *  last element in the %vector.  Iteration is done in reverse
         .               .              .                   .              .              .                   .              .              .                  *  element order.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 reverse_iterator
         .               .              .                   .              .              .                   .              .              .                 rbegin() _GLIBCXX_NOEXCEPT
-- line 847 ----------------------------------------
-- line 910 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                 const_reverse_iterator
         .               .              .                   .              .              .                   .              .              .                 crend() const noexcept
         .               .              .                   .              .              .                   .              .              .                 { return const_reverse_iterator(begin()); }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // [23.2.4.2] capacity
         .               .              .                   .              .              .                   .              .              .                 /**  Returns the number of elements in the %vector.  */
         .               .              .                   .              .              .                   .              .              .                 size_type
10,660,174 ( 0.08%)  3,067 ( 0.00%) 1,124 ( 0.01%)          0              0              0           5,330,186 ( 0.19%)     3 ( 0.00%)     0                 size() const _GLIBCXX_NOEXCEPT
31,437,825 ( 0.24%)  2,022 ( 0.00%)   593 ( 0.01%) 15,990,558 ( 0.47%) 3,395 ( 0.00%) 2,803 ( 0.00%)          0              0              0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**  Returns the size() of the largest possible %vector.  */
         .               .              .                   .              .              .                   .              .              .                 size_type
    31,108 ( 0.00%)  1,073 ( 0.00%)   673 ( 0.01%)          0              0              0              12,480 ( 0.00%)     1 ( 0.00%)     0                 max_size() const _GLIBCXX_NOEXCEPT
    43,680 ( 0.00%)  1,506 ( 0.00%)   306 ( 0.00%)     18,720 ( 0.00%)     0              0              12,480 ( 0.00%)     0              0                 { return _S_max_size(_M_get_Tp_allocator()); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Resizes the %vector to the specified number of elements.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __new_size  Number of elements the %vector should contain.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This function will %resize the %vector to the specified
         .               .              .                   .              .              .                   .              .              .                  *  number of elements.  If the number is smaller than the
         .               .              .                   .              .              .                   .              .              .                  *  %vector's current size the %vector is truncated, otherwise
         .               .              .                   .              .              .                   .              .              .                  *  default constructed elements are appended.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 void
       282 ( 0.00%)     38 ( 0.00%)    26 ( 0.00%)          0              0              0                 141 ( 0.00%)     0              0                 resize(size_type __new_size)
         .               .              .                   .              .              .                   .              .              .                 {
       329 ( 0.00%)     33 ( 0.00%)    21 ( 0.00%)         94 ( 0.00%)     0              0                  47 ( 0.00%)     0              0           	if (__new_size > size())
       154 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)         42 ( 0.00%)     0              0                  28 ( 0.00%)     0              0           	  _M_default_append(__new_size - size());
       231 ( 0.00%)     33 ( 0.00%)    21 ( 0.00%)         66 ( 0.00%)     0              0                  33 ( 0.00%)     0              0           	else if (__new_size < size())
        90 ( 0.00%)      0              0                  40 ( 0.00%)     0              0                  10 ( 0.00%)     0              0           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
       155 ( 0.00%)      0              0                  94 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Resizes the %vector to the specified number of elements.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __new_size  Number of elements the %vector should contain.
         .               .              .                   .              .              .                   .              .              .                  *  @param  __x  Data with which new elements should be populated.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This function will %resize the %vector to the specified
         .               .              .                   .              .              .                   .              .              .                  *  number of elements.  If the number is smaller than the
-- line 951 ----------------------------------------
-- line 990 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                 { _M_shrink_to_fit(); }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns the total number of elements that the %vector can
         .               .              .                   .              .              .                   .              .              .                  *  hold before needing to allocate more memory.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 size_type
       188 ( 0.00%)     33 ( 0.00%)    11 ( 0.00%)          0              0              0                  94 ( 0.00%)     0              0                 capacity() const _GLIBCXX_NOEXCEPT
        94 ( 0.00%)      0              0                  94 ( 0.00%)    33 ( 0.00%)     0                   0              0              0                 { return size_type(this->_M_impl._M_end_of_storage
       470 ( 0.00%)     47 ( 0.00%)    12 ( 0.00%)        188 ( 0.00%)     0              0                   0              0              0           			 - this->_M_impl._M_start); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns true if the %vector is empty.  (Thus begin() would
         .               .              .                   .              .              .                   .              .              .                  *  equal end().)
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 _GLIBCXX_NODISCARD bool
         .               .              .                   .              .              .                   .              .              .                 empty() const _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 { return begin() == end(); }
-- line 1008 ----------------------------------------
-- line 1035 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                  *  @return  Read/write reference to data.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This operator allows for easy, array-style, data access.
         .               .              .                   .              .              .                   .              .              .                  *  Note that data access with this operator is unchecked and
         .               .              .                   .              .              .                   .              .              .                  *  out_of_range lookups are not defined. (For checked lookups
         .               .              .                   .              .              .                   .              .              .                  *  see at().)
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 reference
   981,940 ( 0.01%)  1,410 ( 0.00%)   175 ( 0.00%)          0              0              0             589,182 ( 0.02%)     0              0                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	__glibcxx_requires_subscript(__n);
   992,219 ( 0.01%)  3,997 ( 0.01%)   234 ( 0.00%)    589,182 ( 0.02%)     0              0                   0              0              0           	return *(this->_M_impl._M_start + __n);
   392,788 ( 0.00%)      0              0             392,788 ( 0.01%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  @brief  Subscript access to the data contained in the %vector.
         .               .              .                   .              .              .                   .              .              .                  *  @param __n The index of the element for which data should be
         .               .              .                   .              .              .                   .              .              .                  *  accessed.
         .               .              .                   .              .              .                   .              .              .                  *  @return  Read-only (constant) reference to data.
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This operator allows for easy, array-style, data access.
         .               .              .                   .              .              .                   .              .              .                  *  Note that data access with this operator is unchecked and
         .               .              .                   .              .              .                   .              .              .                  *  out_of_range lookups are not defined. (For checked lookups
         .               .              .                   .              .              .                   .              .              .                  *  see at().)
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 const_reference
44,110,665 ( 0.34%) 10,215 ( 0.02%) 1,098 ( 0.01%)          0              0              0          26,466,399 ( 0.93%)     0              0                 operator[](size_type __n) const _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	__glibcxx_requires_subscript(__n);
70,054,395 ( 0.54%)      0              0          26,466,399 ( 0.78%)     1 ( 0.00%)     0                   0              0              0           	return *(this->_M_impl._M_start + __n);
17,644,266 ( 0.14%)     13 ( 0.00%)     4 ( 0.00%) 17,644,266 ( 0.52%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .               protected:
         .               .              .                   .              .              .                   .              .              .                 /// Safety check used only from at().
         .               .              .                   .              .              .                   .              .              .                 void
         .               .              .                   .              .              .                   .              .              .                 _M_range_check(size_type __n) const
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	if (__n >= this->size())
         .               .              .                   .              .              .                   .              .              .           	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
-- line 1073 ----------------------------------------
-- line 1113 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .           	return (*this)[__n];
         .               .              .                   .              .              .                   .              .              .                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read/write reference to the data at the first
         .               .              .                   .              .              .                   .              .              .                  *  element of the %vector.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 reference
       168 ( 0.00%)     19 ( 0.00%)    19 ( 0.00%)         21 ( 0.00%)     0              0                  63 ( 0.00%)     0              0                 front() _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	__glibcxx_requires_nonempty();
       147 ( 0.00%)      0              0                  21 ( 0.00%)     0              0                  63 ( 0.00%)     0              0           	return *begin();
       105 ( 0.00%)     19 ( 0.00%)    19 ( 0.00%)         84 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read-only (constant) reference to the data at the first
         .               .              .                   .              .              .                   .              .              .                  *  element of the %vector.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 const_reference
     1,680 ( 0.00%)    128 ( 0.00%)    23 ( 0.00%)        210 ( 0.00%)     0              0                 630 ( 0.00%)     0              0                 front() const _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	__glibcxx_requires_nonempty();
     1,470 ( 0.00%)     13 ( 0.00%)     0                 210 ( 0.00%)     0              0                 630 ( 0.00%)     0              0           	return *begin();
     1,050 ( 0.00%)     57 ( 0.00%)    13 ( 0.00%)        840 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read/write reference to the data at the last
         .               .              .                   .              .              .                   .              .              .                  *  element of the %vector.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 reference
   365,889 ( 0.00%)  6,486 ( 0.01%)   645 ( 0.01%)     45,746 ( 0.00%)     0              0             137,238 ( 0.00%)     0              0                 back() _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	__glibcxx_requires_nonempty();
   548,952 ( 0.00%)  2,960 ( 0.00%)   631 ( 0.01%)     45,746 ( 0.00%)     0              0             228,730 ( 0.01%)     0              0           	return *(end() - 1);
   228,730 ( 0.00%)  1,540 ( 0.00%)   402 ( 0.00%)    182,984 ( 0.01%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Returns a read-only (constant) reference to the data at the
         .               .              .                   .              .              .                   .              .              .                  *  last element of the %vector.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 const_reference
       752 ( 0.00%)    118 ( 0.00%)    25 ( 0.00%)         94 ( 0.00%)     0              0                 282 ( 0.00%)     0              0                 back() const _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	__glibcxx_requires_nonempty();
     1,128 ( 0.00%)      0              0                  94 ( 0.00%)     0              0                 470 ( 0.00%)     0              0           	return *(end() - 1);
       470 ( 0.00%)     61 ( 0.00%)    12 ( 0.00%)        376 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .               .              .                   .              .              .                   .              .              .                 // DR 464. Suggestion for new member functions in standard containers.
         .               .              .                   .              .              .                   .              .              .                 // data access
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *   Returns a pointer such that [data(), data() + size()) is a valid
         .               .              .                   .              .              .                   .              .              .                  *   range.  For a non-empty %vector, data() == &front().
         .               .              .                   .              .              .                   .              .              .                  */
-- line 1166 ----------------------------------------
-- line 1179 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                  *
         .               .              .                   .              .              .                   .              .              .                  *  This is a typical stack operation.  The function creates an
         .               .              .                   .              .              .                   .              .              .                  *  element at the end of the %vector and assigns the given data
         .               .              .                   .              .              .                   .              .              .                  *  to it.  Due to the nature of a %vector this operation can be
         .               .              .                   .              .              .                   .              .              .                  *  done in constant time if the %vector has preallocated space
         .               .              .                   .              .              .                   .              .              .                  *  available.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 void
   225,936 ( 0.00%)  9,744 ( 0.02%)   661 ( 0.01%)          0              0              0             112,968 ( 0.00%)     0              0                 push_back(const value_type& __x)
         .               .              .                   .              .              .                   .              .              .                 {
   225,936 ( 0.00%)    211 ( 0.00%)   155 ( 0.00%)    150,624 ( 0.00%)     6 ( 0.00%)     0                   0              0              0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
         .               .              .                   .              .              .                   .              .              .           	  {
         .               .              .                   .              .              .                   .              .              .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
   246,799 ( 0.00%)  1,140 ( 0.00%)   189 ( 0.00%)    141,028 ( 0.00%)     0              0              35,257 ( 0.00%)     0              0           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         .               .              .                   .              .              .                   .              .              .           				     __x);
   176,285 ( 0.00%)     14 ( 0.00%)     0             105,771 ( 0.00%)     0              0              35,257 ( 0.00%)     0              0           	    ++this->_M_impl._M_finish;
         .               .              .                   .              .              .                   .              .              .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
         .               .              .                   .              .              .                   .              .              .           	  }
         .               .              .                   .              .              .                   .              .              .           	else
    21,591 ( 0.00%)  1,038 ( 0.00%)   437 ( 0.00%)      7,197 ( 0.00%)     0              0               4,798 ( 0.00%)     0              0           	  _M_realloc_insert(end(), __x);
   148,225 ( 0.00%)    525 ( 0.00%)   483 ( 0.00%)     75,312 ( 0.00%)     1 ( 0.00%)     0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
         .               .              .                   .              .              .                   .              .              .                 void
    18,018 ( 0.00%)    411 ( 0.00%)   371 ( 0.00%)          0              0              0               9,009 ( 0.00%)     0              0                 push_back(value_type&& __x)
    33,033 ( 0.00%)    170 ( 0.00%)   129 ( 0.00%)     12,012 ( 0.00%)     0              0               6,006 ( 0.00%)     0              0                 { emplace_back(std::move(__x)); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 template<typename... _Args>
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus > 201402L
         .               .              .                   .              .              .                   .              .              .           	reference
         .               .              .                   .              .              .                   .              .              .           #else
         .               .              .                   .              .              .                   .              .              .           	void
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           	emplace_back(_Args&&... __args);
-- line 1212 ----------------------------------------
-- line 1490 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Erases all the elements.  Note that this function only erases the
         .               .              .                   .              .              .                   .              .              .                  *  elements, and that if the elements themselves are pointers, the
         .               .              .                   .              .              .                   .              .              .                  *  pointed-to memory is not touched in any way.  Managing the pointer is
         .               .              .                   .              .              .                   .              .              .                  *  the user's responsibility.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 void
     2,715 ( 0.00%)    432 ( 0.00%)   367 ( 0.00%)          0              0              0               1,086 ( 0.00%)     0              0                 clear() _GLIBCXX_NOEXCEPT
     4,887 ( 0.00%)    289 ( 0.00%)   247 ( 0.00%)      2,715 ( 0.00%)    38 ( 0.00%)    11 ( 0.00%)        543 ( 0.00%)     0              0                 { _M_erase_at_end(this->_M_impl._M_start); }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .               protected:
         .               .              .                   .              .              .                   .              .              .                 /**
         .               .              .                   .              .              .                   .              .              .                  *  Memory expansion handler.  Uses the member allocation function to
         .               .              .                   .              .              .                   .              .              .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
         .               .              .                   .              .              .                   .              .              .                  */
         .               .              .                   .              .              .                   .              .              .                 template<typename _ForwardIterator>
         .               .              .                   .              .              .                   .              .              .           	pointer
        99 ( 0.00%)     11 ( 0.00%)    11 ( 0.00%)          0              0              0                  66 ( 0.00%)     0              0           	_M_allocate_and_copy(size_type __n,
         .               .              .                   .              .              .                   .              .              .           			     _ForwardIterator __first, _ForwardIterator __last)
         .               .              .                   .              .              .                   .              .              .           	{
        66 ( 0.00%)      0              0                  22 ( 0.00%)     0              0                  22 ( 0.00%)     0              0           	  pointer __result = this->_M_allocate(__n);
         .               .              .                   .              .              .                   .              .              .           	  __try
         .               .              .                   .              .              .                   .              .              .           	    {
        55 ( 0.00%)     11 ( 0.00%)    11 ( 0.00%)         33 ( 0.00%)     0              0                  11 ( 0.00%)     0              0           	      std::__uninitialized_copy_a(__first, __last, __result,
        44 ( 0.00%)      0              0                  11 ( 0.00%)     0              0                  11 ( 0.00%)     0              0           					  _M_get_Tp_allocator());
        22 ( 0.00%)      0              0                  11 ( 0.00%)     0              0                   0              0              0           	      return __result;
         .               .              .                   .              .              .                   .              .              .           	    }
         .               .              .                   .              .              .                   .              .              .           	  __catch(...)
         .               .              .                   .              .              .                   .              .              .           	    {
         .               .              .                   .              .              .                   .              .              .           	      _M_deallocate(__result, __n);
         .               .              .                   .              .              .                   .              .              .           	      __throw_exception_again;
         .               .              .                   .              .              .                   .              .              .           	    }
        33 ( 0.00%)     11 ( 0.00%)     9 ( 0.00%)         33 ( 0.00%)    11 ( 0.00%)     0                   0              0              0           	}
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Internal constructor functions follow.
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Called by the range constructor to implement [23.1.1]/9
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus < 201103L
         .               .              .                   .              .              .                   .              .              .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1531 ----------------------------------------
-- line 1585 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .           	    std::__uninitialized_copy_a(__first, __last,
         .               .              .                   .              .              .                   .              .              .           					this->_M_impl._M_start,
         .               .              .                   .              .              .                   .              .              .           					_M_get_Tp_allocator());
         .               .              .                   .              .              .                   .              .              .           	}
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Called by the first initialize_dispatch above and by the
         .               .              .                   .              .              .                   .              .              .                 // vector(n,value,a) constructor.
         .               .              .                   .              .              .                   .              .              .                 void
       294 ( 0.00%)     56 ( 0.00%)    56 ( 0.00%)          0              0              0                 168 ( 0.00%)     0              0                 _M_fill_initialize(size_type __n, const value_type& __value)
         .               .              .                   .              .              .                   .              .              .                 {
        84 ( 0.00%)      0              0                  42 ( 0.00%)     0              0                  42 ( 0.00%)     0              0           	this->_M_impl._M_finish =
       252 ( 0.00%)      0              0                 168 ( 0.00%)     0              0                  42 ( 0.00%)     0              0           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
       168 ( 0.00%)      0              0                  42 ( 0.00%)     0              0                  42 ( 0.00%)     0              0           					_M_get_Tp_allocator());
       126 ( 0.00%)      0              0                  84 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
         .               .              .                   .              .              .                   .              .              .                 // Called by the vector(n) constructor.
         .               .              .                   .              .              .                   .              .              .                 void
         .               .              .                   .              .              .                   .              .              .                 _M_default_initialize(size_type __n)
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	this->_M_impl._M_finish =
         .               .              .                   .              .              .                   .              .              .           	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
-- line 1606 ----------------------------------------
-- line 1748 ----------------------------------------
         .               .              .                   .              .              .                   .              .              .                 // Emplacing an rvalue of the correct type can use _M_insert_rval.
         .               .              .                   .              .              .                   .              .              .                 iterator
         .               .              .                   .              .              .                   .              .              .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
         .               .              .                   .              .              .                   .              .              .                 { return _M_insert_rval(__position, std::move(__v)); }
         .               .              .                   .              .              .                   .              .              .           #endif
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Called by _M_fill_insert, _M_insert_aux etc.
         .               .              .                   .              .              .                   .              .              .                 size_type
    34,043 ( 0.00%)    732 ( 0.00%)   368 ( 0.00%)      3,099 ( 0.00%)     0              0              18,594 ( 0.00%)     0              0                 _M_check_len(size_type __n, const char* __s) const
         .               .              .                   .              .              .                   .              .              .                 {
    43,386 ( 0.00%)  1,863 ( 0.00%)   518 ( 0.00%)      9,297 ( 0.00%)     0              0               6,198 ( 0.00%)     0              0           	if (max_size() - size() < __n)
         .               .              .                   .              .              .                   .              .              .           	  __throw_length_error(__N(__s));
         .               .              .                   .              .              .                   .              .              .           
    49,584 ( 0.00%)  2,210 ( 0.00%)   699 ( 0.01%)      9,297 ( 0.00%)     0              0              15,495 ( 0.00%)     0              0           	const size_type __len = size() + (std::max)(size(), __n);
    34,089 ( 0.00%)  1,915 ( 0.00%)   549 ( 0.01%)     15,495 ( 0.00%)     0              0               6,198 ( 0.00%)     0              0           	return (__len < size() || __len > max_size()) ? max_size() : __len;
    18,594 ( 0.00%)    563 ( 0.00%)   448 ( 0.00%)     15,495 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Called by constructors to check initial size.
         .               .              .                   .              .              .                   .              .              .                 static size_type
       420 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)         42 ( 0.00%)     0              0                 210 ( 0.00%)     0              0                 _S_check_init_len(size_type __n, const allocator_type& __a)
         .               .              .                   .              .              .                   .              .              .                 {
       630 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)         84 ( 0.00%)     0              0                 126 ( 0.00%)     0              0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
         .               .              .                   .              .              .                   .              .              .           	  __throw_length_error(
         .               .              .                   .              .              .                   .              .              .           	      __N("cannot create std::vector larger than max_size()"));
        42 ( 0.00%)      0              0                  42 ( 0.00%)     0              0                   0              0              0           	return __n;
       252 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)        210 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 static size_type
    50,164 ( 0.00%)  3,468 ( 0.01%)   890 ( 0.01%)      6,282 ( 0.00%)     0              0              18,846 ( 0.00%)     1 ( 0.00%)     0                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
         .               .              .                   .              .              .                   .              .              .           	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
         .               .              .                   .              .              .                   .              .              .           	// (even if std::allocator_traits::max_size says we can).
    12,564 ( 0.00%)    259 ( 0.00%)   138 ( 0.00%)          0              0              0               6,282 ( 0.00%)     0              0           	const size_t __diffmax
         .               .              .                   .              .              .                   .              .              .           	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
    25,128 ( 0.00%)    136 ( 0.00%)    79 ( 0.00%)      6,282 ( 0.00%)     0              0              12,564 ( 0.00%)     0              0           	const size_t __allocmax = _Alloc_traits::max_size(__a);
    37,692 ( 0.00%)      0              0               6,282 ( 0.00%)     0              0               6,282 ( 0.00%)     0              0           	return (std::min)(__diffmax, __allocmax);
    31,410 ( 0.00%)     71 ( 0.00%)    66 ( 0.00%)     25,128 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Internal erase functions follow.
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
         .               .              .                   .              .              .                   .              .              .                 // _M_assign_aux.
         .               .              .                   .              .              .                   .              .              .                 void
     3,318 ( 0.00%)    820 ( 0.00%)   622 ( 0.01%)          0              0              0               1,659 ( 0.00%)     3 ( 0.00%)     0                 _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
         .               .              .                   .              .              .                   .              .              .                 {
     5,290 ( 0.00%)     52 ( 0.00%)    51 ( 0.00%)      2,212 ( 0.00%)    11 ( 0.00%)    11 ( 0.00%)        553 ( 0.00%)     0              0           	if (size_type __n = this->_M_impl._M_finish - __pos)
         .               .              .                   .              .              .                   .              .              .           	  {
     1,980 ( 0.00%)      0              0                 990 ( 0.00%)     0              0                 330 ( 0.00%)     0              0           	    std::_Destroy(__pos, this->_M_impl._M_finish,
     1,320 ( 0.00%)    246 ( 0.00%)   206 ( 0.00%)        330 ( 0.00%)     0              0                 330 ( 0.00%)     0              0           			  _M_get_Tp_allocator());
       990 ( 0.00%)     10 ( 0.00%)    10 ( 0.00%)        660 ( 0.00%)     0              0                 330 ( 0.00%)     0              0           	    this->_M_impl._M_finish = __pos;
         .               .              .                   .              .              .                   .              .              .           	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
         .               .              .                   .              .              .                   .              .              .           	  }
     1,659 ( 0.00%)    160 ( 0.00%)    89 ( 0.00%)      1,106 ( 0.00%)     0              0                   0              0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 iterator
         .               .              .                   .              .              .                   .              .              .                 _M_erase(iterator __position);
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 iterator
         .               .              .                   .              .              .                   .              .              .                 _M_erase(iterator __first, iterator __last);
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .           #if __cplusplus >= 201103L
         .               .              .                   .              .              .                   .              .              .               private:
         .               .              .                   .              .              .                   .              .              .                 // Constant-time move assignment when source object's memory can be
         .               .              .                   .              .              .                   .              .              .                 // moved, either because the source's allocator will move too
         .               .              .                   .              .              .                   .              .              .                 // or because the allocators are equal.
         .               .              .                   .              .              .                   .              .              .                 void
       240 ( 0.00%)     24 ( 0.00%)    24 ( 0.00%)         24 ( 0.00%)     0              0                 120 ( 0.00%)     0              0                 _M_move_assign(vector&& __x, true_type) noexcept
         .               .              .                   .              .              .                   .              .              .                 {
       312 ( 0.00%)     10 ( 0.00%)    10 ( 0.00%)         24 ( 0.00%)     0              0                  72 ( 0.00%)     0              0           	vector __tmp(get_allocator());
       120 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)         48 ( 0.00%)     0              0                  24 ( 0.00%)     0              0           	this->_M_impl._M_swap_data(__x._M_impl);
       120 ( 0.00%)      0              0                  24 ( 0.00%)     0              0                  24 ( 0.00%)     0              0           	__tmp._M_impl._M_swap_data(__x._M_impl);
       240 ( 0.00%)     24 ( 0.00%)    21 ( 0.00%)         48 ( 0.00%)     0              0                  72 ( 0.00%)     0              0           	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
       216 ( 0.00%)      0              0                 120 ( 0.00%)     0              0                  24 ( 0.00%)     0              0                 }
         .               .              .                   .              .              .                   .              .              .           
         .               .              .                   .              .              .                   .              .              .                 // Do move assignment when it might not be possible to move source
         .               .              .                   .              .              .                   .              .              .                 // object's memory, resulting in a linear-time operation.
         .               .              .                   .              .              .                   .              .              .                 void
         .               .              .                   .              .              .                   .              .              .                 _M_move_assign(vector&& __x, false_type)
         .               .              .                   .              .              .                   .              .              .                 {
         .               .              .                   .              .              .                   .              .              .           	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
         .               .              .                   .              .              .                   .              .              .           	  _M_move_assign(std::move(__x), true_type());
-- line 1829 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/Matrix.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                 D1mr       DLmr       Dw                 D1mw         DLmw        

-- line 170 ----------------------------------------
         .               .              .                  .          .          .                  .            .           .             * Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two
         .               .              .                  .          .          .                  .            .           .             * smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.
         .               .              .                  .          .          .                  .            .           .             *
         .               .              .                  .          .          .                  .            .           .             * \see MatrixBase for the majority of the API methods for matrices, \ref TopicClassHierarchy,
         .               .              .                  .          .          .                  .            .           .             * \ref TopicStorageOrders
         .               .              .                  .          .          .                  .            .           .             */
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .           template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
    24,948 ( 0.00%)    608 ( 0.00%)   189 ( 0.00%)     6,804 ( 0.00%) 0          0              6,804 ( 0.00%)   0           0           class Matrix
         .               .              .                  .          .          .                  .            .           .             : public PlainObjectBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
         .               .              .                  .          .          .                  .            .           .           {
         .               .              .                  .          .          .                  .            .           .             public:
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /** \brief Base class typedef.
         .               .              .                  .          .          .                  .            .           .                 * \sa PlainObjectBase
         .               .              .                  .          .          .                  .            .           .                 */
         .               .              .                  .          .          .                  .            .           .               typedef PlainObjectBase<Matrix> Base;
-- line 186 ----------------------------------------
-- line 198 ----------------------------------------
         .               .              .                  .          .          .                  .            .           .                 * \brief Assigns matrices to each other.
         .               .              .                  .          .          .                  .            .           .                 *
         .               .              .                  .          .          .                  .            .           .                 * \note This is a special case of the templated operator=. Its purpose is
         .               .              .                  .          .          .                  .            .           .                 * to prevent a default operator= from hiding the templated operator=.
         .               .              .                  .          .          .                  .            .           .                 *
         .               .              .                  .          .          .                  .            .           .                 * \callgraph
         .               .              .                  .          .          .                  .            .           .                 */
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
   107,370 ( 0.00%)  1,260 ( 0.00%)   109 ( 0.00%)         0          0          0             53,685 ( 0.00%)   0           0               EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)
         .               .              .                  .          .          .                  .            .           .               {
    89,475 ( 0.00%)    306 ( 0.00%)   207 ( 0.00%)    35,790 ( 0.00%) 0          0             17,895 ( 0.00%)   0           0                 return Base::_set(other);
    35,790 ( 0.00%)      0              0             35,790 ( 0.00%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /** \internal
         .               .              .                  .          .          .                  .            .           .                 * \brief Copies the value of the expression \a other into \c *this with automatic resizing.
         .               .              .                  .          .          .                  .            .           .                 *
         .               .              .                  .          .          .                  .            .           .                 * *this might be resized to match the dimensions of \a other. If *this was a null matrix (not already initialized),
         .               .              .                  .          .          .                  .            .           .                 * it will be initialized.
         .               .              .                  .          .          .                  .            .           .                 *
         .               .              .                  .          .          .                  .            .           .                 * Note that copying a row-vector into a vector (and conversely) is allowed.
         .               .              .                  .          .          .                  .            .           .                 * The resizing, if any, is then done in the appropriate way so that row-vectors
         .               .              .                  .          .          .                  .            .           .                 * remain row-vectors and vectors remain vectors.
         .               .              .                  .          .          .                  .            .           .                 */
         .               .              .                  .          .          .                  .            .           .               template<typename OtherDerived>
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
   338,304 ( 0.00%) 34,205 ( 0.06%)   907 ( 0.01%)         0          0          0            169,152 ( 0.01%)   0           0               EIGEN_STRONG_INLINE Matrix& operator=(const DenseBase<OtherDerived>& other)
         .               .              .                  .          .          .                  .            .           .               {
   281,920 ( 0.00%) 17,714 ( 0.03%)   488 ( 0.00%)   112,768 ( 0.00%) 0          0             56,384 ( 0.00%)   0           0                 return Base::_set(other);
   112,768 ( 0.00%)    619 ( 0.00%)   461 ( 0.00%)   112,768 ( 0.00%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /* Here, doxygen failed to copy the brief information when using \copydoc */
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /**
         .               .              .                  .          .          .                  .            .           .                 * \brief Copies the generic expression \a other into *this.
         .               .              .                  .          .          .                  .            .           .                 * \copydetails DenseBase::operator=(const EigenBase<OtherDerived> &other)
         .               .              .                  .          .          .                  .            .           .                 */
         .               .              .                  .          .          .                  .            .           .               template<typename OtherDerived>
-- line 234 ----------------------------------------
-- line 251 ----------------------------------------
         .               .              .                  .          .          .                  .            .           .                 *
         .               .              .                  .          .          .                  .            .           .                 * For dynamic-size matrices, creates an empty matrix of size 0. Does not allocate any array. Such a matrix
         .               .              .                  .          .          .                  .            .           .                 * is called a null matrix. This constructor is the unique way to create null matrices: resizing
         .               .              .                  .          .          .                  .            .           .                 * a matrix to 0 is not supported.
         .               .              .                  .          .          .                  .            .           .                 *
         .               .              .                  .          .          .                  .            .           .                 * \sa resize(Index,Index)
         .               .              .                  .          .          .                  .            .           .                 */
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
   449,384 ( 0.00%)  4,152 ( 0.01%) 1,614 ( 0.02%)    56,173 ( 0.00%) 0          0            168,519 ( 0.01%) 419 ( 0.00%)  0               EIGEN_STRONG_INLINE Matrix() : Base()
         .               .              .                  .          .          .                  .            .           .               {
    56,173 ( 0.00%)    449 ( 0.00%)   427 ( 0.00%)         0          0          0             56,173 ( 0.00%)   0           0                 Base::_check_template_params();
         .               .              .                  .          .          .                  .            .           .                 EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
   168,519 ( 0.00%)      0              0            112,346 ( 0.00%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               // FIXME is it still needed
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                  .          .          .                  .            .           .               explicit Matrix(internal::constructor_without_unaligned_array_assert)
         .               .              .                  .          .          .                  .            .           .                 : Base(internal::constructor_without_unaligned_array_assert())
         .               .              .                  .          .          .                  .            .           .               { Base::_check_template_params(); EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .           #if EIGEN_HAS_RVALUE_REFERENCES
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
   374,290 ( 0.00%)  1,174 ( 0.00%)   924 ( 0.01%)         0          0          0            213,880 ( 0.01%)   1 ( 0.00%)  0               Matrix(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)
   374,290 ( 0.00%)      0              0            106,940 ( 0.00%) 0          0            106,940 ( 0.00%)   0           0                 : Base(std::move(other))
         .               .              .                  .          .          .                  .            .           .               {
    53,470 ( 0.00%)      0              0                  0          0          0             53,470 ( 0.00%)   0           0                 Base::_check_template_params();
   213,880 ( 0.00%)      0              0            160,410 ( 0.00%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
   292,308 ( 0.00%)  5,998 ( 0.01%)   704 ( 0.01%)         0          0          0            146,154 ( 0.01%)   0           0               Matrix& operator=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)
         .               .              .                  .          .          .                  .            .           .               {
   243,590 ( 0.00%)      0              0             97,436 ( 0.00%) 0          0             48,718 ( 0.00%)   0           0                 other.swap(*this);
    48,718 ( 0.00%)      0              0             48,718 ( 0.00%) 0          0                  0            0           0                 return *this;
    97,436 ( 0.00%)      0              0             97,436 ( 0.00%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .           #endif
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               #ifndef EIGEN_PARSED_BY_DOXYGEN
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               // This constructor is for both 1x1 matrices and dynamic vectors
         .               .              .                  .          .          .                  .            .           .               template<typename T>
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
    11,979 ( 0.00%)    567 ( 0.00%)   567 ( 0.01%)         0          0          0              6,462 ( 0.00%)   0           0               EIGEN_STRONG_INLINE explicit Matrix(const T& x)
     5,517 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     1,839 ( 0.00%) 0          0              1,839 ( 0.00%)   0           0               {
     1,839 ( 0.00%)      0              0                  0          0          0              1,839 ( 0.00%)   0           0                 Base::_check_template_params();
    10,518 ( 0.00%)    638 ( 0.00%)   427 ( 0.00%)     4,245 ( 0.00%) 0          0              1,839 ( 0.00%)   0           0                 Base::template _init1<T>(x);
     6,462 ( 0.00%)    570 ( 0.00%)   567 ( 0.01%)     4,623 ( 0.00%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               template<typename T0, typename T1>
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
   661,738 ( 0.01%)  2,489 ( 0.00%) 1,035 ( 0.01%)         0          0          0            378,298 ( 0.01%)   0           0               EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)
   283,440 ( 0.00%)    348 ( 0.00%)   212 ( 0.00%)    94,480 ( 0.00%) 0          0             94,480 ( 0.00%)   0           0               {
    94,480 ( 0.00%)      0              0                  0          0          0             94,480 ( 0.00%)   0           0                 Base::_check_template_params();
   568,014 ( 0.00%)  2,001 ( 0.00%)   634 ( 0.01%)   284,196 ( 0.01%) 0          0             94,480 ( 0.00%)   0           0                 Base::template _init2<T0,T1>(x, y);
   283,818 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)   189,338 ( 0.01%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .               #else
         .               .              .                  .          .          .                  .            .           .               /** \brief Constructs a fixed-sized matrix initialized with coefficients starting at \a data */
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                  .          .          .                  .            .           .               explicit Matrix(const Scalar *data);
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /** \brief Constructs a vector or row-vector with given dimension. \only_for_vectors
         .               .              .                  .          .          .                  .            .           .                 *
         .               .              .                  .          .          .                  .            .           .                 * This is useful for dynamic-size vectors. For fixed-size vectors,
-- line 311 ----------------------------------------
-- line 337 ----------------------------------------
         .               .              .                  .          .          .                  .            .           .               Matrix(Index rows, Index cols);
         .               .              .                  .          .          .                  .            .           .               
         .               .              .                  .          .          .                  .            .           .               /** \brief Constructs an initialized 2D vector with given coefficients */
         .               .              .                  .          .          .                  .            .           .               Matrix(const Scalar& x, const Scalar& y);
         .               .              .                  .          .          .                  .            .           .               #endif
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /** \brief Constructs an initialized 3D vector with given coefficients */
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
    78,720 ( 0.00%)  2,499 ( 0.00%)   854 ( 0.01%)         0          0          0             49,200 ( 0.00%)   0           0               EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    29,520 ( 0.00%)      0              0              9,840 ( 0.00%) 0          0              9,840 ( 0.00%)   0           0               {
     9,840 ( 0.00%)      0              0                  0          0          0              9,840 ( 0.00%)   0           0                 Base::_check_template_params();
         .               .              .                  .          .          .                  .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
    78,720 ( 0.00%)  1,670 ( 0.00%)   427 ( 0.00%)    39,360 ( 0.00%) 0          0             29,520 ( 0.00%) 428 ( 0.00%)  6 ( 0.00%)        m_storage.data()[0] = x;
    88,560 ( 0.00%)      0              0             39,360 ( 0.00%) 0          0             29,520 ( 0.00%)   0           0                 m_storage.data()[1] = y;
    88,560 ( 0.00%)    696 ( 0.00%)   426 ( 0.00%)    39,360 ( 0.00%) 0          0             29,520 ( 0.00%)  22 ( 0.00%)  0                 m_storage.data()[2] = z;
    29,520 ( 0.00%)      0              0             19,680 ( 0.00%) 0          0                  0            0           0               }
         .               .              .                  .          .          .                  .            .           .               /** \brief Constructs an initialized 4D vector with given coefficients */
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                  .          .          .                  .            .           .               EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
         .               .              .                  .          .          .                  .            .           .               {
         .               .              .                  .          .          .                  .            .           .                 Base::_check_template_params();
         .               .              .                  .          .          .                  .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)
         .               .              .                  .          .          .                  .            .           .                 m_storage.data()[0] = x;
         .               .              .                  .          .          .                  .            .           .                 m_storage.data()[1] = y;
         .               .              .                  .          .          .                  .            .           .                 m_storage.data()[2] = z;
         .               .              .                  .          .          .                  .            .           .                 m_storage.data()[3] = w;
         .               .              .                  .          .          .                  .            .           .               }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /** \brief Copy constructor */
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
14,454,715 ( 0.11%)  1,871 ( 0.00%)   614 ( 0.01%) 2,628,130 ( 0.08%) 0          0          5,256,260 ( 0.18%) 142 ( 0.00%)  0               EIGEN_STRONG_INLINE Matrix(const Matrix& other) : Base(other)
 3,942,195 ( 0.03%)      0              0          2,628,130 ( 0.08%) 0          0                  0            0           0               { }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /** \brief Copy constructor for generic expressions.
         .               .              .                  .          .          .                  .            .           .                 * \sa MatrixBase::operator=(const EigenBase<OtherDerived>&)
         .               .              .                  .          .          .                  .            .           .                 */
         .               .              .                  .          .          .                  .            .           .               template<typename OtherDerived>
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
   642,908 ( 0.00%) 20,683 ( 0.03%)   914 ( 0.01%)         0          0          0            367,376 ( 0.01%)   0           0               EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)
   642,908 ( 0.00%)  1,062 ( 0.00%)   582 ( 0.01%)   183,688 ( 0.01%) 0          0            183,688 ( 0.01%)   0           0                 : Base(other.derived())
   367,376 ( 0.00%)    430 ( 0.00%)   219 ( 0.00%)   275,532 ( 0.01%) 0          0                  0            0           0               { }
         .               .              .                  .          .          .                  .            .           .           
   244,524 ( 0.00%)  1,624 ( 0.00%) 1,221 ( 0.01%)    69,864 ( 0.00%) 0          0             69,864 ( 0.00%)   0           0               EIGEN_DEVICE_FUNC inline Index innerStride() const { return 1; }
   652,070 ( 0.01%)  2,918 ( 0.00%) 1,537 ( 0.01%)   195,621 ( 0.01%) 0          0            195,621 ( 0.01%)  51 ( 0.00%) 15 ( 0.00%)      EIGEN_DEVICE_FUNC inline Index outerStride() const { return this->innerSize(); }
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               /////////// Geometry module ///////////
         .               .              .                  .          .          .                  .            .           .           
         .               .              .                  .          .          .                  .            .           .               template<typename OtherDerived>
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
         .               .              .                  .          .          .                  .            .           .               explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);
         .               .              .                  .          .          .                  .            .           .               template<typename OtherDerived>
         .               .              .                  .          .          .                  .            .           .               EIGEN_DEVICE_FUNC
-- line 389 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/PlainObjectBase.h
--------------------------------------------------------------------------------
Ir                   I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw         DLmw        

-- line 26 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           namespace internal {
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {
          .               .              .                   .          .          .                   .            .           .             template<typename Index>
          .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .             static EIGEN_ALWAYS_INLINE void run(Index, Index)
          .               .              .                   .          .          .                   .            .           .             {
    182,932 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)          0          0          0                   0            0           0             }
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<> struct check_rows_cols_for_overflow<Dynamic> {
          .               .              .                   .          .          .                   .            .           .             template<typename Index>
          .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .             static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)
          .               .              .                   .          .          .                   .            .           .             {
          .               .              .                   .          .          .                   .            .           .               // http://hg.mozilla.org/mozilla-central/file/6c8a909977d3/xpcom/ds/CheckedInt.h#l242
          .               .              .                   .          .          .                   .            .           .               // we assume Index is signed
      3,374 ( 0.00%)    378 ( 0.00%)   189 ( 0.00%)          0          0          0               1,687 ( 0.00%)   0           0               Index max_index = (std::size_t(1) << (8 * sizeof(Index) - 1)) - 1; // assume Index is signed
     13,496 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)      5,061 ( 0.00%) 0          0               1,687 ( 0.00%)   0           0               bool error = (rows == 0 || cols == 0) ? false
      5,061 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)      3,374 ( 0.00%) 0          0                   0            0           0                          : (rows > max_index / cols);
      3,374 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)      1,687 ( 0.00%) 0          0                   0            0           0               if (error)
          .               .              .                   .          .          .                   .            .           .                 throw_std_bad_alloc();
      1,687 ( 0.00%)      0              0                   0          0          0                   0            0           0             }
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template <typename Derived,
          .               .              .                   .          .          .                   .            .           .                     typename OtherDerived = Derived,
          .               .              .                   .          .          .                   .            .           .                     bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>
          .               .              .                   .          .          .                   .            .           .           struct conservative_resize_like_impl;
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;
-- line 57 ----------------------------------------
-- line 90 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .             * \tparam Derived is the derived type, e.g., a Matrix or Array
          .               .              .                   .          .          .                   .            .           .             *
          .               .              .                   .          .          .                   .            .           .             * \sa \ref TopicClassHierarchy
          .               .              .                   .          .          .                   .            .           .             */
          .               .              .                   .          .          .                   .            .           .           template<typename Derived>
          .               .              .                   .          .          .                   .            .           .           class PlainObjectBase : public doxygen::dense_xpr_base_dispatcher<Derived>
          .               .              .                   .          .          .                   .            .           .           #else
          .               .              .                   .          .          .                   .            .           .           template<typename Derived>
     24,948 ( 0.00%)    328 ( 0.00%)     0               6,804 ( 0.00%) 0          0               6,804 ( 0.00%)   0           0           class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
          .               .              .                   .          .          .                   .            .           .           #endif
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .             public:
          .               .              .                   .          .          .                   .            .           .               enum { Options = internal::traits<Derived>::Options };
          .               .              .                   .          .          .                   .            .           .               typedef typename internal::dense_xpr_base<Derived>::type Base;
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               typedef typename internal::traits<Derived>::StorageKind StorageKind;
          .               .              .                   .          .          .                   .            .           .               typedef typename internal::traits<Derived>::Scalar Scalar;
-- line 106 ----------------------------------------
-- line 135 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .               template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };
          .               .              .                   .          .          .                   .            .           .               template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .             protected:
          .               .              .                   .          .          .                   .            .           .               DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .             public:
          .               .              .                   .          .          .                   .            .           .               enum { NeedsToAlign = (SizeAtCompileTime != Dynamic) && (internal::traits<Derived>::Alignment>0) };
     35,890 ( 0.00%)      1 ( 0.00%)     0              10,767 ( 0.00%) 0          0              10,767 ( 0.00%)   0           0               EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
    341,026 ( 0.00%) 37,992 ( 0.06%)   691 ( 0.01%)    146,154 ( 0.00%) 0          0              97,436 ( 0.00%)   0           0               Base& base() { return *static_cast<Base*>(this); }
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               const Base& base() const { return *static_cast<const Base*>(this); }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
111,670,272 ( 0.87%)  4,804 ( 0.01%) 2,175 ( 0.02%) 27,942,938 ( 0.83%) 0          0          41,838,297 ( 1.47%) 442 ( 0.00%) 15 ( 0.00%)      EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
111,137,782 ( 0.86%)    638 ( 0.00%)   616 ( 0.01%) 27,797,935 ( 0.82%) 0          0          41,656,434 ( 1.46%)   2 ( 0.00%)  0               EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index,Index) const
          .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
          .               .              .                   .          .          .                   .            .           .               {
-- line 161 ----------------------------------------
-- line 165 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .                   return m_storage.data()[rowId + colId * m_storage.rows()];
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const
          .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
      9,072 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0          0          0               4,536 ( 0.00%)   0           0               EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const
          .               .              .                   .          .          .                   .            .           .               {
     10,584 ( 0.00%)      0              0               3,024 ( 0.00%) 0          0               1,512 ( 0.00%)   0           0                 return m_storage.data()[index];
      3,024 ( 0.00%)      0              0               3,024 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,Index) const
          .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,Index) const for details. */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     17,896 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0          0          0              11,185 ( 0.00%)   0           0               EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 if(Flags & RowMajorBit)
          .               .              .                   .          .          .                   .            .           .                   return m_storage.data()[colId + rowId * m_storage.cols()];
          .               .              .                   .          .          .                   .            .           .                 else // column-major
     26,297 ( 0.00%)  1,464 ( 0.00%)   566 ( 0.01%)      7,556 ( 0.00%) 0          0               4,474 ( 0.00%)   0           0                   return m_storage.data()[rowId + colId * m_storage.rows()];
      6,711 ( 0.00%)      0              0               6,711 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) const
          .               .              .                   .          .          .                   .            .           .                 * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) const for details. */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
     25,020 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0          0          0              12,510 ( 0.00%)   0           0               EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)
          .               .              .                   .          .          .                   .            .           .               {
     29,190 ( 0.00%)      0              0               8,340 ( 0.00%) 0          0               4,170 ( 0.00%)   0           0                 return m_storage.data()[index];
      8,340 ( 0.00%)      0              0               8,340 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** This is the const version of coeffRef(Index,Index) which is thus synonym of coeff(Index,Index).
          .               .              .                   .          .          .                   .            .           .                 * It is provided for convenience. */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
      7,472 ( 0.00%)    328 ( 0.00%)   189 ( 0.00%)          0          0          0               4,670 ( 0.00%)   0           0               EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 if(Flags & RowMajorBit)
          .               .              .                   .          .          .                   .            .           .                   return m_storage.data()[colId + rowId * m_storage.cols()];
          .               .              .                   .          .          .                   .            .           .                 else // column-major
     12,142 ( 0.00%)      0              0               3,736 ( 0.00%) 0          0               1,868 ( 0.00%)   0           0                   return m_storage.data()[rowId + colId * m_storage.rows()];
      2,802 ( 0.00%)      0              0               2,802 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** This is the const version of coeffRef(Index) which is thus synonym of coeff(Index).
          .               .              .                   .          .          .                   .            .           .                 * It is provided for convenience. */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 return m_storage.data()[index];
          .               .              .                   .          .          .                   .            .           .               }
-- line 218 ----------------------------------------
-- line 247 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .               /** \internal */
          .               .              .                   .          .          .                   .            .           .               template<int StoreMode>
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** \returns a const pointer to the data array of this matrix */
 65,570,190 ( 0.51%) 15,139 ( 0.02%) 1,161 ( 0.01%)          0          0          0          26,228,076 ( 0.92%)   0           0               EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar *data() const
 65,570,190 ( 0.51%)  2,029 ( 0.00%)   480 ( 0.00%) 39,342,114 ( 1.16%) 0          0          13,114,038 ( 0.46%)   0           0               { return m_storage.data(); }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** \returns a pointer to the data array of this matrix */
     30,305 ( 0.00%)  1,278 ( 0.00%) 1,049 ( 0.01%)          0          0          0              12,122 ( 0.00%)  22 ( 0.00%) 15 ( 0.00%)      EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar *data()
     30,305 ( 0.00%)     39 ( 0.00%)     0              18,183 ( 0.00%) 0          0               6,061 ( 0.00%)   9 ( 0.00%)  1 ( 0.00%)      { return m_storage.data(); }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** Resizes \c *this to a \a rows x \a cols matrix.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * This method is intended for dynamic-size matrices, although it is legal to call it on any
          .               .              .                   .          .          .                   .            .           .                 * matrix as long as fixed dimensions are left unchanged. If you only want to change the number
          .               .              .                   .          .          .                   .            .           .                 * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t).
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * If the current number of coefficients of \c *this exactly matches the
-- line 268 ----------------------------------------
-- line 271 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .                 * shrinking, the data is reallocated and all previous values are lost.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * Example: \include Matrix_resize_int_int.cpp
          .               .              .                   .          .          .                   .            .           .                 * Output: \verbinclude Matrix_resize_int_int.out
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * \sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)
          .               .              .                   .          .          .                   .            .           .                 */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
    649,425 ( 0.01%) 10,867 ( 0.02%)   877 ( 0.01%)          0          0          0             371,100 ( 0.01%)   0           0               EIGEN_STRONG_INLINE void resize(Index rows, Index cols)
          .               .              .                   .          .          .                   .            .           .               {
  1,108,442 ( 0.01%) 11,255 ( 0.02%) 1,136 ( 0.01%)    554,221 ( 0.02%) 0          0             185,550 ( 0.01%)   0           0                 eigen_assert(   EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,rows==RowsAtCompileTime)
          .               .              .                   .          .          .                   .            .           .                              && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,cols==ColsAtCompileTime)
          .               .              .                   .          .          .                   .            .           .                              && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,rows<=MaxRowsAtCompileTime)
          .               .              .                   .          .          .                   .            .           .                              && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,cols<=MaxColsAtCompileTime)
          .               .              .                   .          .          .                   .            .           .                              && rows>=0 && cols>=0 && "Invalid sizes when resizing a matrix or array.");
          .               .              .                   .          .          .                   .            .           .                 internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(rows, cols);
          .               .              .                   .          .          .                   .            .           .                 #ifdef EIGEN_INITIALIZE_COEFFS
          .               .              .                   .          .          .                   .            .           .                   Index size = rows*cols;
          .               .              .                   .          .          .                   .            .           .                   bool size_changed = size != this->size();
          .               .              .                   .          .          .                   .            .           .                   m_storage.resize(size, rows, cols);
          .               .              .                   .          .          .                   .            .           .                   if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
          .               .              .                   .          .          .                   .            .           .                 #else
    742,200 ( 0.01%)  5,465 ( 0.01%)   616 ( 0.01%)    463,875 ( 0.01%) 0          0              92,775 ( 0.00%)   0           0                   m_storage.resize(rows*cols, rows, cols);
          .               .              .                   .          .          .                   .            .           .                 #endif
    278,325 ( 0.00%)      0              0             185,550 ( 0.01%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** Resizes \c *this to a vector of length \a size
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * \only_for_vectors. This method does not work for
          .               .              .                   .          .          .                   .            .           .                 * partially dynamic matrices when the static dimension is anything other
          .               .              .                   .          .          .                   .            .           .                 * than 1. For example it will not work with Matrix<double, 2, Dynamic>.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * Example: \include Matrix_resize_int.cpp
          .               .              .                   .          .          .                   .            .           .                 * Output: \verbinclude Matrix_resize_int.out
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * \sa resize(Index,Index), resize(NoChange_t, Index), resize(Index, NoChange_t)
          .               .              .                   .          .          .                   .            .           .                 */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
      5,670 ( 0.00%)    189 ( 0.00%)     0                   0          0          0               2,835 ( 0.00%)   0           0               inline void resize(Index size)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)
      1,890 ( 0.00%)      0              0                 945 ( 0.00%) 0          0                   0            0           0                 eigen_assert(((SizeAtCompileTime == Dynamic && (MaxSizeAtCompileTime==Dynamic || size<=MaxSizeAtCompileTime)) || SizeAtCompileTime == size) && size>=0);
          .               .              .                   .          .          .                   .            .           .                 #ifdef EIGEN_INITIALIZE_COEFFS
          .               .              .                   .          .          .                   .            .           .                   bool size_changed = size != this->size();
          .               .              .                   .          .          .                   .            .           .                 #endif
          .               .              .                   .          .          .                   .            .           .                 if(RowsAtCompileTime == 1)
          .               .              .                   .          .          .                   .            .           .                   m_storage.resize(size, 1, size);
          .               .              .                   .          .          .                   .            .           .                 else
      5,670 ( 0.00%)    567 ( 0.00%)   378 ( 0.00%)      2,835 ( 0.00%) 0          0                 945 ( 0.00%)   0           0                   m_storage.resize(size, size, 1);
          .               .              .                   .          .          .                   .            .           .                 #ifdef EIGEN_INITIALIZE_COEFFS
          .               .              .                   .          .          .                   .            .           .                   if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
          .               .              .                   .          .          .                   .            .           .                 #endif
      2,835 ( 0.00%)      0              0               1,890 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** Resizes the matrix, changing only the number of columns. For the parameter of type NoChange_t, just pass the special value \c NoChange
          .               .              .                   .          .          .                   .            .           .                 * as in the example below.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * Example: \include Matrix_resize_NoChange_int.cpp
          .               .              .                   .          .          .                   .            .           .                 * Output: \verbinclude Matrix_resize_NoChange_int.out
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * \sa resize(Index,Index)
-- line 331 ----------------------------------------
-- line 354 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .                 * Takes care of doing all the checking that's needed.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * Note that copying a row-vector into a vector (and conversely) is allowed.
          .               .              .                   .          .          .                   .            .           .                 * The resizing, if any, is then done in the appropriate way so that row-vectors
          .               .              .                   .          .          .                   .            .           .                 * remain row-vectors and vectors remain vectors.
          .               .              .                   .          .          .                   .            .           .                 */
          .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
    642,908 ( 0.00%) 55,374 ( 0.09%) 1,316 ( 0.01%)          0          0          0             367,376 ( 0.01%)   0           0               EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)
          .               .              .                   .          .          .                   .            .           .               {
    367,376 ( 0.00%)  1,073 ( 0.00%)   609 ( 0.01%)     91,844 ( 0.00%) 0          0             183,688 ( 0.01%)   0           0                 const OtherDerived& other = _other.derived();
    826,596 ( 0.01%)  2,467 ( 0.00%)   887 ( 0.01%)    183,688 ( 0.01%) 0          0             367,376 ( 0.01%)   0           0                 internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(other.rows(), other.cols());
    826,596 ( 0.01%) 30,837 ( 0.05%) 1,681 ( 0.02%)    183,688 ( 0.01%) 0          0             275,532 ( 0.01%)   0           0                 const Index othersize = other.rows()*other.cols();
          .               .              .                   .          .          .                   .            .           .                 if(RowsAtCompileTime == 1)
          .               .              .                   .          .          .                   .            .           .                 {
          .               .              .                   .          .          .                   .            .           .                   eigen_assert(other.rows() == 1 || other.cols() == 1);
          .               .              .                   .          .          .                   .            .           .                   resize(1, othersize);
          .               .              .                   .          .          .                   .            .           .                 }
          .               .              .                   .          .          .                   .            .           .                 else if(ColsAtCompileTime == 1)
          .               .              .                   .          .          .                   .            .           .                 {
    916,550 ( 0.01%) 31,363 ( 0.05%) 1,322 ( 0.01%)    183,310 ( 0.01%) 0          0             183,310 ( 0.01%)   0           0                   eigen_assert(other.rows() == 1 || other.cols() == 1);
    549,930 ( 0.00%) 22,067 ( 0.04%) 2,169 ( 0.02%)    183,310 ( 0.01%) 0          0              91,655 ( 0.00%)   0           0                   resize(othersize, 1);
          .               .              .                   .          .          .                   .            .           .                 }
      2,457 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)        567 ( 0.00%) 0          0                 567 ( 0.00%)   0           0                 else resize(other.rows(), other.cols());
    367,376 ( 0.00%)    191 ( 0.00%)   191 ( 0.00%)    275,532 ( 0.01%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** Resizes the matrix to \a rows x \a cols while leaving old values untouched.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * The method is intended for matrices of dynamic size. If you only want to change the number
          .               .              .                   .          .          .                   .            .           .                 * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or
          .               .              .                   .          .          .                   .            .           .                 * conservativeResize(Index, NoChange_t).
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * Matrices are resized relative to the top-left element. In case values need to be 
-- line 386 ----------------------------------------
-- line 476 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .                 return Base::operator=(func);
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               // Prevent user from trying to instantiate PlainObjectBase objects
          .               .              .                   .          .          .                   .            .           .               // by making all its constructor protected. See bug 1074.
          .               .              .                   .          .          .                   .            .           .             protected:
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
  1,785,652 ( 0.01%) 17,280 ( 0.03%) 3,122 ( 0.03%)    324,664 ( 0.01%) 0          0             649,328 ( 0.02%)  41 ( 0.00%) 16 ( 0.00%)      EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .           //       _check_template_params();
          .               .              .                   .          .          .                   .            .           .           //       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
    486,996 ( 0.00%)      0              0             324,664 ( 0.01%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           #ifndef EIGEN_PARSED_BY_DOXYGEN
          .               .              .                   .          .          .                   .            .           .               // FIXME is it still needed ?
          .               .              .                   .          .          .                   .            .           .               /** \internal */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               explicit PlainObjectBase(internal::constructor_without_unaligned_array_assert)
          .               .              .                   .          .          .                   .            .           .                 : m_storage(internal::constructor_without_unaligned_array_assert())
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .           //       _check_template_params(); EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           #endif
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           #if EIGEN_HAS_RVALUE_REFERENCES
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
    374,290 ( 0.00%)      0              0                   0          0          0             213,880 ( 0.01%)   2 ( 0.00%)  0               PlainObjectBase(PlainObjectBase&& other) EIGEN_NOEXCEPT
    534,700 ( 0.00%)    702 ( 0.00%)   462 ( 0.00%)    160,410 ( 0.00%) 0          0             160,410 ( 0.01%)   0           0                 : m_storage( std::move(other.m_storage) )
          .               .              .                   .          .          .                   .            .           .               {
    213,880 ( 0.00%)      0              0             160,410 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               PlainObjectBase& operator=(PlainObjectBase&& other) EIGEN_NOEXCEPT
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 using std::swap;
          .               .              .                   .          .          .                   .            .           .                 swap(m_storage, other.m_storage);
          .               .              .                   .          .          .                   .            .           .                 return *this;
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           #endif
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** Copy constructor */
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
  7,884,390 ( 0.06%)  4,080 ( 0.01%)   644 ( 0.01%)          0          0          0           3,942,195 ( 0.14%)   2 ( 0.00%)  0               EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)
 14,454,715 ( 0.11%)    378 ( 0.00%)   189 ( 0.00%)  6,570,325 ( 0.19%) 0          0           2,628,130 ( 0.09%)   1 ( 0.00%)  0                 : Base(), m_storage(other.m_storage) { }
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)
          .               .              .                   .          .          .                   .            .           .                 : m_storage(size, rows, cols)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .           //       _check_template_params();
          .               .              .                   .          .          .                   .            .           .           //       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** \sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */
          .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
    551,442 ( 0.00%) 20,399 ( 0.03%) 2,120 ( 0.02%)          0          0          0             275,910 ( 0.01%)   0           0               EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)
    551,064 ( 0.00%)    812 ( 0.00%)   218 ( 0.00%)    183,688 ( 0.01%) 0          0             183,688 ( 0.01%)   0           0                 : m_storage()
          .               .              .                   .          .          .                   .            .           .               {
     91,844 ( 0.00%)      0              0                   0          0          0              91,844 ( 0.00%)   0           0                 _check_template_params();
    459,220 ( 0.00%)    410 ( 0.00%)   410 ( 0.00%)    183,688 ( 0.01%) 0          0              91,844 ( 0.00%)   0           0                 resizeLike(other);
    459,220 ( 0.00%) 18,493 ( 0.03%) 1,266 ( 0.01%)    183,688 ( 0.01%) 0          0              91,844 ( 0.00%)   0           0                 _set_noalias(other);
    275,910 ( 0.00%)    189 ( 0.00%)     0             184,066 ( 0.01%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** \sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */
          .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)
          .               .              .                   .          .          .                   .            .           .                 : m_storage()
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 _check_template_params();
-- line 546 ----------------------------------------
-- line 704 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .                 * \sa operator=(const MatrixBase<OtherDerived>&), _set_noalias()
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * \internal
          .               .              .                   .          .          .                   .            .           .                 */
          .               .              .                   .          .          .                   .            .           .               // aliasing is dealt once in internall::call_assignment
          .               .              .                   .          .          .                   .            .           .               // so at this stage we have to assume aliasing... and resising has to be done later.
          .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
    519,953 ( 0.00%) 39,285 ( 0.06%)   892 ( 0.01%)          0          0          0             297,116 ( 0.01%)   0           0               EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)
          .               .              .                   .          .          .                   .            .           .               {
    742,790 ( 0.01%) 24,241 ( 0.04%) 1,672 ( 0.02%)    148,558 ( 0.00%) 0          0             222,837 ( 0.01%)   0           0                 internal::call_assignment(this->derived(), other.derived());
    222,837 ( 0.00%)    190 ( 0.00%)     0              74,279 ( 0.00%) 0          0              74,279 ( 0.00%)   0           0                 return this->derived();
    222,837 ( 0.00%)    196 ( 0.00%)   193 ( 0.00%)    222,837 ( 0.01%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               /** \internal Like _set() but additionally makes the assumption that no aliasing effect can happen (which
          .               .              .                   .          .          .                   .            .           .                 * is the case when creating a new matrix) so one can enforce lazy evaluation.
          .               .              .                   .          .          .                   .            .           .                 *
          .               .              .                   .          .          .                   .            .           .                 * \sa operator=(const MatrixBase<OtherDerived>&), _set()
          .               .              .                   .          .          .                   .            .           .                 */
          .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
    931,160 ( 0.01%)  4,286 ( 0.01%) 1,494 ( 0.01%)     93,116 ( 0.00%) 0          0             465,580 ( 0.02%)   0           0               EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 // I don't think we need this resize call since the lazyAssign will anyways resize
          .               .              .                   .          .          .                   .            .           .                 // and lazyAssign will be called by the assign selector.
          .               .              .                   .          .          .                   .            .           .                 //_resize_to_match(other);
          .               .              .                   .          .          .                   .            .           .                 // the 'false' below means to enforce lazy evaluation. We don't use lazyAssign() because
          .               .              .                   .          .          .                   .            .           .                 // it wouldn't allow to copy a row-vector into a column-vector.
  1,489,856 ( 0.01%)  9,596 ( 0.02%) 3,150 ( 0.03%)    186,232 ( 0.01%) 0          0             372,464 ( 0.01%)   0           0                 internal::call_assignment_no_alias(this->derived(), other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>());
    279,348 ( 0.00%) 12,822 ( 0.02%)   204 ( 0.00%)     93,116 ( 0.00%) 0          0              93,116 ( 0.00%)   0           0                 return this->derived();
    558,696 ( 0.00%) 11,987 ( 0.02%) 2,286 ( 0.02%)    465,580 ( 0.01%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               template<typename T0, typename T1>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
      3,024 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0          0          0               1,890 ( 0.00%)   0           0               EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
          .               .              .                   .          .          .                   .            .           .               {
        378 ( 0.00%)      0              0                   0          0          0                 378 ( 0.00%)   0           0                 const bool t0_is_integer_alike = internal::is_valid_index_type<T0>::value;
        378 ( 0.00%)      0              0                   0          0          0                 378 ( 0.00%)   0           0                 const bool t1_is_integer_alike = internal::is_valid_index_type<T1>::value;
          .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT(t0_is_integer_alike &&
          .               .              .                   .          .          .                   .            .           .                                     t1_is_integer_alike,
          .               .              .                   .          .          .                   .            .           .                                     FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
      2,268 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)      1,134 ( 0.00%) 0          0                 378 ( 0.00%)   0           0                 resize(rows,cols);
      1,134 ( 0.00%)      0              0                 756 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .               
          .               .              .                   .          .          .                   .            .           .               template<typename T0, typename T1>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
    752,816 ( 0.01%)  2,280 ( 0.00%)   682 ( 0.01%)          0          0          0             470,510 ( 0.02%)   0           0               EIGEN_STRONG_INLINE void _init2(const T0& val0, const T1& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)
    770,704 ( 0.01%)    287 ( 0.00%)   212 ( 0.00%)    376,408 ( 0.01%) 0          0             282,306 ( 0.01%) 532 ( 0.00%)  0                 m_storage.data()[0] = Scalar(val0);
    864,806 ( 0.01%)  1,338 ( 0.00%)   431 ( 0.00%)    376,408 ( 0.01%) 0          0             282,306 ( 0.01%)   0           0                 m_storage.data()[1] = Scalar(val1);
    282,306 ( 0.00%)      0              0             188,204 ( 0.01%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .               
          .               .              .                   .          .          .                   .            .           .               template<typename T0, typename T1>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init2(const Index& val0, const Index& val1,
          .               .              .                   .          .          .                   .            .           .                                               typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)
          .               .              .                   .          .          .                   .            .           .                                                                             && (internal::is_same<T0,Index>::value)
          .               .              .                   .          .          .                   .            .           .                                                                             && (internal::is_same<T1,Index>::value)
          .               .              .                   .          .          .                   .            .           .                                                                             && Base::SizeAtCompileTime==2,T1>::type* = 0)
-- line 763 ----------------------------------------
-- line 766 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .                 m_storage.data()[0] = Scalar(val0);
          .               .              .                   .          .          .                   .            .           .                 m_storage.data()[1] = Scalar(val1);
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               // The argument is convertible to the Index type and we either have a non 1x1 Matrix, or a dynamic-sized Array,
          .               .              .                   .          .          .                   .            .           .               // then the argument is meant to be the size of the object.
          .               .              .                   .          .          .                   .            .           .               template<typename T>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
      5,103 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)        567 ( 0.00%) 0          0               2,835 ( 0.00%)   0           0               EIGEN_STRONG_INLINE void _init1(Index size, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)
          .               .              .                   .          .          .                   .            .           .                                                                                         && ((!internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value || Base::SizeAtCompileTime==Dynamic)),T>::type* = 0)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 // NOTE MSVC 2008 complains if we directly put bool(NumTraits<T>::IsInteger) as the EIGEN_STATIC_ASSERT argument.
        567 ( 0.00%)      0              0                   0          0          0                 567 ( 0.00%)   0           0                 const bool is_integer_alike = internal::is_valid_index_type<T>::value;
      1,701 ( 0.00%)      0              0                   0          0          0                 567 ( 0.00%)   0           0                 EIGEN_UNUSED_VARIABLE(is_integer_alike);
          .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT(is_integer_alike,
          .               .              .                   .          .          .                   .            .           .                                     FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
      2,835 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)      1,134 ( 0.00%) 0          0                 567 ( 0.00%)   0           0                 resize(size);
      3,402 ( 0.00%)      0              0               2,268 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .               
          .               .              .                   .          .          .                   .            .           .               // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coefficient (case where scalar type can be implicitely converted)
          .               .              .                   .          .          .                   .            .           .               template<typename T>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1)
          .               .              .                   .          .          .                   .            .           .                 m_storage.data()[0] = val0;
-- line 791 ----------------------------------------
-- line 809 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init1(const Scalar* data){
          .               .              .                   .          .          .                   .            .           .                 this->_set_noalias(ConstMapType(data));
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               // Initialize an arbitrary matrix from a dense expression
          .               .              .                   .          .          .                   .            .           .               template<typename T, typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
      7,632 ( 0.00%)    894 ( 0.00%)   851 ( 0.01%)          0          0          0               3,816 ( 0.00%)   0           0               EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other){
      6,360 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)      2,544 ( 0.00%) 0          0               1,272 ( 0.00%)   0           0                 this->_set_noalias(other);
      3,816 ( 0.00%)      0              0               2,544 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               // Initialize an arbitrary matrix from an object convertible to the Derived type.
          .               .              .                   .          .          .                   .            .           .               template<typename T>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               EIGEN_STRONG_INLINE void _init1(const Derived& other){
          .               .              .                   .          .          .                   .            .           .                 this->_set_noalias(other);
          .               .              .                   .          .          .                   .            .           .               }
          .               .              .                   .          .          .                   .            .           .           
-- line 827 ----------------------------------------
-- line 880 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .               
          .               .              .                   .          .          .                   .            .           .           #ifndef EIGEN_PARSED_BY_DOXYGEN
          .               .              .                   .          .          .                   .            .           .               /** \internal
          .               .              .                   .          .          .                   .            .           .                 * \brief Override DenseBase::swap() since for dynamic-sized matrices
          .               .              .                   .          .          .                   .            .           .                 * of same type it is enough to swap the data pointers.
          .               .              .                   .          .          .                   .            .           .                 */
          .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
    341,026 ( 0.00%)  1,197 ( 0.00%)   463 ( 0.00%)          0          0          0             194,872 ( 0.01%)   0           0               void swap(DenseBase<OtherDerived> & other)
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 enum { SwapPointers = internal::is_same<Derived, OtherDerived>::value && Base::SizeAtCompileTime==Dynamic };
    487,180 ( 0.00%)  4,949 ( 0.01%)   456 ( 0.00%)     97,436 ( 0.00%) 0          0             146,154 ( 0.01%)   0           0                 internal::matrix_swap_impl<Derived, OtherDerived, bool(SwapPointers)>::run(this->derived(), other.derived());
    194,872 ( 0.00%)      0              0             146,154 ( 0.00%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .               
          .               .              .                   .          .          .                   .            .           .               /** \internal
          .               .              .                   .          .          .                   .            .           .                 * \brief const version forwarded to DenseBase::swap
          .               .              .                   .          .          .                   .            .           .                 */
          .               .              .                   .          .          .                   .            .           .               template<typename OtherDerived>
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .               void swap(DenseBase<OtherDerived> const & other)
          .               .              .                   .          .          .                   .            .           .               { Base::swap(other.derived()); }
          .               .              .                   .          .          .                   .            .           .               
          .               .              .                   .          .          .                   .            .           .               EIGEN_DEVICE_FUNC 
    923,505 ( 0.01%)    579 ( 0.00%)   189 ( 0.00%)          0          0          0             307,835 ( 0.01%)   0           0               static EIGEN_STRONG_INLINE void _check_template_params()
          .               .              .                   .          .          .                   .            .           .               {
          .               .              .                   .          .          .                   .            .           .                 EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, (Options&RowMajor)==RowMajor)
          .               .              .                   .          .          .                   .            .           .                                   && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, (Options&RowMajor)==0)
          .               .              .                   .          .          .                   .            .           .                                   && ((RowsAtCompileTime == Dynamic) || (RowsAtCompileTime >= 0))
          .               .              .                   .          .          .                   .            .           .                                   && ((ColsAtCompileTime == Dynamic) || (ColsAtCompileTime >= 0))
          .               .              .                   .          .          .                   .            .           .                                   && ((MaxRowsAtCompileTime == Dynamic) || (MaxRowsAtCompileTime >= 0))
          .               .              .                   .          .          .                   .            .           .                                   && ((MaxColsAtCompileTime == Dynamic) || (MaxColsAtCompileTime >= 0))
          .               .              .                   .          .          .                   .            .           .                                   && (MaxRowsAtCompileTime == RowsAtCompileTime || RowsAtCompileTime==Dynamic)
          .               .              .                   .          .          .                   .            .           .                                   && (MaxColsAtCompileTime == ColsAtCompileTime || ColsAtCompileTime==Dynamic)
          .               .              .                   .          .          .                   .            .           .                                   && (Options & (DontAlign|RowMajor)) == Options),
          .               .              .                   .          .          .                   .            .           .                   INVALID_MATRIX_TEMPLATE_PARAMETERS)
    923,505 ( 0.01%)  2,254 ( 0.00%)   680 ( 0.01%)    615,670 ( 0.02%) 0          0                   0            0           0               }
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .               enum { IsPlainObjectBase = 1 };
          .               .              .                   .          .          .                   .            .           .           #endif
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           namespace internal {
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template <typename Derived, typename OtherDerived, bool IsVector>
-- line 923 ----------------------------------------
-- line 1009 ----------------------------------------
          .               .              .                   .          .          .                   .            .           .                 _this.tail(num_new_elements) = other.tail(num_new_elements);
          .               .              .                   .          .          .                   .            .           .             }
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>
          .               .              .                   .          .          .                   .            .           .           struct matrix_swap_impl
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
    292,308 ( 0.00%) 11,190 ( 0.02%)   503 ( 0.00%)          0          0          0             146,154 ( 0.01%)   0           0             static inline void run(MatrixTypeA& a, MatrixTypeB& b)
          .               .              .                   .          .          .                   .            .           .             {
    389,744 ( 0.00%) 16,019 ( 0.03%)   609 ( 0.01%)     97,436 ( 0.00%) 0          0              97,436 ( 0.00%)   0           0               a.base().swap(b);
    146,154 ( 0.00%)      0              0              97,436 ( 0.00%) 0          0                   0            0           0             }
          .               .              .                   .          .          .                   .            .           .           };
          .               .              .                   .          .          .                   .            .           .           
          .               .              .                   .          .          .                   .            .           .           template<typename MatrixTypeA, typename MatrixTypeB>
          .               .              .                   .          .          .                   .            .           .           struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>
          .               .              .                   .          .          .                   .            .           .           {
          .               .              .                   .          .          .                   .            .           .             EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .            .           .             static inline void run(MatrixTypeA& a, MatrixTypeB& b)
          .               .              .                   .          .          .                   .            .           .             {
-- line 1028 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/util/Meta.h
--------------------------------------------------------------------------------
Ir                  I1mr           ILmr         Dr                  D1mr       DLmr       Dw                  D1mw           DLmw        

-- line 299 ----------------------------------------
         .              .            .                   .          .          .                   .              .           .           /** \internal
         .              .            .                   .          .          .                   .              .           .             * A base class do disable default copy ctor and copy assignement operator.
         .              .            .                   .          .          .                   .              .           .             */
         .              .            .                   .          .          .                   .              .           .           class noncopyable
         .              .            .                   .          .          .                   .              .           .           {
         .              .            .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC noncopyable(const noncopyable&);
         .              .            .                   .          .          .                   .              .           .             EIGEN_DEVICE_FUNC const noncopyable& operator=(const noncopyable&);
         .              .            .                   .          .          .                   .              .           .           protected:
96,504,275 ( 0.75%) 2,102 ( 0.00%) 680 ( 0.01%) 27,572,650 ( 0.82%) 0          0          27,572,650 ( 0.97%) 1,884 ( 0.00%) 25 ( 0.00%)    EIGEN_DEVICE_FUNC noncopyable() {}
96,504,275 ( 0.75%)     0            0          27,572,650 ( 0.82%) 0          0          27,572,650 ( 0.97%)     0           0             EIGEN_DEVICE_FUNC ~noncopyable() {}
         .              .            .                   .          .          .                   .              .           .           };
         .              .            .                   .          .          .                   .              .           .           
         .              .            .                   .          .          .                   .              .           .           /** \internal
         .              .            .                   .          .          .                   .              .           .             * Convenient struct to get the result type of a unary or binary functor.
         .              .            .                   .          .          .                   .              .           .             *
         .              .            .                   .          .          .                   .              .           .             * It supports both the current STL mechanism (using the result_type member) as well as
         .              .            .                   .          .          .                   .              .           .             * upcoming next STL generation (using a templated result member).
         .              .            .                   .          .          .                   .              .           .             * If none of these members is provided, then the type of the first argument is returned. FIXME, that behavior is a pretty bad hack.
-- line 316 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/SculptCurve.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                 D1mr         DLmr         Dw                 D1mw         DLmw         

-- line 62 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           #include <Eigen/Core>
         .               .              .                  .            .            .                  .            .            .           #include <Eigen/LU>
         .               .              .                  .            .            .                  .            .            .           #include <Eigen/StdVector>
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           #ifndef DEFINE_STD_VECTOR_INSERTION_OPERATOR
         .               .              .                  .            .            .                  .            .            .           #define DEFINE_STD_VECTOR_INSERTION_OPERATOR
         .               .              .                  .            .            .                  .            .            .           // Defines insertion operator (<<) for std::vector, for convenience
     2,400 ( 0.00%)    212 ( 0.00%)   133 ( 0.00%)         0            0            0              1,200 ( 0.00%)   0            0           template<class T> std::vector<T> & operator<<(std::vector<T> & v, const T & x)
     3,200 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)     2,000 ( 0.00%)   0            0                400 ( 0.00%)   0            0           { v.push_back(x); return v; }
    55,776 ( 0.00%)      7 ( 0.00%)     0                  0            0            0             27,888 ( 0.00%)   0            0           template<class T> std::vector<T,Eigen::aligned_allocator<T> > & operator<<(std::vector<T,Eigen::aligned_allocator<T> > & v, const T & x)
    74,368 ( 0.00%)    279 ( 0.00%)   234 ( 0.00%)    46,480 ( 0.00%)   0            0              9,296 ( 0.00%)   0            0           { v.push_back(x); return v; }
         .               .              .                  .            .            .                  .            .            .           #endif
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           namespace SculptCurve
         .               .              .                  .            .            .                  .            .            .           {
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           inline bool isnan(double x)
    83,130 ( 0.00%)     43 ( 0.00%)    14 ( 0.00%)         0            0            0             33,252 ( 0.00%)   0            0           {
         .               .              .                  .            .            .                  .            .            .           #ifdef _WIN32
         .               .              .                  .            .            .                  .            .            .               return _isnan(x);
         .               .              .                  .            .            .                  .            .            .           #else
    49,878 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)    16,626 ( 0.00%)   0            0             16,626 ( 0.00%)   0            0               return std::isnan(x);
         .               .              .                  .            .            .                  .            .            .           #endif
    33,252 ( 0.00%)      0              0             33,252 ( 0.00%)   0            0                  0            0            0           }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           struct Intersection
         .               .              .                  .            .            .                  .            .            .           {
         .               .              .                  .            .            .                  .            .            .               double s, t;
       105 ( 0.00%)     14 ( 0.00%)    12 ( 0.00%)        42 ( 0.00%)   0            0                 42 ( 0.00%)   0            0               Intersection(double s, double t): s(s), t(t) {}
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               bool operator< (const Intersection & other) const
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   return s < other.s;
         .               .              .                  .            .            .                  .            .            .               }
         .               .              .                  .            .            .                  .            .            .           };
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           template<class T>
    45,454 ( 0.00%)  1,765 ( 0.00%)   255 ( 0.00%)    19,276 ( 0.00%) 366 ( 0.00%) 252 ( 0.00%)    10,410 ( 0.00%) 279 ( 0.00%) 218 ( 0.00%)  class Curve
         .               .              .                  .            .            .                  .            .            .           {
         .               .              .                  .            .            .                  .            .            .           public:
         .               .              .                  .            .            .                  .            .            .               // -------- Construction and Destruction --------
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Construct an empty curve. Optionally, specify a sampling rate
     1,519 ( 0.00%)    203 ( 0.00%)    31 ( 0.00%)         0            0            0                868 ( 0.00%)   0            0               Curve(double ds = 5.0) :
     1,302 ( 0.00%)    203 ( 0.00%)    31 ( 0.00%)       651 ( 0.00%)   0            0                651 ( 0.00%)  47 ( 0.00%)  34 ( 0.00%)          dirtyArclengths_(false), isClosed_(false), sketchInProgress_(false),
       868 ( 0.00%)      0              0                434 ( 0.00%)   0            0                434 ( 0.00%)   3 ( 0.00%)   0                   N_(10), fitterType_(QUARTIC_BEZIER_FITTER),
     7,378 ( 0.00%)    580 ( 0.00%)    83 ( 0.00%)     2,821 ( 0.00%)  53 ( 0.00%)  17 ( 0.00%)     1,736 ( 0.00%)  44 ( 0.00%)  27 ( 0.00%)          ds_(ds), lastDs_(-1) {}
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Construct a straight line
         .               .              .                  .            .            .                  .            .            .               Curve(const T & start, const T & end, double ds = 5.0) :
         .               .              .                  .            .            .                  .            .            .                   dirtyArclengths_(true), isClosed_(false), sketchInProgress_(false),
         .               .              .                  .            .            .                  .            .            .                   N_(20), fitterType_(QUARTIC_BEZIER_FITTER),
         .               .              .                  .            .            .                  .            .            .                   ds_(ds), lastDs_(-1)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   vertices_.push_back(start);
         .               .              .                  .            .            .                  .            .            .                   vertices_.push_back(end);
         .               .              .                  .            .            .                  .            .            .                   resample(true);
         .               .              .                  .            .            .                  .            .            .               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Reinitialize curve
        70 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)         0            0            0                 28 ( 0.00%)   0            0               void clear() {
       210 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        84 ( 0.00%)   0            0                 70 ( 0.00%)   0            0                   vertices_.clear(); arclengths_.clear(); lastDs_ = -1; dirtyArclengths_ = false; isClosed_ = false;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
        56 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   p_.clear(); // raw input from mouse
        56 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   qTemp_.clear(); // temp vertices
        42 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   clearFits_();
        42 ( 0.00%)      0              0                 28 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // must ensure that the first vertex is equal to the last
         .               .              .                  .            .            .                  .            .            .               // by default, sculpt curve never create a loop, it must be explicitly
         .               .              .                  .            .            .                  .            .            .               // created using the method below, so that it will behave as a loop
       108 ( 0.00%)      8 ( 0.00%)     0                  0            0            0                 54 ( 0.00%)   0            0               void makeLoop()
         .               .              .                  .            .            .                  .            .            .               {
        54 ( 0.00%)      0              0                 27 ( 0.00%)   0            0                 27 ( 0.00%)   0            0                   isClosed_ = true;
        81 ( 0.00%)      0              0                 54 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
       228 ( 0.00%)      0              0                  0            0            0                114 ( 0.00%)   0            0               double epsilon() const
         .               .              .                  .            .            .                  .            .            .               {
       114 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)        57 ( 0.00%)   0            0                  0            0            0                   return 1e-6;
       171 ( 0.00%)      0              0                114 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // -------- Sketching and Fitting --------
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               void beginSketch(double x, double y) { T v; v.setX(x); v.setY(y); beginSketch(v); }
       140 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 70 ( 0.00%)   0            0               void beginSketch(const T & vertex)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Initialization
        42 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   clear();
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // add first point
       182 ( 0.00%)      0              0                 42 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                   p_.push_back(Input(vertex,0));
        70 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        28 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   pushFirstVertex_(vertex);
         .               .              .                  .            .            .                  .            .            .           
        42 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   lastFinalS_ = 0;
        28 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   sketchInProgress_ = true;
        98 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        70 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               void continueSketch(double x, double y) { T v; v.setX(x); v.setY(y); continueSketch(v); }
     2,387 ( 0.00%)    217 ( 0.00%)   212 ( 0.00%)       217 ( 0.00%)   0            0              1,302 ( 0.00%)   0            0               void continueSketch(const T & vertex)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .           
       868 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       434 ( 0.00%) 216 ( 0.00%) 212 ( 0.00%)         0            0            0                   if(sketchInProgress_)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // add input point
         .               .              .                  .            .            .                  .            .            .                   //Eigen::Vector2d p(x,y);
     3,038 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       434 ( 0.00%)   0            0                868 ( 0.00%)   0            0                       double dx = vertex.x()-p_.back().p.x();
     3,038 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       434 ( 0.00%)   0            0                868 ( 0.00%)   0            0                       double dy = vertex.y()-p_.back().p.y();
     1,519 ( 0.00%)      0              0                434 ( 0.00%)   0            0                217 ( 0.00%)   0            0                   double distSquared = dx*dx + dy*dy;
     1,519 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       217 ( 0.00%)   0            0                  0            0            0                   if(!(distSquared>0))
         .               .              .                  .            .            .                  .            .            .                       return;
     4,991 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)     1,302 ( 0.00%)  52 ( 0.00%)  51 ( 0.00%)     1,085 ( 0.00%)   0            0                   p_.push_back(Input( vertex, p_.back().s + std::sqrt(distSquared)));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // erase previous temporary data
       868 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       217 ( 0.00%)   0            0                217 ( 0.00%)   0            0                   qTemp_.clear();
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // compute new fit
     2,387 ( 0.00%)      0              0                651 ( 0.00%)   0            0                217 ( 0.00%)   0            0                   if(p_.size() < (unsigned int) N_)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       // Compute fit
     1,700 ( 0.00%)    300 ( 0.00%)   200 ( 0.00%)       600 ( 0.00%)  70 ( 0.00%)  67 ( 0.00%)       300 ( 0.00%)   0            0                       Fitter * fit = fitter(fitterType_, p_, 0, static_cast<int>(p_.size()), ds_);
         .               .              .                  .            .            .                  .            .            .           
       900 ( 0.00%)      0              0                100 ( 0.00%)   0            0                200 ( 0.00%)   0            0                       T q = vertices_.back(); // = q_[0]
       300 ( 0.00%)    100 ( 0.00%)   100 ( 0.00%)       200 ( 0.00%)   0            0                100 ( 0.00%)   0            0                       double s = lastFinalS_;                 // = 0
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // sample from fit
         .               .              .                  .            .            .                  .            .            .                       // while we have not reached the end
    46,696 ( 0.00%)  3,983 ( 0.01%)   200 ( 0.00%)    19,415 ( 0.00%)   0            0              3,883 ( 0.00%)   0            0                       while(p_.back().s - s > ds_)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // add a new vertex
    26,481 ( 0.00%)    162 ( 0.00%)    92 ( 0.00%)    15,132 ( 0.00%)   0            0              3,783 ( 0.00%)   0            0                           s += 0.75*ds_;
    49,179 ( 0.00%)  3,783 ( 0.01%)     0             11,349 ( 0.00%)   0            0              7,566 ( 0.00%)   0            0                           q = phi_(s, fit);
    22,698 ( 0.00%)  3,783 ( 0.01%)     0              3,783 ( 0.00%)   0            0              3,783 ( 0.00%)   0            0                           qTemp_.push_back(q);
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                       // add last vertex
       900 ( 0.00%)      0              0                100 ( 0.00%)   0            0                200 ( 0.00%)   0            0                       T lastP = p_.back().p;
       600 ( 0.00%)    100 ( 0.00%)   100 ( 0.00%)       100 ( 0.00%)   0            0                100 ( 0.00%)   0            0                       qTemp_.push_back(lastP);
         .               .              .                  .            .            .                  .            .            .           
       900 ( 0.00%)      0              0                300 ( 0.00%)   8 ( 0.00%)   8 ( 0.00%)       100 ( 0.00%)   0            0                       delete fit;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       // compute new fitting
     2,457 ( 0.00%)    468 ( 0.00%)   351 ( 0.00%)     1,170 ( 0.00%) 103 ( 0.00%) 103 ( 0.00%)       351 ( 0.00%)   0            0                       Fitter * fit = fitter(fitterType_, p_,static_cast<int>(p_.size()) - N_, N_, ds_);
       702 ( 0.00%)    117 ( 0.00%)   117 ( 0.00%)       117 ( 0.00%)   0            0                117 ( 0.00%)   0            0                       fits_ << fit;
         .               .              .                  .            .            .                  .            .            .           
     1,053 ( 0.00%)      0              0                117 ( 0.00%)   0            0                234 ( 0.00%)   0            0                       T q = vertices_.back();
         .               .              .                  .            .            .                  .            .            .                       //double qt = qt_.last();
       351 ( 0.00%)      0              0                234 ( 0.00%)   0            0                117 ( 0.00%)   0            0                       double s = lastFinalS_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // while we have not reached the end
    63,081 ( 0.00%)  1,060 ( 0.00%)   351 ( 0.00%)    26,235 ( 0.00%)   0            0              5,247 ( 0.00%)   0            0                       while(p_.back().s - s > ds_)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // add a new vertex
    35,910 ( 0.00%)     51 ( 0.00%)     0             20,520 ( 0.00%)   0            0              5,130 ( 0.00%)   0            0                           s += 0.75*ds_;
    66,690 ( 0.00%)  4,191 ( 0.01%)   117 ( 0.00%)    10,260 ( 0.00%)   0            0             10,260 ( 0.00%)   0            0                           q = phi_(s);
    97,470 ( 0.00%)  4,860 ( 0.01%)   234 ( 0.00%)    30,780 ( 0.00%)   0            0             10,260 ( 0.00%)   0            0                           if(s<=p_[p_.size()-N_+1].s)
         .               .              .                  .            .            .                  .            .            .                           {
     3,315 ( 0.00%)      0              0                663 ( 0.00%)   0            0                663 ( 0.00%)   0            0                               pushVertex_(q);
     2,652 ( 0.00%)      0              0              1,326 ( 0.00%)   0            0                663 ( 0.00%)   0            0                               lastFinalS_ = s;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                           else
         .               .              .                  .            .            .                  .            .            .                           {
    26,802 ( 0.00%)      0              0              4,467 ( 0.00%)   0            0              4,467 ( 0.00%)   0            0                               qTemp_.push_back(q);
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                           //viz_.addVertex(q[0],q[1]);
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // add last vertex
     1,053 ( 0.00%)      0              0                117 ( 0.00%)   0            0                234 ( 0.00%)   0            0                       T lastP = p_.back().p;
       702 ( 0.00%)    117 ( 0.00%)   117 ( 0.00%)       117 ( 0.00%)   0            0                117 ( 0.00%)   0            0                       qTemp_.push_back(lastP);
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
       868 ( 0.00%)    100 ( 0.00%)   100 ( 0.00%)       434 ( 0.00%) 217 ( 0.00%) 212 ( 0.00%)       217 ( 0.00%)  23 ( 0.00%)  23 ( 0.00%)          lastDs_ = -1;
         .               .              .                  .            .            .                  .            .            .                   }
     1,736 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)     1,302 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
       112 ( 0.00%)     14 ( 0.00%)     7 ( 0.00%)        14 ( 0.00%)   0            0                 42 ( 0.00%)   0            0               void endSketch()
         .               .              .                  .            .            .                  .            .            .               {
    13,604 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)        42 ( 0.00%)   0            0              3,048 ( 0.00%)   0            0                   for(T vertex : qTemp_)
     3,705 ( 0.00%)      0              0                741 ( 0.00%)   0            0                741 ( 0.00%)   0            0                       pushVertex_(vertex);
        56 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   qTemp_.clear();
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   //vertices_.insert(vertices_.end(), qTemp_.begin(), qTemp_.end());
        42 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   clearFits_();
         .               .              .                  .            .            .                  .            .            .                   //makeQuasiUniform_();
         .               .              .                  .            .            .                  .            .            .                   //computeQS_();
         .               .              .                  .            .            .                  .            .            .           
        56 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   p_.clear(); // clear raw input (used as a test to know is curve is being drawn)
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
        28 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   sketchInProgress_ = false;
        56 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   resample(true);
         .               .              .                  .            .            .                  .            .            .           
        84 ( 0.00%)     15 ( 0.00%)    14 ( 0.00%)        56 ( 0.00%)   2 ( 0.00%)   0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // -------- Sampling --------
         .               .              .                  .            .            .                  .            .            .           
   185,706 ( 0.00%) 17,153 ( 0.03%)   250 ( 0.00%)         0            0            0             92,853 ( 0.00%)  40 ( 0.00%)   0               int size() const
         .               .              .                  .            .            .                  .            .            .               {
   309,510 ( 0.00%)    385 ( 0.00%)   249 ( 0.00%)    61,902 ( 0.00%)   0            0             61,902 ( 0.00%)   0            0                   return static_cast<int>(vertices_.size() + qTemp_.size());
    92,853 ( 0.00%)      0              0             92,853 ( 0.00%)   0            0                  0            0            0               }
 8,167,460 ( 0.06%)     11 ( 0.00%)    11 ( 0.00%)         0            0            0          4,667,120 ( 0.16%)   0            0               T operator[] (int i) const
         .               .              .                  .            .            .                  .            .            .               {
 9,334,240 ( 0.07%)    413 ( 0.00%)   251 ( 0.00%) 2,333,560 ( 0.07%)   0            0          2,333,560 ( 0.08%) 129 ( 0.00%)   0                   int k = i - static_cast<int>(vertices_.size());
 2,333,560 ( 0.02%)      0              0          1,166,780 ( 0.03%)   0            0                  0            0            0                   if(k<0)
14,345,019 ( 0.11%)      0              0          3,310,389 ( 0.10%)   0            0          2,206,926 ( 0.08%)   0            0                       return vertices_[i];
         .               .              .                  .            .            .                  .            .            .                   else
   759,804 ( 0.01%)     96 ( 0.00%)    95 ( 0.00%)   189,951 ( 0.01%)   0            0            126,634 ( 0.00%)   0            0                       return qTemp_[k];
 3,500,340 ( 0.03%)    283 ( 0.00%)   156 ( 0.00%) 3,500,340 ( 0.10%)   0            0                  0            0            0               }
       594 ( 0.00%)    121 ( 0.00%)    22 ( 0.00%)         0            0            0                297 ( 0.00%)   0            0               double arclength(int i) const
         .               .              .                  .            .            .                  .            .            .               {
       297 ( 0.00%)      0              0                 99 ( 0.00%)   0            0                 99 ( 0.00%)   0            0                   precomputeArclengths_();
       891 ( 0.00%)      0              0                297 ( 0.00%)  96 ( 0.00%)  96 ( 0.00%)        99 ( 0.00%)   0            0                   return arclengths_[i];
       297 ( 0.00%)      0              0                198 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
     5,616 ( 0.00%)    218 ( 0.00%)   193 ( 0.00%)       624 ( 0.00%)   0            0              2,496 ( 0.00%)   0            0               T start() const
         .               .              .                  .            .            .                  .            .            .               {
     4,368 ( 0.00%)    232 ( 0.00%)   207 ( 0.00%)       624 ( 0.00%)   0            0                624 ( 0.00%)   0            0                   if(size())
     4,368 ( 0.00%)      0              0              1,248 ( 0.00%)   0            0                624 ( 0.00%)   0            0                       return operator[](0);
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                       return T();
     3,744 ( 0.00%)    221 ( 0.00%)   207 ( 0.00%)     3,120 ( 0.00%)   0            0                  0            0            0               }
     5,652 ( 0.00%)    242 ( 0.00%)   207 ( 0.00%)       628 ( 0.00%)   0            0              2,512 ( 0.00%)   0            0               T end() const
         .               .              .                  .            .            .                  .            .            .               {
     4,396 ( 0.00%)      0              0                628 ( 0.00%)   0            0                628 ( 0.00%)   0            0                   if(size())
     6,280 ( 0.00%)      0              0              1,884 ( 0.00%)   0            0              1,256 ( 0.00%)   0            0                       return operator[](size()-1);
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                       return T();
     3,768 ( 0.00%)    226 ( 0.00%)   200 ( 0.00%)     3,140 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
    58,820 ( 0.00%)     88 ( 0.00%)    30 ( 0.00%)    23,528 ( 0.00%)  17 ( 0.00%)  12 ( 0.00%)    11,764 ( 0.00%)   0            0               double ds() const { return ds_; }
       253 ( 0.00%)      3 ( 0.00%)     1 ( 0.00%)        92 ( 0.00%)   0            0                 92 ( 0.00%)  12 ( 0.00%)   9 ( 0.00%)      void setDs(double ds) {  ds_ = ds; }
       414 ( 0.00%)     34 ( 0.00%)    30 ( 0.00%)       115 ( 0.00%)   0            0                115 ( 0.00%)   0            0               void resample(double ds)    { setDs(ds); resample(); }
     2,475 ( 0.00%)    252 ( 0.00%)    36 ( 0.00%)       225 ( 0.00%)   0            0              1,125 ( 0.00%)  19 ( 0.00%)   0               void resample(bool force = false)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   // prevent resampling a curve already sampled at the same rate
       900 ( 0.00%)      0              0                225 ( 0.00%)   0            0                  0            0            0                   if(!force)
         .               .              .                  .            .            .                  .            .            .                   {
     1,576 ( 0.00%)    160 ( 0.00%)     4 ( 0.00%)       788 ( 0.00%)   5 ( 0.00%)   3 ( 0.00%)         0            0            0                       if(lastDs_ == ds_)
       168 ( 0.00%)    104 ( 0.00%)     4 ( 0.00%)         0            0            0                  0            0            0                           return;
         .               .              .                  .            .            .                  .            .            .                       else
       116 ( 0.00%)      0              0                 87 ( 0.00%)   0            0                 29 ( 0.00%)   0            0                           lastDs_ = ds_;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // We'll work on a linked list for fast insertion/deletion in the middle
         .               .              .                  .            .            .                  .            .            .                   typedef std::list<T,Eigen::aligned_allocator<T> > SampleList;
       171 ( 0.00%)     28 ( 0.00%)    14 ( 0.00%)         0            0            0                 57 ( 0.00%)   2 ( 0.00%)   0                   SampleList samples;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // First pass: copy all non-NaN samples to the list
       114 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)        57 ( 0.00%)  20 ( 0.00%)   7 ( 0.00%)        57 ( 0.00%)   2 ( 0.00%)   0                   double defaultWidth = 10;
        57 ( 0.00%)      0              0                  0            0            0                 57 ( 0.00%)   0            0                   int n = 0;
    44,849 ( 0.00%)     67 ( 0.00%)    28 ( 0.00%)    16,740 ( 0.00%)   0            0              5,656 ( 0.00%)   0            0                   for(int i=0; i<size(); ++i)
         .               .              .                  .            .            .                  .            .            .                   {
    33,252 ( 0.00%)      0              0             11,084 ( 0.00%)   0            0              5,542 ( 0.00%)   0            0                       T sample = operator[](i);
    44,336 ( 0.00%)     34 ( 0.00%)    14 ( 0.00%)         0            0            0             11,084 ( 0.00%)   0            0                       if(isnan(sample.width()))
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           sample.setWidth(defaultWidth);
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .           
   121,924 ( 0.00%)     34 ( 0.00%)    14 ( 0.00%)         0            0            0             22,168 ( 0.00%)   0            0                       if(!isnan(sample.x()) && !isnan(sample.y()))
         .               .              .                  .            .            .                  .            .            .                       {
    27,710 ( 0.00%)      0              0                  0            0            0              5,542 ( 0.00%)   0            0                           samples.push_back(sample);
     5,542 ( 0.00%)      0              0              5,542 ( 0.00%)   0            0                  0            0            0                           ++n;
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Step 1: While(n>4), Remove all (d < ds/2). Remove prelast if (dlast < ds/4)
         .               .              .                  .            .            .                  .            .            .                   //         While(n<=4), Remove all (d < eps/2), and push (eps/2 <= d < eps) to (d == eps). Remove prelast if (dlast < eps/2)
       342 ( 0.00%)      0              0                114 ( 0.00%)  22 ( 0.00%)   7 ( 0.00%)       114 ( 0.00%)   2 ( 0.00%)   0                   double halfDs = 0.5 * ds();
       342 ( 0.00%)     34 ( 0.00%)    14 ( 0.00%)       114 ( 0.00%)  23 ( 0.00%)   7 ( 0.00%)       114 ( 0.00%)   0            0                   double quarterDs = 0.25 * ds();
       285 ( 0.00%)      0              0                 57 ( 0.00%)   0            0                114 ( 0.00%)   0            0                   double eps = epsilon();
       228 ( 0.00%)     34 ( 0.00%)    14 ( 0.00%)       114 ( 0.00%)   0            0                 57 ( 0.00%)   0            0                   double halfEps = 0.5*eps;
       114 ( 0.00%)      0              0                 57 ( 0.00%)   0            0                  0            0            0                   if(n >= 3)
         .               .              .                  .            .            .                  .            .            .                   {
       228 ( 0.00%)      0              0                  0            0            0                114 ( 0.00%)   2 ( 0.00%)   0                       typename SampleList::iterator it1 = samples.begin();
       285 ( 0.00%)     34 ( 0.00%)    14 ( 0.00%)        57 ( 0.00%)   0            0                114 ( 0.00%)   0            0                       typename SampleList::iterator it2 = it1; ++it2;
       399 ( 0.00%)      0              0                  0            0            0                171 ( 0.00%)   2 ( 0.00%)   0                       typename SampleList::iterator itLast = samples.end(); --itLast;
         .               .              .                  .            .            .                  .            .            .                       // Here is the current state of the linked list:
         .               .              .                  .            .            .                  .            .            .                       //  begin=it1  it2                          last       end
         .               .              .                  .            .            .                  .            .            .                       //        ()-->()-->()-->()-->()-->()-->()-->()------>(NULL)
    38,452 ( 0.00%)     66 ( 0.00%)    28 ( 0.00%)         0            0            0              5,485 ( 0.00%)   0            0                       while(it2 != itLast)
         .               .              .                  .            .            .                  .            .            .                       {
    65,136 ( 0.00%)     32 ( 0.00%)    14 ( 0.00%)         0            0            0             21,712 ( 0.00%)   1 ( 0.00%)   0                           double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
    10,856 ( 0.00%)      0              0              5,428 ( 0.00%)   0            0                  0            0            0                           if(n<=4)
         .               .              .                  .            .            .                  .            .            .                           {
         .               .              .                  .            .            .                  .            .            .                               if(d<halfEps)
         .               .              .                  .            .            .                  .            .            .                               {
         .               .              .                  .            .            .                  .            .            .                                   it2 = samples.erase(it2);
         .               .              .                  .            .            .                  .            .            .                                   --n;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                               else
         .               .              .                  .            .            .                  .            .            .                               {
-- line 363 ----------------------------------------
-- line 366 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                                       *it2 = it1->lerp(eps/d,*it2);
         .               .              .                  .            .            .                  .            .            .                                   }
         .               .              .                  .            .            .                  .            .            .                                   ++it1;
         .               .              .                  .            .            .                  .            .            .                                   ++it2;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                           else
         .               .              .                  .            .            .                  .            .            .                           {
    16,284 ( 0.00%)     77 ( 0.00%)    28 ( 0.00%)    10,856 ( 0.00%)   0            0                  0            0            0                               if(d<halfDs)
         .               .              .                  .            .            .                  .            .            .                               {
        55 ( 0.00%)      0              0                  5 ( 0.00%)   0            0                 15 ( 0.00%)   0            0                                   it2 = samples.erase(it2);
        10 ( 0.00%)      0              0                  5 ( 0.00%)   0            0                  0            0            0                                   --n;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                               else
         .               .              .                  .            .            .                  .            .            .                               {
    16,269 ( 0.00%)      0              0                  0            0            0              5,423 ( 0.00%)   0            0                                   ++it1;
    16,269 ( 0.00%)      0              0                  0            0            0              5,423 ( 0.00%)   0            0                                   ++it2;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                       // Here is the current state of the linked list:
         .               .              .                  .            .            .                  .            .            .                       //       begin                     it1       it2=last  end
         .               .              .                  .            .            .                  .            .            .                       //        ()------->()------->()-->()------->()------>(NULL)
         .               .              .                  .            .            .                  .            .            .                       //
       627 ( 0.00%)      0              0                  0            0            0                171 ( 0.00%)   0            0                       if(it1 != samples.begin())
         .               .              .                  .            .            .                  .            .            .                       {
       684 ( 0.00%)     42 ( 0.00%)    14 ( 0.00%)         0            0            0                228 ( 0.00%)   0            0                           double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
       114 ( 0.00%)      0              0                 57 ( 0.00%)   0            0                  0            0            0                           if(n<=4)
         .               .              .                  .            .            .                  .            .            .                           {
         .               .              .                  .            .            .                  .            .            .                               if(d<halfEps)
         .               .              .                  .            .            .                  .            .            .                               {
         .               .              .                  .            .            .                  .            .            .                                   samples.erase(it1);
         .               .              .                  .            .            .                  .            .            .                                   --n;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                           else
         .               .              .                  .            .            .                  .            .            .                           {
       171 ( 0.00%)     39 ( 0.00%)    14 ( 0.00%)       114 ( 0.00%)   0            0                  0            0            0                               if(d<quarterDs)
         .               .              .                  .            .            .                  .            .            .                               {
        70 ( 0.00%)      7 ( 0.00%)     5 ( 0.00%)         7 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                                   samples.erase(it1);
         7 ( 0.00%)      0              0                  7 ( 0.00%)   0            0                  0            0            0                                   --n;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Step 2: Handle trivial cases
        57 ( 0.00%)     33 ( 0.00%)     9 ( 0.00%)         0            0            0                 57 ( 0.00%)   0            0                   bool subdivide = false;
       114 ( 0.00%)      0              0                 57 ( 0.00%)   0            0                  0            0            0                   if(n<2)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       if(n == 0)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           T sample;
         .               .              .                  .            .            .                  .            .            .                           sample.setWidth(defaultWidth);
         .               .              .                  .            .            .                  .            .            .                           samples.push_back(sample);
         .               .              .                  .            .            .                  .            .            .                           ++n;
         .               .              .                  .            .            .                  .            .            .                       }
-- line 422 ----------------------------------------
-- line 428 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                       T sample3 = sample0;
         .               .              .                  .            .            .                  .            .            .                       samples.push_back(sample1);
         .               .              .                  .            .            .                  .            .            .                       ++n;
         .               .              .                  .            .            .                  .            .            .                       samples.push_back(sample2);
         .               .              .                  .            .            .                  .            .            .                       ++n;
         .               .              .                  .            .            .                  .            .            .                       samples.push_back(sample3);
         .               .              .                  .            .            .                  .            .            .                       ++n;
         .               .              .                  .            .            .                  .            .            .                   }
       114 ( 0.00%)     42 ( 0.00%)    14 ( 0.00%)        57 ( 0.00%)   0            0                  0            0            0                   else if(n == 2)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       typename SampleList::iterator it1 = samples.begin();
         .               .              .                  .            .            .                  .            .            .                       typename SampleList::iterator it2 = it1; ++it2;
         .               .              .                  .            .            .                  .            .            .                       double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
         .               .              .                  .            .            .                  .            .            .                       if(d<halfEps)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // same as n<2, we have guarantee that the last distance will be > halfEps
         .               .              .                  .            .            .                  .            .            .                           T sample0 = *it1;
-- line 444 ----------------------------------------
-- line 484 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                               {
         .               .              .                  .            .            .                  .            .            .                                   double u = (double) i / (double) (n-1);
         .               .              .                  .            .            .                  .            .            .                                   T sample = it1->lerp(u,*it2);
         .               .              .                  .            .            .                  .            .            .                                   samples.insert(it2,sample); // insert just before it2
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
       114 ( 0.00%)     88 ( 0.00%)    28 ( 0.00%)        57 ( 0.00%)   0            0                  0            0            0                   else if(n == 3)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       typename SampleList::iterator it1 = samples.begin();
         .               .              .                  .            .            .                  .            .            .                       typename SampleList::iterator it2 = it1; ++it2;
         .               .              .                  .            .            .                  .            .            .                       typename SampleList::iterator it3 = it2; ++it3;
         .               .              .                  .            .            .                  .            .            .                       // Since p1 has survived the cleaning, we know ||p1-p0|| > eps
         .               .              .                  .            .            .                  .            .            .                       double d = it1->distanceTo(*it3); // note: could use squared distance, would be more efficient
         .               .              .                  .            .            .                  .            .            .                       if(d<halfEps)
         .               .              .                  .            .            .                  .            .            .                       {
-- line 500 ----------------------------------------
-- line 517 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // we're good
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                       // In any case, since ||p1-p0|| or ||p2-p1|| can be arbitrarily large
         .               .              .                  .            .            .                  .            .            .                       subdivide = true;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                   {
        57 ( 0.00%)     34 ( 0.00%)    14 ( 0.00%)         0            0            0                 57 ( 0.00%)   0            0                       subdivide = true;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Step 3: Subdivision scheme
       114 ( 0.00%)      0              0                 57 ( 0.00%)   0            0                  0            0            0                   if(subdivide) // Note: this implies n>=3
         .               .              .                  .            .            .                  .            .            .                   {
       171 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)         0            0            0                 57 ( 0.00%)   0            0                       SampleList subdividedSamples;
        57 ( 0.00%)      0              0                  0            0            0                 57 ( 0.00%)   0            0                       bool subdivideAgain = true;
       289 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)       116 ( 0.00%)   0            0                  0            0            0                       while(subdivideAgain)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // Initialization
        59 ( 0.00%)      2 ( 0.00%)     0                  0            0            0                 59 ( 0.00%)   0            0                           subdivideAgain = false;
       236 ( 0.00%)      0              0                  0            0            0                118 ( 0.00%)   0            0                           typename SampleList::iterator it1 = samples.begin();
       295 ( 0.00%)     31 ( 0.00%)    14 ( 0.00%)        59 ( 0.00%)   0            0                118 ( 0.00%)   0            0                           typename SampleList::iterator it2 = it1; ++it2;
       236 ( 0.00%)      0              0                  0            0            0                118 ( 0.00%)   0            0                           typename SampleList::iterator itEnd = samples.end();
       118 ( 0.00%)      0              0                 59 ( 0.00%)   0            0                 59 ( 0.00%)   2 ( 0.00%)   0                           typename SampleList::iterator itFirst = it1;
       295 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)        59 ( 0.00%)   0            0                118 ( 0.00%)   0            0                           typename SampleList::iterator itLast = itEnd; --itLast;
       472 ( 0.00%)      0              0                  0            0            0                118 ( 0.00%)   0            0                           subdividedSamples.push_back(*it1);
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                           // Main loop through list
    40,771 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)         0            0            0              5,816 ( 0.00%)   0            0                           while(it2 != itEnd)
         .               .              .                  .            .            .                  .            .            .                           {
    69,084 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)         0            0            0             23,028 ( 0.00%)   0            0                               double d = it1->distanceTo(*it2); // note: could use squared distance, would be more efficient
    46,056 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)    11,514 ( 0.00%)   0            0              5,757 ( 0.00%)   0            0                               if(d>ds()) // should subdivide
         .               .              .                  .            .            .                  .            .            .                               {
         .               .              .                  .            .            .                  .            .            .                                   // compute new sample using 4-point subdivision scheme [Dyn 1987]
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   typename SampleList::iterator it0 = it1;
        14 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         4 ( 0.00%)   1 ( 0.00%)   0                  0            0            0                                   if (isClosed_ && it0 == itFirst) it0 = itLast;
        17 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         0            0            0                  3 ( 0.00%)   0            0                                   if(it0 != itFirst) --it0;
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   typename SampleList::iterator it3 = it2;
        14 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         4 ( 0.00%)   0            0                  0            0            0                                   if (isClosed_ && it3 == itLast) it3 = itFirst;
        20 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         0            0            0                  4 ( 0.00%)   0            0                                   if(it3 != itLast) ++it3;
        16 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         0            0            0                  4 ( 0.00%)   0            0                                   T sample0 = *it0;
        16 ( 0.00%)      0              0                  0            0            0                  4 ( 0.00%)   0            0                                   T sample1 = *it1;
        16 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         0            0            0                  4 ( 0.00%)   0            0                                   T sample2 = *it2;
        16 ( 0.00%)      0              0                  0            0            0                  4 ( 0.00%)   0            0                                   T sample3 = *it3;
         .               .              .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p0(sample0.x(),sample0.y());
         .               .              .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p1(sample1.x(),sample1.y());
         .               .              .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p2(sample2.x(),sample2.y());
         .               .              .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p3(sample3.x(),sample3.y());
         4 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         2 ( 0.00%)   1 ( 0.00%)   0                  2 ( 0.00%)   0            0                                   double w = 0.0625; // i.e., 1/16
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   double halfPlusW = 0.5625; // i.e., 1/2 + 1/16
         .               .              .                  .            .            .                  .            .            .                                   //Eigen::Vector2d p = halfPlusW*(p1+p2) + w*(p0+p3);
        64 ( 0.00%)      4 ( 0.00%)     4 ( 0.00%)         4 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                                   T newSample = (sample1+sample2)*halfPlusW - (sample0+sample3)*w;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                                   // insert
        10 ( 0.00%)      1 ( 0.00%)     0                  0            0            0                  2 ( 0.00%)   0            0                                   subdividedSamples.push_back(newSample);
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                                   // recurse
         2 ( 0.00%)      0              0                  0            0            0                  2 ( 0.00%)   0            0                                   subdivideAgain = true;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // insert it2 anyway
    46,056 ( 0.00%)     32 ( 0.00%)    14 ( 0.00%)         0            0            0             11,514 ( 0.00%)   0            0                               subdividedSamples.push_back(*it2);
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // advance in list
    17,271 ( 0.00%)      0              0                  0            0            0              5,757 ( 0.00%)   0            0                               ++it1;
    17,271 ( 0.00%)      0              0                  0            0            0              5,757 ( 0.00%)   0            0                               ++it2;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                           // What to do at the end
       295 ( 0.00%)      0              0                  0            0            0                 59 ( 0.00%)   0            0                           samples.swap(subdividedSamples);
       177 ( 0.00%)      0              0                  0            0            0                 59 ( 0.00%)   0            0                           subdividedSamples.clear();
         .               .              .                  .            .            .                  .            .            .                       }
       171 ( 0.00%)      0              0                  0            0            0                 57 ( 0.00%)   0            0                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Copy back the list to the vector
       228 ( 0.00%)     33 ( 0.00%)    14 ( 0.00%)        57 ( 0.00%)   0            0                 57 ( 0.00%)   0            0                   vertices_.clear();
       228 ( 0.00%)      0              0                  0            0            0                114 ( 0.00%)   1 ( 0.00%)   0                   typename SampleList::iterator itBegin = samples.begin();
       228 ( 0.00%)      0              0                  0            0            0                114 ( 0.00%)   2 ( 0.00%)   0                   typename SampleList::iterator itEnd = samples.end();
    55,890 ( 0.00%)     74 ( 0.00%)    28 ( 0.00%)        57 ( 0.00%)   0            0             11,178 ( 0.00%)   0            0                   for(typename SampleList::iterator it = itBegin; it != itEnd; ++it)
    44,256 ( 0.00%)      0              0              5,532 ( 0.00%)   0            0             11,064 ( 0.00%)   0            0                       vertices_.push_back(*it);
       171 ( 0.00%)      0              0                 57 ( 0.00%)   0            0                 57 ( 0.00%)   0            0                   setDirtyArclengths_();
     1,578 ( 0.00%)    244 ( 0.00%)    32 ( 0.00%)     1,125 ( 0.00%)   7 ( 0.00%)   0                 57 ( 0.00%)   0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // directly set the curve to be the provided vertices, for instance
         .               .              .                  .            .            .                  .            .            .               // coming from another neatening algorithm or curve representation
         .               .              .                  .            .            .                  .            .            .               // keep the loopness it has before calling the function
         .               .              .                  .            .            .                  .            .            .               void setVertices(const std::vector<T,Eigen::aligned_allocator<T> > & newVertices)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   // clear but keep loopness
         .               .              .                  .            .            .                  .            .            .                   bool loopTmp = isClosed_;
-- line 606 ----------------------------------------
-- line 612 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                   setDirtyArclengths_();
         .               .              .                  .            .            .                  .            .            .               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // -------- Continuous curve --------
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Note: these functions ignore whatever is in qTemp
         .               .              .                  .            .            .                  .            .            .               //       so might be unexpected behaviour if called while drawing
         .               .              .                  .            .            .                  .            .            .           
     1,915 ( 0.00%)    354 ( 0.00%)    65 ( 0.00%)         0            0            0                766 ( 0.00%)   0            0               double length() const
         .               .              .                  .            .            .                  .            .            .               {
     1,149 ( 0.00%)      0              0                383 ( 0.00%)   0            0                383 ( 0.00%)   0            0                   precomputeArclengths_();
     2,298 ( 0.00%)      0              0                766 ( 0.00%)  12 ( 0.00%)   7 ( 0.00%)       383 ( 0.00%)   0            0                   return arclengths_.back();
     1,149 ( 0.00%)      0              0                766 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
    11,380 ( 0.00%)    531 ( 0.00%)    11 ( 0.00%)     1,138 ( 0.00%)   0            0              5,690 ( 0.00%)   0            0               T operator() (double s) const
         .               .              .                  .            .            .                  .            .            .               {
     5,690 ( 0.00%)    538 ( 0.00%)    25 ( 0.00%)     1,138 ( 0.00%)   0            0              2,276 ( 0.00%)   0            0                   std::size_t n = vertices_.size();
     2,276 ( 0.00%)      0              0              1,138 ( 0.00%)   0            0                  0            0            0                   assert(n>0);
     2,276 ( 0.00%)      0              0              1,138 ( 0.00%)   0            0                  0            0            0                   if(n == 1)
         .               .              .                  .            .            .                  .            .            .                       return vertices_.front();
         .               .              .                  .            .            .                  .            .            .                   else
     7,966 ( 0.00%)    373 ( 0.00%)    25 ( 0.00%)     3,414 ( 0.00%)   0            0              1,138 ( 0.00%)   0            0                       return interpolatedVertex_(s);
     6,828 ( 0.00%)    538 ( 0.00%)    25 ( 0.00%)     5,690 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // -------- Apply affine transform --------
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               Curve<T> transformed(const Eigen::Affine2d & xf)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   Curve<T> res(*this);
         .               .              .                  .            .            .                  .            .            .                   res.transform(xf);
-- line 642 ----------------------------------------
-- line 667 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       vertices_[i].setX(vertices_[i].x() + dx);
         .               .              .                  .            .            .                  .            .            .                       vertices_[i].setY(vertices_[i].y() + dy);
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // return -1 if no vertices
         .               .              .                  .            .            .                  .            .            .               struct ClosestVertex { int i; double d; };
     1,089 ( 0.00%)     11 ( 0.00%)    11 ( 0.00%)        99 ( 0.00%)   0            0                594 ( 0.00%)   0            0               ClosestVertex findClosestVertex(double x, double y) const
         .               .              .                  .            .            .                  .            .            .               {
       198 ( 0.00%)     11 ( 0.00%)    11 ( 0.00%)        99 ( 0.00%)  11 ( 0.00%)  11 ( 0.00%)        99 ( 0.00%)   0            0                   double minD2 = std::numeric_limits<double>::max();
        99 ( 0.00%)      0              0                  0            0            0                 99 ( 0.00%)   0            0                   int i = -1;
       198 ( 0.00%)      0              0                 99 ( 0.00%)   0            0                 99 ( 0.00%)   0            0                   int minI = i;
   154,143 ( 0.00%)     33 ( 0.00%)    33 ( 0.00%)       297 ( 0.00%)   0            0             34,430 ( 0.00%)   0            0                   for(auto v: vertices_)
         .               .              .                  .            .            .                  .            .            .                   {
     8,459 ( 0.00%)      0              0              8,459 ( 0.00%)   0            0                  0            0            0                       ++i;
    59,213 ( 0.00%)     11 ( 0.00%)    11 ( 0.00%)     8,459 ( 0.00%)   0            0             16,918 ( 0.00%)   0            0                       double dx = x-v.x();
    59,213 ( 0.00%)      0              0              8,459 ( 0.00%)   0            0             16,918 ( 0.00%)   0            0                       double dy = y-v.y();
    59,213 ( 0.00%)      0              0             16,918 ( 0.00%)   0            0              8,459 ( 0.00%)   0            0                       double d2 = dx*dx + dy*dy;
    25,377 ( 0.00%)      0              0             16,918 ( 0.00%)   0            0                  0            0            0                       if(d2<minD2)
         .               .              .                  .            .            .                  .            .            .                       {
     3,846 ( 0.00%)      0              0              1,923 ( 0.00%)   0            0              1,923 ( 0.00%)   0            0                           minD2 = d2;
     3,846 ( 0.00%)      0              0              1,923 ( 0.00%)   0            0              1,923 ( 0.00%)   0            0                           minI = i;
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
       693 ( 0.00%)      0              0                198 ( 0.00%)   0            0                297 ( 0.00%)   0            0                   ClosestVertex res = { minI, sqrt(minD2) };
       792 ( 0.00%)     11 ( 0.00%)    11 ( 0.00%)       198 ( 0.00%)   0            0                  0            0            0                   return res;
       693 ( 0.00%)      0              0                495 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               double prepareSculpt(double x, double y, double radius)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   ClosestVertex v = findClosestVertex(x,y);
         .               .              .                  .            .            .                  .            .            .                   sculptIndex_ = v.i;
         .               .              .                  .            .            .                  .            .            .                   sculptRadius_ = radius;
         .               .              .                  .            .            .                  .            .            .                   return v.d;
         .               .              .                  .            .            .                  .            .            .               }
-- line 702 ----------------------------------------
-- line 1005 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               //void beginSculptDeform()
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // -------- Intersections --------
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // helper method: returns det(U,V)
       483 ( 0.00%)     11 ( 0.00%)     3 ( 0.00%)         0            0            0                345 ( 0.00%)   0            0               inline static double det(double ux, double uy,
         .               .              .                  .            .            .                  .            .            .                                        double vx, double vy)
         .               .              .                  .            .            .                  .            .            .               {
       414 ( 0.00%)     11 ( 0.00%)     8 ( 0.00%)       276 ( 0.00%)   0            0                  0            0            0                   return ux*vy - uy*vx;
       207 ( 0.00%)      0              0                138 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // helper method: returns whether the segments [AB] and [CD] intersect, with a margin of error epsilon
         .               .              .                  .            .            .                  .            .            .               //                if yes, the intersection P is P = A + u * (B-A) = C + v * (D-C)
 7,097,328 ( 0.06%)    126 ( 0.00%)    28 ( 0.00%)         0            0            0          5,576,472 ( 0.20%)   0            0               inline static bool intersects(
         .               .              .                  .            .            .                  .            .            .                       // input
         .               .              .                  .            .            .                  .            .            .                       double ax, double ay,
         .               .              .                  .            .            .                  .            .            .                       double bx, double by,
         .               .              .                  .            .            .                  .            .            .                       double cx, double cy,
         .               .              .                  .            .            .                  .            .            .                       double dx, double dy,
         .               .              .                  .            .            .                  .            .            .                       // output
         .               .              .                  .            .            .                  .            .            .                       double & u, double & v,
         .               .              .                  .            .            .                  .            .            .                       // parameters
         .               .              .                  .            .            .                  .            .            .                       double epsilon = 1e-10)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   // fast pruning. In if size screen > 100 * ds, then in > 98% of the time, 4 assignments and <= 4 comparisons
         .               .              .                  .            .            .                  .            .            .                   double minABx, maxABx;
 3,968,148 ( 0.03%)     20 ( 0.00%)     6 ( 0.00%) 2,027,808 ( 0.06%)   0            0          1,013,904 ( 0.04%)   0            0                   if(ax < bx)    { minABx = ax; maxABx = bx; } else { minABx = bx; maxABx = ax; }
         .               .              .                  .            .            .                  .            .            .                   double minCDx, maxCDx;
 3,861,346 ( 0.03%)     73 ( 0.00%)    14 ( 0.00%) 2,027,808 ( 0.06%)   0            0          1,013,904 ( 0.04%)   0            0                   if(cx < dx)    { minCDx = cx; maxCDx = dx; } else { minCDx = dx; maxCDx = cx; }
 2,031,834 ( 0.02%)     33 ( 0.00%)     8 ( 0.00%) 1,354,556 ( 0.04%)   0            0                  0            0            0                   if(minABx > maxCDx || minCDx > maxABx)
 1,007,944 ( 0.01%)      0              0                  0            0            0                  0            0            0                       return false;
         .               .              .                  .            .            .                  .            .            .                   // in > 99.98% of the time, <= 8 assignments and <= 8 comparisons
         .               .              .                  .            .            .                  .            .            .                   double minABy, maxABy;
    22,849 ( 0.00%)     28 ( 0.00%)    13 ( 0.00%)    11,920 ( 0.00%)   0            0              5,960 ( 0.00%)   0            0                   if(ay < by)    { minABy = ay; maxABy = by; } else { minABy = by; maxABy = ay; }
         .               .              .                  .            .            .                  .            .            .                   double minCDy, maxCDy;
    22,891 ( 0.00%)     28 ( 0.00%)    13 ( 0.00%)    11,920 ( 0.00%)   0            0              5,960 ( 0.00%)   0            0                   if(cy < dy)    { minCDy = cy; maxCDy = dy; } else { minCDy = dy; maxCDy = cy; }
    12,399 ( 0.00%)     11 ( 0.00%)     6 ( 0.00%)     8,266 ( 0.00%)   0            0                  0            0            0                   if(minABy > maxCDy || minCDy > maxABy)
     5,914 ( 0.00%)     15 ( 0.00%)     7 ( 0.00%)         0            0            0                  0            0            0                       return false;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // actual computation
       368 ( 0.00%)     11 ( 0.00%)     8 ( 0.00%)       184 ( 0.00%)   0            0                 46 ( 0.00%)   0            0                   double det_ = det(bx-ax, by-ay, dx-cx, dy-cy); // det(AB,CD)
       368 ( 0.00%)     22 ( 0.00%)    16 ( 0.00%)       184 ( 0.00%)   0            0                 46 ( 0.00%)   0            0                   double numU = det(dx-cx, dy-cy, ax-cx, ay-cy); // det(CD,AC)
       368 ( 0.00%)     11 ( 0.00%)     8 ( 0.00%)       184 ( 0.00%)   0            0                 46 ( 0.00%)   0            0                   double numV = det(bx-ax, by-ay, ax-cx, ay-cy); // det(AB,AC)
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // if parallel
       184 ( 0.00%)      0              0                 46 ( 0.00%)   0            0                 23 ( 0.00%)   0            0                   if(std::abs(det_) < epsilon)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       return false; // consider not intersecting if nearly parallel, by design.
         .               .              .                  .            .            .                  .            .            .                                     // if you consider changing this, make sure to think about it
         .               .              .                  .            .            .                  .            .            .                                     // full-time during at least one month. If you still think
         .               .              .                  .            .            .                  .            .            .                                     // it is a good idea, then implement it. Then revert your changes
         .               .              .                  .            .            .                  .            .            .                                     // when you realize how big this mistake was. Trust me, you will.
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                   {
        69 ( 0.00%)     11 ( 0.00%)     8 ( 0.00%)        46 ( 0.00%)   8 ( 0.00%)   8 ( 0.00%)        23 ( 0.00%)   0            0                       double invDet = 1/det_;
        92 ( 0.00%)      0              0                 69 ( 0.00%)   0            0                 23 ( 0.00%)   0            0                       u = numU * invDet;
        92 ( 0.00%)      0              0                 69 ( 0.00%)   0            0                 23 ( 0.00%)   0            0                       v = numV * invDet;
       560 ( 0.00%)     22 ( 0.00%)    16 ( 0.00%)       320 ( 0.00%)   0            0                  0            0            0                       if(u>=-epsilon && u<1+epsilon && v>=-epsilon && v<1+epsilon)
        14 ( 0.00%)      0              0                  0            0            0                  0            0            0                          return true;
         .               .              .                  .            .            .                  .            .            .                       else
        16 ( 0.00%)      0              0                  0            0            0                  0            0            0                          return false;
         .               .              .                  .            .            .                  .            .            .                   }
 1,013,904 ( 0.01%)     54 ( 0.00%)    14 ( 0.00%) 1,013,904 ( 0.03%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .               // helper method provided for convenience:
         .               .              .                  .            .            .                  .            .            .               //                returns whether the segments [AB] and [CD] intersect, with a margin of error epsilon
         .               .              .                  .            .            .                  .            .            .               //                if yes, the intersection P is P = A + u * (B-A) = C + v * (D-C)
 8,111,232 ( 0.06%)     52 ( 0.00%)    28 ( 0.00%)         0            0            0          6,590,376 ( 0.23%)   0            0               inline static bool intersects(
         .               .              .                  .            .            .                  .            .            .                       // input
         .               .              .                  .            .            .                  .            .            .                       T & a, T & b,
         .               .              .                  .            .            .                  .            .            .                       T & c, T & d,
         .               .              .                  .            .            .                  .            .            .                       // output
         .               .              .                  .            .            .                  .            .            .                       double & u, double & v,
         .               .              .                  .            .            .                  .            .            .                       // parameters
         .               .              .                  .            .            .                  .            .            .                       double epsilon = 1e-10)
         .               .              .                  .            .            .                  .            .            .               {
24,333,696 ( 0.19%)    149 ( 0.00%)    42 ( 0.00%) 6,590,376 ( 0.20%)   0            0          6,083,424 ( 0.21%)   0            0                   return intersects(a.x(), a.y(),
         .               .              .                  .            .            .                  .            .            .                                     b.x(), b.y(),
         .               .              .                  .            .            .                  .            .            .                                     c.x(), c.y(),
         .               .              .                  .            .            .                  .            .            .                                     d.x(), d.y(),
         .               .              .                  .            .            .                  .            .            .                                     u, v,
         .               .              .                  .            .            .                  .            .            .                                     epsilon);
 4,055,616 ( 0.03%)      0              0          3,548,664 ( 0.11%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Compute unclean intersections.
         .               .              .                  .            .            .                  .            .            .               // May have duplicates. May miss some if segments nearly parallel.
         .               .              .                  .            .            .                  .            .            .               // Includes "virtual intersections": when extending the end of the curve by tolerance would create a new intersection.
         .               .              .                  .            .            .                  .            .            .               // Return value not sorted.
       588 ( 0.00%)     98 ( 0.00%)    24 ( 0.00%)        49 ( 0.00%)   0            0                343 ( 0.00%)   0            0               std::vector<Intersection> intersections(const SculptCurve::Curve<T> & other, double tolerance = 15.0) const
         .               .              .                  .            .            .                  .            .            .               {
       147 ( 0.00%)      0              0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   precomputeArclengths_();
       147 ( 0.00%)      0              0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   other.precomputeArclengths_();
         .               .              .                  .            .            .                  .            .            .           
       147 ( 0.00%)      0              0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   std::vector<Intersection> res;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Returns in trivial cases
       196 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)        49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   int n = size();
       196 ( 0.00%)      0              0                 49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   int nOther = other.size();
       196 ( 0.00%)      0              0                 98 ( 0.00%)   0            0                  0            0            0                   if(n<2 || nOther<2)
         .               .              .                  .            .            .                  .            .            .                       return res;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // store min/max
       245 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)        49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   double l = length();
       245 ( 0.00%)      0              0                 49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                   double lOther = other.length();
        98 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)        49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   double minS = l;
        98 ( 0.00%)      0              0                  0            0            0                 49 ( 0.00%)   0            0                   double maxS = 0;
        98 ( 0.00%)      0              0                 49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   double minT = lOther;
        98 ( 0.00%)      0              0                  0            0            0                 49 ( 0.00%)   0            0                   double maxT = 0;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   double u, v;
    22,944 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)    13,688 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                   for(int i=0; i<n-1; ++i)
         .               .              .                  .            .            .                  .            .            .                   {
    27,180 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)     9,060 ( 0.00%)   0            0              4,530 ( 0.00%)   0            0                       T va = (*this)[i];
    31,710 ( 0.00%)      0              0              9,060 ( 0.00%)   0            0              4,530 ( 0.00%)   0            0                       T vb = (*this)[i+1];
 1,975,050 ( 0.02%)     98 ( 0.00%)    24 ( 0.00%) 1,177,782 ( 0.03%)   0            0              4,530 ( 0.00%)   0            0                       for(int j=0; j<nOther-1; ++j)
         .               .              .                  .            .            .                  .            .            .                       {
 2,337,444 ( 0.02%)      0              0            779,148 ( 0.02%)   0            0            389,574 ( 0.01%)   0            0                           T vc = other[j];
 2,727,018 ( 0.02%)     49 ( 0.00%)    12 ( 0.00%)   779,148 ( 0.02%)   0            0            389,574 ( 0.01%)   0            0                           T vd = other[j+1];
         .               .              .                  .            .            .                  .            .            .           
 4,285,314 ( 0.03%)      0              0            389,574 ( 0.01%)   0            0            779,148 ( 0.03%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
   779,148 ( 0.01%)     41 ( 0.00%)    12 ( 0.00%)   389,574 ( 0.01%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
        56 ( 0.00%)      4 ( 0.00%)     4 ( 0.00%)        22 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                               double s = (1-u)*arclengths_[i] + u*arclengths_[i+1];
        56 ( 0.00%)      4 ( 0.00%)     4 ( 0.00%)        22 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                               double t = (1-v)*other.arclengths_[j] + v*other.arclengths_[j+1];
        24 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         6 ( 0.00%)   0            0                  4 ( 0.00%)   0            0                               res.push_back(Intersection(s,t));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // update min/max
         6 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         4 ( 0.00%)   0            0                  0            0            0                               if(s<minS)
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   minS = s;
         6 ( 0.00%)      0              0                  4 ( 0.00%)   0            0                  0            0            0                               if(s>maxS)
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   maxS = s;
         6 ( 0.00%)      0              0                  4 ( 0.00%)   0            0                  0            0            0                               if(t<minT)
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   minT = t;
         6 ( 0.00%)      0              0                  4 ( 0.00%)   0            0                  0            0            0                               if(t>maxT)
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   maxT = t;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Compute endpoints intersections
       382 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)       192 ( 0.00%)   0            0                  0            0            0                   if(minS > tolerance && !isClosed_) // start of this
         .               .              .                  .            .            .                  .            .            .                   {
       423 ( 0.00%)     47 ( 0.00%)    11 ( 0.00%)        47 ( 0.00%)   0            0                 94 ( 0.00%)   0            0                       T va = vertices_.front();
       329 ( 0.00%)      0              0                 94 ( 0.00%)   0            0                 47 ( 0.00%)   0            0                       T ve = (*this)(tolerance);
       376 ( 0.00%)     47 ( 0.00%)    11 ( 0.00%)        47 ( 0.00%)   0            0                 47 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
    21,902 ( 0.00%)     19 ( 0.00%)    11 ( 0.00%)    13,066 ( 0.00%)   0            0                 47 ( 0.00%)   0            0                       for(int j=0; j<nOther-1; ++j)
         .               .              .                  .            .            .                  .            .            .                       {
    25,944 ( 0.00%)      0              0              8,648 ( 0.00%)   0            0              4,324 ( 0.00%)   0            0                           T vc = other[j];
    30,268 ( 0.00%)     47 ( 0.00%)    11 ( 0.00%)     8,648 ( 0.00%)   0            0              4,324 ( 0.00%)   0            0                           T vd = other[j+1];
         .               .              .                  .            .            .                  .            .            .           
    47,564 ( 0.00%)     47 ( 0.00%)    11 ( 0.00%)     4,324 ( 0.00%)   0            0              8,648 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
     8,648 ( 0.00%)      0              0              4,324 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
         4 ( 0.00%)      0              0                  0            0            0                  2 ( 0.00%)   0            0                               double s = 0;
        56 ( 0.00%)      6 ( 0.00%)     6 ( 0.00%)        22 ( 0.00%)   0            0                 10 ( 0.00%)   0            0                               double t = (1-v)*other.arclengths_[j] + v*other.arclengths_[j+1];
        24 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         6 ( 0.00%)   0            0                  4 ( 0.00%)   0            0                               res.push_back(Intersection(s,t));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // update min/max
         6 ( 0.00%)      0              0                  4 ( 0.00%)   0            0                  0            0            0                               if(s<minS)
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   minS = s;
         6 ( 0.00%)      0              0                  4 ( 0.00%)   0            0                  0            0            0                               if(s>maxS)
         .               .              .                  .            .            .                  .            .            .                                   maxS = s;
         6 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         4 ( 0.00%)   0            0                  0            0            0                               if(t<minT)
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   minT = t;
         6 ( 0.00%)      0              0                  4 ( 0.00%)   0            0                  0            0            0                               if(t>maxT)
         4 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   maxT = t;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
       441 ( 0.00%)     47 ( 0.00%)    13 ( 0.00%)       245 ( 0.00%)   0            0                  0            0            0                   if(maxS < l-tolerance && !isClosed_) // end of this
         .               .              .                  .            .            .                  .            .            .                   {
       441 ( 0.00%)     46 ( 0.00%)    12 ( 0.00%)        49 ( 0.00%)   0            0                 98 ( 0.00%)   0            0                       T va = vertices_.back();
       441 ( 0.00%)      0              0                147 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                       T ve = (*this)(l-tolerance);
       392 ( 0.00%)     35 ( 0.00%)    12 ( 0.00%)        49 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
    23,224 ( 0.00%)     46 ( 0.00%)    12 ( 0.00%)    13,856 ( 0.00%)   0            0                 49 ( 0.00%)   0            0                       for(int j=0; j<nOther-1; ++j)
         .               .              .                  .            .            .                  .            .            .                       {
    27,516 ( 0.00%)     12 ( 0.00%)    12 ( 0.00%)     9,172 ( 0.00%)   0            0              4,586 ( 0.00%)   0            0                           T vc = other[j];
    32,102 ( 0.00%)      0              0              9,172 ( 0.00%)   0            0              4,586 ( 0.00%)   0            0                           T vd = other[j+1];
         .               .              .                  .            .            .                  .            .            .           
    50,446 ( 0.00%)     42 ( 0.00%)    12 ( 0.00%)     4,586 ( 0.00%)   0            0              9,172 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
     9,172 ( 0.00%)      0              0              4,586 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
         .               .              .                  .            .            .                  .            .            .                               double s = l;
         .               .              .                  .            .            .                  .            .            .                               double t = (1-v)*other.arclengths_[j] + v*other.arclengths_[j+1];
         .               .              .                  .            .            .                  .            .            .                               res.push_back(Intersection(s,t));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // update min/max
         .               .              .                  .            .            .                  .            .            .                               if(s<minS)
         .               .              .                  .            .            .                  .            .            .                                   minS = s;
-- line 1198 ----------------------------------------
-- line 1200 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                                   maxS = s;
         .               .              .                  .            .            .                  .            .            .                               if(t<minT)
         .               .              .                  .            .            .                  .            .            .                                   minT = t;
         .               .              .                  .            .            .                  .            .            .                               if(t>maxT)
         .               .              .                  .            .            .                  .            .            .                                   maxT = t;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
       387 ( 0.00%)     49 ( 0.00%)    12 ( 0.00%)       194 ( 0.00%)   0            0                  0            0            0                   if(minT > tolerance && !other.isClosed_) // start of other
         .               .              .                  .            .            .                  .            .            .                   {
       288 ( 0.00%)     32 ( 0.00%)     8 ( 0.00%)        32 ( 0.00%)   0            0                 64 ( 0.00%)   0            0                       T va = other.vertices_.front();
       224 ( 0.00%)      0              0                 64 ( 0.00%)   0            0                 32 ( 0.00%)   0            0                       T ve = other(tolerance);
       256 ( 0.00%)     32 ( 0.00%)     8 ( 0.00%)        32 ( 0.00%)   0            0                 32 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
    16,422 ( 0.00%)     61 ( 0.00%)    13 ( 0.00%)     9,802 ( 0.00%)   0            0                 32 ( 0.00%)   0            0                       for(int i=0; i<n-1; ++i)
         .               .              .                  .            .            .                  .            .            .                       {
    38,952 ( 0.00%)     32 ( 0.00%)     8 ( 0.00%)     6,492 ( 0.00%)   0            0              6,492 ( 0.00%)   0            0                           T vc = vertices_[i];
    42,198 ( 0.00%)     29 ( 0.00%)     8 ( 0.00%)     6,492 ( 0.00%)   0            0              6,492 ( 0.00%)   0            0                           T vd = vertices_[i+1];
         .               .              .                  .            .            .                  .            .            .           
    35,706 ( 0.00%)     19 ( 0.00%)     8 ( 0.00%)     3,246 ( 0.00%)   0            0              6,492 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
     6,492 ( 0.00%)      0              0              3,246 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
         .               .              .                  .            .            .                  .            .            .                               double t = 0;
         .               .              .                  .            .            .                  .            .            .                               double s = (1-v)*arclengths_[i] + v*arclengths_[i+1];
         .               .              .                  .            .            .                  .            .            .                               res.push_back(Intersection(s,t));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // update min/max
         .               .              .                  .            .            .                  .            .            .                               if(s<minS)
         .               .              .                  .            .            .                  .            .            .                                   minS = s;
-- line 1227 ----------------------------------------
-- line 1229 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                                   maxS = s;
         .               .              .                  .            .            .                  .            .            .                               if(t<minT)
         .               .              .                  .            .            .                  .            .            .                                   minT = t;
         .               .              .                  .            .            .                  .            .            .                               if(t>maxT)
         .               .              .                  .            .            .                  .            .            .                                   maxT = t;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
       441 ( 0.00%)     66 ( 0.00%)    19 ( 0.00%)       245 ( 0.00%)   0            0                  0            0            0                   if(maxS < l-tolerance && !other.isClosed_) // end of this
         .               .              .                  .            .            .                  .            .            .                   {
       297 ( 0.00%)      0              0                 33 ( 0.00%)   0            0                 66 ( 0.00%)   0            0                       T va = other.vertices_.back();
       297 ( 0.00%)     33 ( 0.00%)     8 ( 0.00%)        99 ( 0.00%)   0            0                 33 ( 0.00%)   0            0                       T ve = other(lOther-tolerance);
       264 ( 0.00%)     33 ( 0.00%)     8 ( 0.00%)        33 ( 0.00%)   0            0                 33 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
    16,718 ( 0.00%)     33 ( 0.00%)     8 ( 0.00%)     9,978 ( 0.00%)   0            0                 33 ( 0.00%)   0            0                       for(int i=0; i<n-1; ++i)
         .               .              .                  .            .            .                  .            .            .                       {
    39,648 ( 0.00%)     33 ( 0.00%)     8 ( 0.00%)     6,608 ( 0.00%)   0            0              6,608 ( 0.00%)   0            0                           T vc = vertices_[i];
    42,952 ( 0.00%)     33 ( 0.00%)     8 ( 0.00%)     6,608 ( 0.00%)   0            0              6,608 ( 0.00%)   0            0                           T vd = vertices_[i+1];
         .               .              .                  .            .            .                  .            .            .           
    36,344 ( 0.00%)      0              0              3,304 ( 0.00%)   0            0              6,608 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
     6,608 ( 0.00%)     33 ( 0.00%)     8 ( 0.00%)     3,304 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
         2 ( 0.00%)      0              0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                               double t = lOther;
        28 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)        11 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                               double s = (1-v)*arclengths_[i] + v*arclengths_[i+1];
        12 ( 0.00%)      1 ( 0.00%)     1 ( 0.00%)         3 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                               res.push_back(Intersection(s,t));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // update min/max
         3 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  0            0            0                               if(s<minS)
         2 ( 0.00%)      1 ( 0.00%)     1 ( 0.00%)         1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   minS = s;
         3 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  0            0            0                               if(s>maxS)
         2 ( 0.00%)      0              0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   maxS = s;
         3 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  0            0            0                               if(t<minT)
         .               .              .                  .            .            .                  .            .            .                                   minT = t;
         3 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  0            0            0                               if(t>maxT)
         2 ( 0.00%)      0              0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   maxT = t;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
        82 ( 0.00%)     16 ( 0.00%)     7 ( 0.00%)         0            0            0                  0            0            0                   return res;
       343 ( 0.00%)     44 ( 0.00%)    10 ( 0.00%)       294 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Compute unclean self-intersections.
         .               .              .                  .            .            .                  .            .            .               // May have duplicates. May miss some if segments nearly parallel.
         .               .              .                  .            .            .                  .            .            .               // Includes "virtual intersections": when extending the end of the curve by tolerance would create a new intersection.
         .               .              .                  .            .            .                  .            .            .               // Return value not sorted.
       154 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 84 ( 0.00%)   0            0               std::vector<Intersection> selfIntersections(double tolerance = 15.0) const
         .               .              .                  .            .            .                  .            .            .               {
        42 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   precomputeArclengths_();
         .               .              .                  .            .            .                  .            .            .           
        42 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   std::vector<Intersection> res;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Returns in trivial cases
        56 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                   int n = size();
        28 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                  0            0            0                   if(n<4)
         .               .              .                  .            .            .                  .            .            .                       return res;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // store min/max
        70 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                   double l = length();
        28 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   double minS = l;
        28 ( 0.00%)      0              0                  0            0            0                 14 ( 0.00%)   0            0                   double maxS = 0;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   double u, v;
     6,924 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)     4,132 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   for(int i=0; i<n-3; ++i)
         .               .              .                  .            .            .                  .            .            .                   {
     8,208 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)     2,736 ( 0.00%)   0            0              1,368 ( 0.00%)   0            0                       T va = (*this)[i];
     9,576 ( 0.00%)      0              0              2,736 ( 0.00%)   0            0              1,368 ( 0.00%)   0            0                       T vb = (*this)[i+1];
   509,269 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)   303,099 ( 0.01%)   0            0              1,368 ( 0.00%)   0            0                       for(int j=i+2; j<n-1; ++j)
         .               .              .                  .            .            .                  .            .            .                       {
   597,990 ( 0.00%)      0              0            199,330 ( 0.01%)   0            0             99,665 ( 0.00%)   0            0                           T vc = (*this)[j];
   697,655 ( 0.01%)     14 ( 0.00%)    14 ( 0.00%)   199,330 ( 0.01%)   0            0             99,665 ( 0.00%)   0            0                           T vd = (*this)[j+1];
         .               .              .                  .            .            .                  .            .            .           
 1,096,315 ( 0.01%)     14 ( 0.00%)    14 ( 0.00%)    99,665 ( 0.00%)  14 ( 0.00%)  14 ( 0.00%)   199,330 ( 0.01%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
   199,330 ( 0.00%)      0              0             99,665 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
        28 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)        11 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                               double s = (1-u)*arclengths_[i] + u*arclengths_[i+1];
        28 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)        11 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                               double t = (1-v)*arclengths_[j] + v*arclengths_[j+1];
        12 ( 0.00%)      1 ( 0.00%)     1 ( 0.00%)         3 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                               res.push_back(Intersection(s,t));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // update min/max
         3 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  0            0            0                               if(s<minS)
         2 ( 0.00%)      0              0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   minS = s;
         3 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  0            0            0                               if(t>maxS)
         2 ( 0.00%)      0              0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   maxS = t;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Compute endpoints intersections
       107 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        54 ( 0.00%)   0            0                  0            0            0                   if(minS > tolerance && !isClosed_) // start
         .               .              .                  .            .            .                  .            .            .                   {
       117 ( 0.00%)     13 ( 0.00%)    13 ( 0.00%)        13 ( 0.00%)   0            0                 26 ( 0.00%)   0            0                       T va = vertices_.front();
        91 ( 0.00%)      0              0                 26 ( 0.00%)   0            0                 13 ( 0.00%)   0            0                       T ve = (*this)(tolerance);
       104 ( 0.00%)     13 ( 0.00%)    13 ( 0.00%)        13 ( 0.00%)   0            0                 13 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
     5,828 ( 0.00%)     13 ( 0.00%)    13 ( 0.00%)     3,476 ( 0.00%)   0            0                 13 ( 0.00%)   0            0                       for(int j=1; j<n-1; ++j)
         .               .              .                  .            .            .                  .            .            .                       {
     6,900 ( 0.00%)     13 ( 0.00%)    13 ( 0.00%)     2,300 ( 0.00%)   0            0              1,150 ( 0.00%)   0            0                           T vc = (*this)[j];
     8,050 ( 0.00%)      0              0              2,300 ( 0.00%)   0            0              1,150 ( 0.00%)   0            0                           T vd = (*this)[j+1];
         .               .              .                  .            .            .                  .            .            .           
    12,650 ( 0.00%)     13 ( 0.00%)    13 ( 0.00%)     1,150 ( 0.00%)   0            0              2,300 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
     2,300 ( 0.00%)      0              0              1,150 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
        28 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)        11 ( 0.00%)   0            0                  5 ( 0.00%)   0            0                               double t = (1-v)*arclengths_[j] + v*arclengths_[j+1];
        12 ( 0.00%)      1 ( 0.00%)     1 ( 0.00%)         3 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                               res.push_back(Intersection(0,t));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // update min/max
         3 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  0            0            0                               if(t>maxS)
         2 ( 0.00%)      0              0                  1 ( 0.00%)   0            0                  1 ( 0.00%)   0            0                                   maxS = t;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
       116 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        66 ( 0.00%)   0            0                  0            0            0                   if(maxS < l-tolerance && !isClosed_) // end
         .               .              .                  .            .            .                  .            .            .                   {
       108 ( 0.00%)     12 ( 0.00%)    12 ( 0.00%)        12 ( 0.00%)   0            0                 24 ( 0.00%)   0            0                       T va = vertices_.back();
       108 ( 0.00%)     12 ( 0.00%)    12 ( 0.00%)        36 ( 0.00%)   0            0                 12 ( 0.00%)   0            0                       T ve = (*this)(l-tolerance);
        96 ( 0.00%)      0              0                 12 ( 0.00%)   0            0                 12 ( 0.00%)   0            0                       T vb = ve.lerp(2.0, va);
     5,587 ( 0.00%)     24 ( 0.00%)    24 ( 0.00%)     3,333 ( 0.00%)   0            0                 12 ( 0.00%)   0            0                       for(int j=0; j<n-3; ++j)
         .               .              .                  .            .            .                  .            .            .                       {
     6,618 ( 0.00%)      0              0              2,206 ( 0.00%)   0            0              1,103 ( 0.00%)   0            0                           T vc = (*this)[j];
     7,721 ( 0.00%)      0              0              2,206 ( 0.00%)   0            0              1,103 ( 0.00%)   0            0                           T vd = (*this)[j+1];
         .               .              .                  .            .            .                  .            .            .           
    12,133 ( 0.00%)     12 ( 0.00%)    12 ( 0.00%)     1,103 ( 0.00%)   0            0              2,206 ( 0.00%)   0            0                           bool doIntersect = intersects(va, vb, vc, vd, u, v);
     2,206 ( 0.00%)     12 ( 0.00%)    12 ( 0.00%)     1,103 ( 0.00%)   0            0                  0            0            0                           if(doIntersect)
         .               .              .                  .            .            .                  .            .            .                           {
         .               .              .                  .            .            .                  .            .            .                               double t = (1-v)*arclengths_[j] + v*arclengths_[j+1];
         .               .              .                  .            .            .                  .            .            .                               res.push_back(Intersection(t,l));
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
        28 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         0            0            0                  0            0            0                   return res;
        98 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        84 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Split the curve: guarantees that res.size() = splitValues.size() - 1
         .               .              .                  .            .            .                  .            .            .               // Input: split values. e.g : [0, 230, l]
         .               .              .                  .            .            .                  .            .            .               // Output: a list of curves: [subcurve(0->230) , subcurve(230->l)]
         .               .              .                  .            .            .                  .            .            .               // splitValues must have a size>=2 to return a non-empty vector
         .               .              .                  .            .            .                  .            .            .               // if the curve is a loop, the values are expected to be in the range 0..l except the last one
         .               .              .                  .            .            .                  .            .            .               // and be like: [ s1 s2 s3 ... sn s1+l ]
       143 ( 0.00%)     26 ( 0.00%)    20 ( 0.00%)        13 ( 0.00%)   0            0                 78 ( 0.00%)   0            0               std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  > split(const std::vector<double> & splitValues) const
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   using std::cout;
         .               .              .                  .            .            .                  .            .            .                   using std::endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   //cout << "\n\n\n ########### Entering split #########" << endl;
         .               .              .                  .            .            .                  .            .            .                   //cout << "Split values:";
         .               .              .                  .            .            .                  .            .            .                   //for(auto s: splitValues)
         .               .              .                  .            .            .                  .            .            .                   //    std::cout << " " << s;
         .               .              .                  .            .            .                  .            .            .                   //cout << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // for numerical corner cases: when one split value is exactly a vertex
         .               .              .                  .            .            .                  .            .            .                   //double epsilon = 1e-5;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // get number of split required.
        52 ( 0.00%)      0              0                 13 ( 0.00%)   0            0                 26 ( 0.00%)   0            0                   const int nSplitValues = static_cast<int>(splitValues.size());
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // trivial cases
        26 ( 0.00%)      0              0                 13 ( 0.00%)   0            0                  0            0            0                   if(nSplitValues < 2)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       //cout << "not enough split values" << endl;
         .               .              .                  .            .            .                  .            .            .                       return std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  >();
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
        52 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)        13 ( 0.00%)   0            0                 26 ( 0.00%)   0            0                   int n = size();
        26 ( 0.00%)      0              0                 13 ( 0.00%)   0            0                  0            0            0                   if(n == 0)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       //cout << "curve is null" << endl;
         .               .              .                  .            .            .                  .            .            .                       return std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  >(nSplitValues+1);
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Now, we know the curve is non-null, and that there is at least one split
        39 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)        13 ( 0.00%)   0            0                 13 ( 0.00%)   0            0                   precomputeArclengths_();
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   //cout << "Curve to split:";
         .               .              .                  .            .            .                  .            .            .                   //for(auto s: vertices_)
         .               .              .                  .            .            .                  .            .            .                   //    std::cout << " (" << s.x() << "," << s.y() << "," << s.width() << ") ";
         .               .              .                  .            .            .                  .            .            .                   //cout << endl;
         .               .              .                  .            .            .                  .            .            .                   //cout << "arclengths:";
         .               .              .                  .            .            .                  .            .            .                   //for(auto s: arclengths_)
         .               .              .                  .            .            .                  .            .            .                   //    std::cout << " " << s;
         .               .              .                  .            .            .                  .            .            .                   //cout << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
        13 ( 0.00%)      0              0                  0            0            0                 13 ( 0.00%)   0            0                   int i = 0;
        91 ( 0.00%)      0              0                 13 ( 0.00%)  10 ( 0.00%)   0                 13 ( 0.00%)   0            0                   T lastVertexOfLastCurve;
         .               .              .                  .            .            .                  .            .            .                   // find first vertex
         .               .              .                  .            .            .                  .            .            .                   // skip all vertices 0, 1, .., i, i+1, i+2, ...., i+k with an arclength strictly less than splitValues.front()
         .               .              .                  .            .            .                  .            .            .                   //cout << "arclengths_[i] to be tested = arclength[" << 0 << "] = " << arclengths_[0] << endl;
     2,574 ( 0.00%)     26 ( 0.00%)    20 ( 0.00%)       936 ( 0.00%)   3 ( 0.00%)   0                351 ( 0.00%)   0            0                   while(i<n && arclengths_[i] < splitValues.front() /*+ epsilon*/)
         .               .              .                  .            .            .                  .            .            .                   {
       104 ( 0.00%)      0              0                104 ( 0.00%)   0            0                  0            0            0                       i++;
         .               .              .                  .            .            .                  .            .            .                       //cout << "arclengths_[i] to be tested = arclength[" << i << "] = " << arclengths_[i] << endl;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   //cout << "now, i = " << i << endl;
         .               .              .                  .            .            .                  .            .            .                   // compute first vertex
        26 ( 0.00%)      0              0                 13 ( 0.00%)   0            0                  0            0            0                   if(i == 0)
         .               .              .                  .            .            .                  .            .            .                   {
       120 ( 0.00%)     12 ( 0.00%)     9 ( 0.00%)        12 ( 0.00%)   0            0                 24 ( 0.00%)   0            0                       lastVertexOfLastCurve = start();
        24 ( 0.00%)      0              0                 12 ( 0.00%)   0            0                  0            0            0                       i++;
         .               .              .                  .            .            .                  .            .            .                       //cout << "we had i=0, hence lastvertex is first vertex" << endl;
         .               .              .                  .            .            .                  .            .            .                   }
         3 ( 0.00%)      1 ( 0.00%)     1 ( 0.00%)         2 ( 0.00%)   0            0                  0            0            0                   else if(i<n)
         .               .              .                  .            .            .                  .            .            .                   {
        40 ( 0.00%)      3 ( 0.00%)     3 ( 0.00%)        14 ( 0.00%)   0            0                  8 ( 0.00%)   0            0                       double  u = (splitValues.front() - arclengths_[i-1]) / (arclengths_[i] - arclengths_[i-1]);
        28 ( 0.00%)      2 ( 0.00%)     2 ( 0.00%)         5 ( 0.00%)   0            0                  4 ( 0.00%)   0            0                       lastVertexOfLastCurve = vertices_[i-1].lerp(u, vertices_[i]);
         .               .              .                  .            .            .                  .            .            .                       //cout << "we had i!=0, so we computed an interpolated vertex : ("
         .               .              .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.x() << ","
         .               .              .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.y() << ","
         .               .              .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.width() << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // special case when created vertex too close from next one: skip next one
         .               .              .                  .            .            .                  .            .            .                       // this case happens when the requested splitValue is exactly the arclength of one of
         .               .              .                  .            .            .                  .            .            .                       // the vertex
         3 ( 0.00%)      0              0                  2 ( 0.00%)   1 ( 0.00%)   0                  0            0            0                       if(u>0.99)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           i++;
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       lastVertexOfLastCurve = end();
         .               .              .                  .            .            .                  .            .            .                       //cout << "i was >= n, hence lastvertex is last vertex" << endl;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // to handle loop
        13 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)         0            0            0                 13 ( 0.00%)   0            0                   bool hasLooped = false;
         .               .              .                  .            .            .                  .            .            .           
        13 ( 0.00%)      0              0                  0            0            0                 13 ( 0.00%)   0            0                   int splitIndex = 1;
        39 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)         0            0            0                 13 ( 0.00%)   0            0                   std::vector< Curve<T>,Eigen::aligned_allocator<Curve<T> >  > res;
         .               .              .                  .            .            .                  .            .            .                   // loop invariant: splitIndex-1 == res.size()
         .               .              .                  .            .            .                  .            .            .                   //cout << "entering loop over split values" << endl;
       142 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)        56 ( 0.00%)   0            0                 15 ( 0.00%)   0            0                   while(splitIndex < nSplitValues)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       //cout << "\n ## starting a new sub-curve ##" << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       //cout << "starting a new sub-curve" << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       //cout << "splitIndex = " << splitIndex << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // extract a sub-curve from vertex i included to arclength "splitValue"
       120 ( 0.00%)      0              0                 45 ( 0.00%)   0            0                 30 ( 0.00%)   0            0                       double splitValue = splitValues[splitIndex];
         .               .              .                  .            .            .                  .            .            .                       //cout << "splitValue = " << splitValue << endl;
         .               .              .                  .            .            .                  .            .            .           
        90 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)        30 ( 0.00%)  10 ( 0.00%)   0                 15 ( 0.00%)   0            0                       Curve curve(ds_);
        30 ( 0.00%)      0              0                 15 ( 0.00%)   0            0                  0            0            0                       if(hasLooped)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           splitValue -= length();
         .               .              .                  .            .            .                  .            .            .                           //cout << "but we've looped so splitValue = " << splitIndex << endl;
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // add last vertex of previous sub-curve, if any
        90 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)         0            0            0                 15 ( 0.00%)   0            0                       curve.vertices_.push_back(lastVertexOfLastCurve);
       120 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)         0            0            0                 30 ( 0.00%)   0            0                       curve.arclengths_.push_back(0);
         .               .              .                  .            .            .                  .            .            .                       //cout << "adding the first vertex: ("
         .               .              .                  .            .            .                  .            .            .                       //     << curve.vertices_.back().x() << ","
         .               .              .                  .            .            .                  .            .            .                       //     << curve.vertices_.back().y() << ","
         .               .              .                  .            .            .                  .            .            .                       //     << curve.vertices_.back().width() << ")  with arclength = "
         .               .              .                  .            .            .                  .            .            .                       //     << curve.arclengths_.back() << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       //cout << "entering loop to add all vertices" << endl;
         .               .              .                  .            .            .                  .            .            .                       // add all vertices i, i+1, i+2, ...., i+k with an arclength strictly less than splitValue
    23,209 ( 0.00%)     30 ( 0.00%)    20 ( 0.00%)     7,736 ( 0.00%)  85 ( 0.00%)   0              1,289 ( 0.00%)   0            0                       while( (i>=n) || (arclengths_[i] < splitValue/* - epsilon*/) ) // basically: while(arclengths_[i] < splitValue)
         .               .              .                  .            .            .                  .            .            .                                                                        // but we do not want to leave the loop when arclengths_[i]
         .               .              .                  .            .            .                  .            .            .                                                                        // is ill-defined, and instead handle it, correct it, and resume the loop
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           //cout << "new loop body execution: i = " << i << " and n = " << n << endl;
     3,825 ( 0.00%)      0              0              2,550 ( 0.00%)   0            0                  0            0            0                           if(i<n) // normal case
         .               .              .                  .            .            .                  .            .            .                           {
    16,562 ( 0.00%)     13 ( 0.00%)    10 ( 0.00%)     2,548 ( 0.00%)   0            0              2,548 ( 0.00%)   0            0                               curve.vertices_.push_back(vertices_[i]);
    33,124 ( 0.00%)     26 ( 0.00%)    20 ( 0.00%)     8,918 ( 0.00%)   0            0              6,370 ( 0.00%)   0            0                               curve.arclengths_.push_back(arclengths_[i]-splitValues[splitIndex-1]);
         .               .              .                  .            .            .                  .            .            .                               //cout << "added vertex: ("
         .               .              .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().x() << ","
         .               .              .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().y() << ","
         .               .              .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().width() << ")  with arclength = "
         .               .              .                  .            .            .                  .            .            .                               //     << curve.arclengths_.back() << endl;
     2,548 ( 0.00%)      0              0              1,274 ( 0.00%)   0            0                  0            0            0                               i++;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                           else // case where arclengths_[i] is ill-defined because we reached end of loop
         .               .              .                  .            .            .                  .            .            .                           {
         .               .              .                  .            .            .                  .            .            .                               //cout << "woops, we've reached i = n" << endl;
         8 ( 0.00%)      0              0                  3 ( 0.00%)   0            0                  0            0            0                               if(isClosed_ && !hasLooped)
         .               .              .                  .            .            .                  .            .            .                               {
         .               .              .                  .            .            .                  .            .            .                                   //cout << "that's because this curve is a loop!" << endl;
         1 ( 0.00%)      0              0                  0            0            0                  1 ( 0.00%)   0            0                                   hasLooped = true;
         1 ( 0.00%)      0              0                  0            0            0                  1 ( 0.00%)   0            0                                   i = 1; // not 0 because the last vertex is equal to the first, we don't want to add it twice
         7 ( 0.00%)      0              0                  2 ( 0.00%)   0            0                  2 ( 0.00%)   0            0                                   splitValue -= length();
         .               .              .                  .            .            .                  .            .            .                                   //cout << "the new split value is: " << splitValue << endl;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                               else
         .               .              .                  .            .            .                  .            .            .                               {
         .               .              .                  .            .            .                  .            .            .                                   //cout << "well, then we just leave the loop :-)" << endl;
         .               .              .                  .            .            .                  .            .            .                                   break;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                       //cout << "leaving loop iterating over vertices" << endl;
         .               .              .                  .            .            .                  .            .            .                       //cout << "i = " << i << endl;
         .               .              .                  .            .            .                  .            .            .                       // here, (arclengths_[i-1] < splitValue and arclengths_[i] >= splitValue) or (i==n)
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // add new vertex inbetween i-1 and i
        75 ( 0.00%)      0              0                 45 ( 0.00%)   0            0                  0            0            0                       if( (0<i-1) && (i<n) ) // question: why not i-1 >= 0 instead ?
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // here, maybe should check if that's necessary or not
         .               .              .                  .            .            .                  .            .            .                           // I think I must check that u is > eps
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                           //cout << "let's add one more vertex" << endl;
         .               .              .                  .            .            .                  .            .            .           
       525 ( 0.00%)     45 ( 0.00%)    30 ( 0.00%)       180 ( 0.00%)   0            0                 90 ( 0.00%)   0            0                           double  u = (splitValue - arclengths_[i-1]) / (arclengths_[i] - arclengths_[i-1]);
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                           // same precaution the other way around:
         .               .              .                  .            .            .                  .            .            .                           // special case when created vertex too close from previous one:then don't add it
        45 ( 0.00%)      0              0                 30 ( 0.00%)   9 ( 0.00%)   0                  0            0            0                           if(u>0.01)
         .               .              .                  .            .            .                  .            .            .                           {
       435 ( 0.00%)     28 ( 0.00%)    20 ( 0.00%)        75 ( 0.00%)   0            0                 60 ( 0.00%)   0            0                               curve.vertices_.push_back(vertices_[i-1].lerp(u, vertices_[i]));
       255 ( 0.00%)     15 ( 0.00%)    10 ( 0.00%)        60 ( 0.00%)   0            0                 45 ( 0.00%)   0            0                               curve.arclengths_.push_back(splitValue-splitValues[splitIndex-1]);
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               //cout << "splitValue = " << splitValue
         .               .              .                  .            .            .                  .            .            .                               //     << "    arclengths_[i-1] = " << arclengths_[i-1]
         .               .              .                  .            .            .                  .            .            .                               //     << "    arclengths_[i] = " << arclengths_[i]
         .               .              .                  .            .            .                  .            .            .                               //     << "    u = " << u
         .               .              .                  .            .            .                  .            .            .                               //     << "    vertex = ("
         .               .              .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().x() << ","
         .               .              .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().y() << ","
         .               .              .                  .            .            .                  .            .            .                               //     << curve.vertices_.back().width() << ")  with arclength = "
         .               .              .                  .            .            .                  .            .            .                               //     << curve.arclengths_.back() << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                               // special case when created vertex too close from next one: skip next one
         .               .              .                  .            .            .                  .            .            .                               // this case happens when the requested splitValue is exactly the arclength of one of
         .               .              .                  .            .            .                  .            .            .                               // the vertex
        45 ( 0.00%)     15 ( 0.00%)    10 ( 0.00%)        30 ( 0.00%)   0            0                  0            0            0                               if(u>0.99)
         .               .              .                  .            .            .                  .            .            .                               {
        12 ( 0.00%)      0              0                 12 ( 0.00%)   0            0                  0            0            0                                   i++;
         .               .              .                  .            .            .                  .            .            .                               }
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                           else
         .               .              .                  .            .            .                  .            .            .                           {
         .               .              .                  .            .            .                  .            .            .                               // nothing to do, the next vertex will naturally be added
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // handle special case
        60 ( 0.00%)      0              0                 30 ( 0.00%)   1 ( 0.00%)   0                  0            0            0                       if(isClosed_)
         3 ( 0.00%)      0              0                  0            0            0                  1 ( 0.00%)   0            0                           curve.setDirtyArclengths_();
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // add the curve to the result
        75 ( 0.00%)     15 ( 0.00%)    10 ( 0.00%)         0            0            0                 15 ( 0.00%)   0            0                       res.push_back(curve);
       195 ( 0.00%)      2 ( 0.00%)     0                  0            0            0                 45 ( 0.00%)   0            0                       lastVertexOfLastCurve = res.back().end();
         .               .              .                  .            .            .                  .            .            .                       //cout << "added the new curve to split curve list, its last vertex is: "
         .               .              .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.x() << ","
         .               .              .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.y() << ","
         .               .              .                  .            .            .                  .            .            .                       //     << lastVertexOfLastCurve.width() << endl;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // increment split index
        15 ( 0.00%)     15 ( 0.00%)     0                 15 ( 0.00%)   0            0                  0            0            0                       splitIndex++;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   // here:  splitIndex == nSplitValues && splitIndex-1 == res.size()
         .               .              .                  .            .            .                  .            .            .                   // hence  res.size() == nSplitValues - 1
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   //returns
        65 ( 0.00%)      0              0                 13 ( 0.00%)   0            0                 13 ( 0.00%)   0            0                   return res;
       143 ( 0.00%)     26 ( 0.00%)    20 ( 0.00%)        78 ( 0.00%)   0            0                 13 ( 0.00%)   0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // ----- Curve geometry editing -----
         .               .              .                  .            .            .                  .            .            .           
       140 ( 0.00%)     14 ( 0.00%)     0                 14 ( 0.00%)   0            0                 70 ( 0.00%)   0            0               void setEndPoints(const T & newStart, const T & newEnd)
         .               .              .                  .            .            .                  .            .            .               {
        56 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                   int n = size();
        28 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                  0            0            0                   if(n < 3)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       vertices_.clear();
         .               .              .                  .            .            .                  .            .            .                       vertices_.push_back(newStart);
         .               .              .                  .            .            .                  .            .            .                       vertices_.push_back(newEnd);
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                   {
        42 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                       precomputeArclengths_();
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // this method could be replaced using lerp only, but it would make it
         .               .              .                  .            .            .                  .            .            .                       // much much less efficient and readable
       140 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        28 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                       T dStart = newStart - vertices_.front();
       140 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        28 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                       T dEnd = newEnd - vertices_.back();
         .               .              .                  .            .            .                  .            .            .           
        70 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                       double l = length();
        56 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                  0            0            0                       assert(l>0);
     5,710 ( 0.00%)  1,438 ( 0.00%)    28 ( 0.00%)     4,258 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                       for(int i=0; i<n; ++i)
         .               .              .                  .            .            .                  .            .            .                       {
    14,100 ( 0.00%)  2,806 ( 0.00%)    14 ( 0.00%)     5,640 ( 0.00%)   1 ( 0.00%)   0              2,820 ( 0.00%)   0            0                           double a = arclengths_[i] / l;
    46,530 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)     7,050 ( 0.00%)   0            0              7,050 ( 0.00%)   0            0                           vertices_[i] = vertices_[i] + dStart.lerp(a, dEnd);
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
        56 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   resample(true);
        84 ( 0.00%)      0              0                 56 ( 0.00%)   1 ( 0.00%)   0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           private:
         .               .              .                  .            .            .                  .            .            .               // Sampled curve: the one that is exposed to the user
         .               .              .                  .            .            .                  .            .            .               std::vector<T,Eigen::aligned_allocator<T> > vertices_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Arc-length precomputation
         .               .              .                  .            .            .                  .            .            .               mutable std::vector<double> arclengths_;
         .               .              .                  .            .            .                  .            .            .               mutable bool dirtyArclengths_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // If treated as a loop
         .               .              .                  .            .            .                  .            .            .               bool isClosed_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // ---- Sketching: curve neatening algorithm  ----
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               bool sketchInProgress_;
       126 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        14 ( 0.00%)   0            0                 56 ( 0.00%)   0            0               void pushFirstVertex_(const T & vertex)
         .               .              .                  .            .            .                  .            .            .               {
       112 ( 0.00%)      0              0                 14 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                   arclengths_.push_back(0);
        84 ( 0.00%)      0              0                 28 ( 0.00%)   0            0                 14 ( 0.00%)   0            0                   vertices_.push_back(vertex);
        84 ( 0.00%)      0              0                 56 ( 0.00%)   0            0                  0            0            0               }
    14,040 ( 0.00%)     14 ( 0.00%)     7 ( 0.00%)     1,404 ( 0.00%)   0            0              7,020 ( 0.00%)   0            0               void pushVertex_(const T & vertex)
         .               .              .                  .            .            .                  .            .            .               {
    15,444 ( 0.00%)    168 ( 0.00%)   115 ( 0.00%)     2,808 ( 0.00%)   0            0              4,212 ( 0.00%)   0            0                   double d = vertices_.back().distanceTo(vertex);
     5,616 ( 0.00%)      0              0              1,404 ( 0.00%)   0            0                  0            0            0                   if(d>0)
         .               .              .                  .            .            .                  .            .            .                   {
    18,252 ( 0.00%)    677 ( 0.00%)   115 ( 0.00%)     5,616 ( 0.00%) 118 ( 0.00%) 113 ( 0.00%)     4,212 ( 0.00%)   0            0                       arclengths_.push_back(arclengths_.back() + d);
     8,424 ( 0.00%)      0              0              2,808 ( 0.00%)   0            0              1,404 ( 0.00%)   0            0                       vertices_.push_back(vertex);
         .               .              .                  .            .            .                  .            .            .                   }
     9,828 ( 0.00%)    666 ( 0.00%)   106 ( 0.00%)     7,020 ( 0.00%)   0            0                  0            0            0               }
    12,518 ( 0.00%)    478 ( 0.00%)    12 ( 0.00%)     1,138 ( 0.00%)   0            0              6,828 ( 0.00%)   0            0               T interpolatedVertex_(double s) const // size must be > 1
         .               .              .                  .            .            .                  .            .            .               {
     3,414 ( 0.00%)    538 ( 0.00%)    25 ( 0.00%)     1,138 ( 0.00%)   0            0              1,138 ( 0.00%)   0            0                   precomputeArclengths_();
         .               .              .                  .            .            .                  .            .            .           
     1,138 ( 0.00%)      0              0                  0            0            0              1,138 ( 0.00%)   0            0                   int i = 0;
     6,828 ( 0.00%)      0              0              1,138 ( 0.00%)   0            0              2,276 ( 0.00%)   0            0                   int j = static_cast<int>(vertices_.size()) - 1;
    10,242 ( 0.00%)    524 ( 0.00%)    25 ( 0.00%)     3,414 ( 0.00%)  49 ( 0.00%)  25 ( 0.00%)     2,276 ( 0.00%)   0            0                   double si = arclengths_[i];
    10,242 ( 0.00%)      0              0              3,414 ( 0.00%)  85 ( 0.00%)  78 ( 0.00%)     2,276 ( 0.00%)   0            0                   double sj = arclengths_[j];
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   int k;
         .               .              .                  .            .            .                  .            .            .                   double sk, u;
         .               .              .                  .            .            .                  .            .            .           
    11,298 ( 0.00%)    489 ( 0.00%)    25 ( 0.00%)     5,080 ( 0.00%)   0            0                  0            0            0                   while( j-i > 1)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       // compute an index hopefully close to s
     8,412 ( 0.00%)    408 ( 0.00%)    25 ( 0.00%)     5,608 ( 0.00%)   0            0              1,402 ( 0.00%)   0            0                       u = (s - si) / (sj - si);
    21,030 ( 0.00%)    390 ( 0.00%)    25 ( 0.00%)     7,010 ( 0.00%)  14 ( 0.00%)   7 ( 0.00%)     2,804 ( 0.00%)   0            0                       k = std::floor( (1-u)*i + u*j );
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // make sure i < k < j
    25,236 ( 0.00%)    501 ( 0.00%)    25 ( 0.00%)     4,206 ( 0.00%)   0            0              7,010 ( 0.00%)   0            0                       k = std::min(j-1, std::max(i+1, k));
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // recurse
    12,618 ( 0.00%)      0              0              4,206 ( 0.00%)  39 ( 0.00%)  25 ( 0.00%)     2,804 ( 0.00%)   0            0                       sk = arclengths_[k];
     4,206 ( 0.00%)      0              0              2,804 ( 0.00%)   0            0                  0            0            0                       if(sk > s)
         .               .              .                  .            .            .                  .            .            .                       {
     1,576 ( 0.00%)      0              0                788 ( 0.00%)   0            0                788 ( 0.00%)   0            0                           j = k;
     2,364 ( 0.00%)      0              0                788 ( 0.00%)   0            0                788 ( 0.00%)   0            0                           sj = sk;
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                       else
         .               .              .                  .            .            .                  .            .            .                       {
     1,228 ( 0.00%)      0              0                614 ( 0.00%)   0            0                614 ( 0.00%)   0            0                           i = k;
     1,228 ( 0.00%)      0              0                614 ( 0.00%)   0            0                614 ( 0.00%)   0            0                           si = sk;
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // Now: j = i+1
     6,828 ( 0.00%)    408 ( 0.00%)    25 ( 0.00%)     4,552 ( 0.00%)   0            0              1,138 ( 0.00%)   0            0                   u = (s - si) / (sj - si);
    25,036 ( 0.00%)     81 ( 0.00%)    25 ( 0.00%)     6,828 ( 0.00%)   0            0              3,414 ( 0.00%)   0            0                   return vertices_[i].lerp(u,vertices_[j]);
     7,966 ( 0.00%)      0              0              6,828 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // parameters
         .               .              .                  .            .            .                  .            .            .               int N_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // temp variables
         .               .              .                  .            .            .                  .            .            .               std::vector<T,Eigen::aligned_allocator<T> > qTemp_; // vertices only valid until next mouse sample
         .               .              .                  .            .            .                  .            .            .                                              // the ones before are final and stored in q_
         .               .              .                  .            .            .                  .            .            .               //QList<double> qtTemp_; // same but for time information // NOT needed now: part of T
         .               .              .                  .            .            .                  .            .            .               double lastFinalS_; // value s such that phi(s) = q_.last()
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // raw input from mouse
     9,450 ( 0.00%)    231 ( 0.00%)   226 ( 0.00%)     3,675 ( 0.00%)   0            0              2,625 ( 0.00%)   0            0               struct Input
         .               .              .                  .            .            .                  .            .            .               {
     4,158 ( 0.00%)    462 ( 0.00%)   452 ( 0.00%)     1,386 ( 0.00%)   0            0              1,386 ( 0.00%)   0            0                   Input(const T & p, double s) : p(p), s(s) {}
         .               .              .                  .            .            .                  .            .            .                   T p;
         .               .              .                  .            .            .                  .            .            .                   double s;
         .               .              .                  .            .            .                  .            .            .                   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
         .               .              .                  .            .            .                  .            .            .               };
         .               .              .                  .            .            .                  .            .            .               std::vector<Input,Eigen::aligned_allocator<Input> > p_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // fit a smooth curve to a subpart of the raw mouse input
         .               .              .                  .            .            .                  .            .            .               class Fitter
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .               public:
         .               .              .                  .            .            .                  .            .            .                   // the fitting computation must be implemented in derived constructors.
         .               .              .                  .            .            .                  .            .            .                   //
         .               .              .                  .            .            .                  .            .            .                   // the N input points from p[j] to p[j+N-1] (guaranteed to exist)
         .               .              .                  .            .            .                  .            .            .                   // is the local part of the curve that should be fit.
         .               .              .                  .            .            .                  .            .            .                   //
     1,736 ( 0.00%)    160 ( 0.00%)   160 ( 0.00%)         0            0            0              1,302 ( 0.00%)   0            0                   Fitter(const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds) :
     4,123 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)     2,387 ( 0.00%)   0            0              1,085 ( 0.00%)  48 ( 0.00%)  40 ( 0.00%)              p_(p), j_(j), N_(N), ds_(ds) {}
     2,387 ( 0.00%)    130 ( 0.00%)   125 ( 0.00%)       651 ( 0.00%)   0            0                651 ( 0.00%)   0            0                   virtual ~Fitter() {}
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // eval() must be implemented in derived classes
         .               .              .                  .            .            .                  .            .            .                   //
         .               .              .                  .            .            .                  .            .            .                   // the fitting curve C must:
         .               .              .                  .            .            .                  .            .            .                   //    - be a continuous curve parameterized from startS to endS
         .               .              .                  .            .            .                  .            .            .                   //    - verify C(startS) = startP and C(endS) = endP
         .               .              .                  .            .            .                  .            .            .                   //    - have a precision of at least ds
         .               .              .                  .            .            .                  .            .            .                   //
-- line 1734 ----------------------------------------
-- line 1743 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                   //
         .               .              .                  .            .            .                  .            .            .                   virtual Eigen::Vector2d eval(double s) const=0;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // weight that should be use for this curve at this parameter to
         .               .              .                  .            .            .                  .            .            .                   // blend the different overlapping local fits together
         .               .              .                  .            .            .                  .            .            .                   //
         .               .              .                  .            .            .                  .            .            .                   // this method can be overriden in derived class if custom blending
         .               .              .                  .            .            .                  .            .            .                   // weights are desired (but the default ones should be fine)
   102,222 ( 0.00%)  4,074 ( 0.01%)   106 ( 0.00%)         0            0            0             51,111 ( 0.00%)   0            0                   virtual double w(double s) const
         .               .              .                  .            .            .                  .            .            .                   {
   119,259 ( 0.00%)      0              0             34,074 ( 0.00%)   0            0             34,074 ( 0.00%)   0            0                       double u = u_(s);
   170,370 ( 0.00%)    157 ( 0.00%)   106 ( 0.00%)    85,185 ( 0.00%)   0            0                  0            0            0                       return u*u*(1-u)*(1-u);
    51,111 ( 0.00%)      0              0             34,074 ( 0.00%)   0            0                  0            0            0                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // convenient inline methods to make code easier to write and read
   163,504 ( 0.00%)    651 ( 0.00%)   651 ( 0.01%)    48,308 ( 0.00%)   0            0             44,592 ( 0.00%)   0            0                   inline Eigen::Vector2d p(int i) const {return Eigen::Vector2d(p_[i].p.x(), p_[i].p.y()) ;}
 2,191,230 ( 0.02%)    209 ( 0.00%)   209 ( 0.00%)   730,410 ( 0.02%) 419 ( 0.00%) 410 ( 0.00%)   486,940 ( 0.02%)   0            0                   inline double s(int i) const {return p_[i].s;}
 1,204,860 ( 0.01%)  9,326 ( 0.02%)   229 ( 0.00%)   401,620 ( 0.01%) 180 ( 0.00%) 180 ( 0.00%)   240,972 ( 0.01%)   0            0                   inline double startS() const {return s(j_);}
   763,078 ( 0.01%)    374 ( 0.00%)   209 ( 0.00%)   281,134 ( 0.01%)   0            0            120,486 ( 0.00%)   0            0                   inline double endS() const {return s(j_+N_-1);}
    13,090 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)     5,950 ( 0.00%)   0            0              2,975 ( 0.00%)   0            0                   inline Eigen::Vector2d startP() const {return p(j_);}
    15,470 ( 0.00%)    434 ( 0.00%)   434 ( 0.00%)     7,140 ( 0.00%)   0            0              2,975 ( 0.00%)   0            0                   inline Eigen::Vector2d endP() const {return p(j_+N_-1);}
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               protected:
         .               .              .                  .            .            .                  .            .            .                   // maps [startS, endS] to [0,1]
 1,204,860 ( 0.01%)  9,384 ( 0.02%)   438 ( 0.00%)   321,296 ( 0.01%)   0            0            321,296 ( 0.01%)   0            0                   double u_(double s) const {return (s-startS())/(endS()-startS());}
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // reference to the whole raw mouse input
         .               .              .                  .            .            .                  .            .            .                   const std::vector<Input,Eigen::aligned_allocator<Input> > & p_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // local range of vertices to fit: the N points p_[j] to p_[j+N-1]
         .               .              .                  .            .            .                  .            .            .                   int j_;
         .               .              .                  .            .            .                  .            .            .                   int N_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // required precision, to be used if derived classes need sampling
         .               .              .                  .            .            .                  .            .            .                   double ds_;
         .               .              .                  .            .            .                  .            .            .               };
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // List storing all the local fitting
         .               .              .                  .            .            .                  .            .            .               std::vector<Fitter*> fits_;
       224 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        28 ( 0.00%)   0            0                 84 ( 0.00%)   0            0               void clearFits_()
         .               .              .                  .            .            .                  .            .            .               {
     2,287 ( 0.00%)     56 ( 0.00%)    56 ( 0.00%)       201 ( 0.00%)  23 ( 0.00%)  16 ( 0.00%)       636 ( 0.00%)   0            0                   for(Fitter * f : fits_)
       936 ( 0.00%)      0              0                351 ( 0.00%) 107 ( 0.00%)  82 ( 0.00%)       117 ( 0.00%)   0            0                       delete f;
       112 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)        28 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                   fits_.clear();
       168 ( 0.00%)      0              0                112 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Blend overlapping fitting together
         .               .              .                  .            .            .                  .            .            .               int lastFittingInvolved_i; // not initialized, but it's ok
    35,910 ( 0.00%)  5,130 ( 0.01%)   117 ( 0.00%)         0            0            0             20,520 ( 0.00%)   0            0               int lastFittingInvolved_(double s)
         .               .              .                  .            .            .                  .            .            .               {
    15,390 ( 0.00%)    780 ( 0.00%)   117 ( 0.00%)    10,260 ( 0.00%)   0            0              5,130 ( 0.00%)   0            0                   int i = lastFittingInvolved_i; // make it more readable
    71,208 ( 0.00%)      0              0             15,390 ( 0.00%)   0            0              5,130 ( 0.00%)   0            0                   if(i<0 || (unsigned int) i >= p_.size())
     4,518 ( 0.00%)      0              0                  0            0            0              4,518 ( 0.00%)   0            0                       i = 0;
    30,168 ( 0.00%)    171 ( 0.00%)   117 ( 0.00%)     5,130 ( 0.00%)   0            0                  0            0            0                   while(i-1>=0 && s<p_[i-1].s)
         .               .              .                  .            .            .                  .            .            .                       i--;
 1,587,925 ( 0.01%)  8,336 ( 0.01%)   234 ( 0.00%)   381,102 ( 0.01%) 574 ( 0.00%) 574 ( 0.00%)   127,034 ( 0.00%)   0            0                   while((unsigned int)i+1<p_.size() && s>=p_[i+1].s)
    58,387 ( 0.00%)      0              0             58,387 ( 0.00%)   0            0                  0            0            0                       i++;
     5,130 ( 0.00%)      0              0              5,130 ( 0.00%)   0            0                  0            0            0                   return i;
    15,390 ( 0.00%)      0              0             15,390 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
   106,956 ( 0.00%) 17,826 ( 0.03%)   418 ( 0.00%)     8,913 ( 0.00%)   0            0             62,391 ( 0.00%)   0            0               T phi_(double s, Fitter * useSingleFit = 0)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   // compute pos
    71,304 ( 0.00%)  8,913 ( 0.01%)   209 ( 0.00%)         0            0            0             26,739 ( 0.00%)   0            0                   Eigen::Vector2d pos(0,0);
    17,826 ( 0.00%)      0              0              8,913 ( 0.00%)   0            0                  0            0            0                   if(useSingleFit)
         .               .              .                  .            .            .                  .            .            .                   {
    64,311 ( 0.00%)    162 ( 0.00%)    92 ( 0.00%)    18,915 ( 0.00%)  92 ( 0.00%)  92 ( 0.00%)     7,566 ( 0.00%)   0            0                       pos = useSingleFit->eval(s);
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                   {
    30,780 ( 0.00%) 10,260 ( 0.02%)   234 ( 0.00%)    10,260 ( 0.00%)   0            0             10,260 ( 0.00%)   0            0                       int i=lastFittingInvolved_(s);
    76,950 ( 0.00%)  5,130 ( 0.01%)   117 ( 0.00%)    20,520 ( 0.00%)   0            0             20,520 ( 0.00%)   0            0                       int startJ = std::max(0,i-N_+2);
    87,210 ( 0.00%)  5,130 ( 0.01%)   117 ( 0.00%)    20,520 ( 0.00%)   0            0             20,520 ( 0.00%)   0            0                       int endJ = std::min(i,(int)p_.size()-N_);
    15,390 ( 0.00%)      0              0             10,260 ( 0.00%)   0            0                  0            0            0                       if(startJ==endJ)
         .               .              .                  .            .            .                  .            .            .                       {
    24,288 ( 0.00%)  1,056 ( 0.00%)    11 ( 0.00%)     6,336 ( 0.00%)  11 ( 0.00%)  11 ( 0.00%)     3,168 ( 0.00%)   0            0                           pos = fits_[startJ]->eval(s);
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                       else
         .               .              .                  .            .            .                  .            .            .                       {
     8,148 ( 0.00%)  8,148 ( 0.01%)   212 ( 0.00%)         0            0            0              4,074 ( 0.00%)   0            0                           double sumW = 0;
    92,592 ( 0.00%)    157 ( 0.00%)   106 ( 0.00%)    63,333 ( 0.00%)   0            0              4,074 ( 0.00%)   0            0                           for(int j=startJ; j<=endJ; j++)
         .               .              .                  .            .            .                  .            .            .                           {
   289,629 ( 0.00%)  4,074 ( 0.01%)   106 ( 0.00%)   102,222 ( 0.00%) 725 ( 0.00%) 705 ( 0.00%)    51,111 ( 0.00%)   0            0                               double w = fits_[j]->w(s);
   289,629 ( 0.00%)    754 ( 0.00%)   106 ( 0.00%)   102,222 ( 0.00%) 106 ( 0.00%) 106 ( 0.00%)    34,074 ( 0.00%)   0            0                               Eigen::Vector2d q = fits_[j]->eval(s);
   289,629 ( 0.00%)    106 ( 0.00%)   106 ( 0.00%)         0            0            0             51,111 ( 0.00%)   0            0                               pos = pos + w * q;
    68,148 ( 0.00%)      0              0             34,074 ( 0.00%)   0            0             17,037 ( 0.00%)   0            0                               sumW += w;
         .               .              .                  .            .            .                  .            .            .                           }
    57,036 ( 0.00%)  4,074 ( 0.01%)   106 ( 0.00%)     8,148 ( 0.00%)   0            0             12,222 ( 0.00%)   0            0                           pos = (1/sumW) * pos;
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // get other data as linear interpolation of raw mouse input (no smoothing)
    62,391 ( 0.00%)  9,096 ( 0.01%)   312 ( 0.00%)    17,826 ( 0.00%) 209 ( 0.00%) 207 ( 0.00%)     8,913 ( 0.00%)   0            0                   T res;
    71,304 ( 0.00%)      0              0              8,913 ( 0.00%)   0            0              8,913 ( 0.00%)   0            0                   if(p_.size() == 0)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       // nothing, keep default-constructed data
         .               .              .                  .            .            .                  .            .            .                   }
    71,304 ( 0.00%)  8,913 ( 0.01%)   209 ( 0.00%)     8,913 ( 0.00%)   0            0              8,913 ( 0.00%)   0            0                   else if(p_.size() == 1)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                       res = p_[0].p;
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   else
         .               .              .                  .            .            .                  .            .            .                   {
    53,478 ( 0.00%)    224 ( 0.00%)   209 ( 0.00%)     8,913 ( 0.00%)   0            0             17,826 ( 0.00%)   0            0                       int i = static_cast<int>(p_.size()) - 1;
   646,415 ( 0.01%)    234 ( 0.00%)   209 ( 0.00%)   186,452 ( 0.01%)   0            0             39,073 ( 0.00%)   0            0                       while(p_[i-1].s > s && i>1)
    30,160 ( 0.00%)      0              0             30,160 ( 0.00%)   0            0                  0            0            0                           i--;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // now, we have p_[i-1].s <= s < p_[i]
         .               .              .                  .            .            .                  .            .            .                       // note: we know that s2 - s1 > 0 since we rejected before
         .               .              .                  .            .            .                  .            .            .                       // the input that did not satisfy this condition
    89,130 ( 0.00%)    209 ( 0.00%)   209 ( 0.00%)    26,739 ( 0.00%)   0            0             17,826 ( 0.00%)   0            0                       double s1 = p_[i-1].s;
    80,217 ( 0.00%)    220 ( 0.00%)   209 ( 0.00%)    26,739 ( 0.00%)   0            0             17,826 ( 0.00%)   0            0                       double s2 = p_[i].s;
    53,478 ( 0.00%)    220 ( 0.00%)   209 ( 0.00%)    35,652 ( 0.00%)   0            0              8,913 ( 0.00%)   0            0                       double u = (s-s1)/(s2-s1);
   249,564 ( 0.00%)    209 ( 0.00%)   209 ( 0.00%)    53,478 ( 0.00%)   0            0             35,652 ( 0.00%)   0            0                       res = p_[i-1].p.lerp(u, p_[i].p);
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   // change position
    80,217 ( 0.00%)    209 ( 0.00%)   209 ( 0.00%)    17,826 ( 0.00%)   0            0             17,826 ( 0.00%)   0            0                   res.setX(pos[0]);
    80,217 ( 0.00%)    336 ( 0.00%)   209 ( 0.00%)    17,826 ( 0.00%)   0            0             17,826 ( 0.00%)   0            0                   res.setY(pos[1]);
         .               .              .                  .            .            .                  .            .            .           
     8,913 ( 0.00%)      0              0                  0            0            0                  0            0            0                   return res;
    62,391 ( 0.00%)      0              0             53,478 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               //double phit_(double s); // useless now, part of T
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Different fitting algorithms that can be used
         .               .              .                  .            .            .                  .            .            .               // Note: only smooth the x and y coordinates. Could use higher dimensional
         .               .              .                  .            .            .                  .            .            .               //       bezier to also smooth other data, but not done by design
     6,944 ( 0.00%)    222 ( 0.00%)   125 ( 0.00%)     1,953 ( 0.00%)   0            0              1,953 ( 0.00%)   0            0               class CubicBezierFitter: public Fitter
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .               public:
     2,821 ( 0.00%)    434 ( 0.00%)   434 ( 0.00%)       217 ( 0.00%)   0            0              1,736 ( 0.00%)   0            0                   CubicBezierFitter(const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds) :
     6,944 ( 0.00%)    651 ( 0.00%)   651 ( 0.01%)     2,387 ( 0.00%)   0            0              1,519 ( 0.00%)   0            0                       Fitter(p,j,N, ds)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .           
       434 ( 0.00%)      0              0                217 ( 0.00%)   0            0                  0            0            0                       assert(N>=2);
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // --- Fit a bezier curve to the input points ---
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // end points
     2,387 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       434 ( 0.00%)   0            0                434 ( 0.00%)   0            0                       P0_ = this->startP();
     2,387 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       434 ( 0.00%)   0            0                434 ( 0.00%)   0            0                       P3_ = this->endP();
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // handle special cases:
       434 ( 0.00%)      0              0                217 ( 0.00%)   0            0                  0            0            0                       if(N==2)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // linear:
       420 ( 0.00%)     42 ( 0.00%)    42 ( 0.00%)        70 ( 0.00%)  14 ( 0.00%)  14 ( 0.00%)        84 ( 0.00%)   0            0                           P1_ = 2./3. *  P0_ + 1./3. * P3_;
       434 ( 0.00%)     28 ( 0.00%)    28 ( 0.00%)        70 ( 0.00%)   0            0                 84 ( 0.00%)   0            0                           P2_ = 1./3. *  P0_ + 2./3. * P3_;
         .               .              .                  .            .            .                  .            .            .                       }
       406 ( 0.00%)    203 ( 0.00%)   203 ( 0.00%)       203 ( 0.00%)   0            0                  0            0            0                       else if(N==3)
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .                           // At*A is also singular in this case
         .               .              .                  .            .            .                  .            .            .                           // fit a dum quadratic (todo: smth better)
       182 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        42 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                           P1_ = this->p(j+1);
       196 ( 0.00%)     14 ( 0.00%)    14 ( 0.00%)        42 ( 0.00%)   0            0                 28 ( 0.00%)   0            0                           P2_ = this->p(j+1);
         .               .              .                  .            .            .                  .            .            .                       }
         .               .              .                  .            .            .                  .            .            .                       else
         .               .              .                  .            .            .                  .            .            .                       {
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                           // create linear system
     2,268 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)       378 ( 0.00%)   0            0                567 ( 0.00%)   0            0                           Eigen::MatrixXd A(2*(this->N_-2),4);
     1,890 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)       378 ( 0.00%)   0            0                378 ( 0.00%)   0            0                           Eigen::VectorXd B(2*(this->N_-2));
     2,079 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)       378 ( 0.00%)   0            0                567 ( 0.00%)   0            0                           double Ax = this->startP()[0];
     2,079 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)       378 ( 0.00%)   0            0                567 ( 0.00%)   0            0                           double Ay = this->startP()[1];
     2,079 ( 0.00%)      0              0                378 ( 0.00%)   0            0                567 ( 0.00%)   0            0                           double Dx = this->endP()[0];
     2,079 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)       378 ( 0.00%)   0            0                567 ( 0.00%)   0            0                           double Dy = this->endP()[1];
     8,817 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     5,563 ( 0.00%)   0            0                189 ( 0.00%)   0            0                           for(int i=1; i<this->N_-1; i++)
         .               .              .                  .            .            .                  .            .            .                           {
    18,735 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)     6,245 ( 0.00%)   0            0              3,747 ( 0.00%)   0            0                               double Ui = this->u_(this->s(i+this->j_));
     3,747 ( 0.00%)      0              0              2,498 ( 0.00%) 189 ( 0.00%) 189 ( 0.00%)     1,249 ( 0.00%)   0            0                               double OneMinusUi = 1-Ui;
     3,747 ( 0.00%)      0              0              1,249 ( 0.00%)   0            0              1,249 ( 0.00%)   0            0                               double Ui2 = Ui*Ui;
     3,747 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     1,249 ( 0.00%)   0            0              1,249 ( 0.00%)   0            0                               double OneMinusUi2 = OneMinusUi*OneMinusUi;
     3,747 ( 0.00%)      0              0              2,498 ( 0.00%)   0            0              1,249 ( 0.00%)   0            0                               double Ui3 = Ui2*Ui;
     3,747 ( 0.00%)      0              0              2,498 ( 0.00%)   0            0              1,249 ( 0.00%)   0            0                               double OneMinusUi3 = OneMinusUi2*OneMinusUi;
     7,494 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     3,747 ( 0.00%) 189 ( 0.00%) 189 ( 0.00%)     1,249 ( 0.00%)   0            0                               double ThreeOneMinusUi2Ui = 3 * OneMinusUi2 * Ui;
     7,494 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     3,747 ( 0.00%)   0            0              1,249 ( 0.00%)   0            0                               double ThreeOneMinusUiUi2 = 3 * OneMinusUi * Ui2;
         .               .              .                  .            .            .                  .            .            .           
     4,996 ( 0.00%)      0              0              1,249 ( 0.00%)   0            0              1,249 ( 0.00%)   0            0                               int TwoTimesIMinus1 = 2*(i-1);
     6,245 ( 0.00%)      0              0              1,249 ( 0.00%)   0            0              1,249 ( 0.00%)   0            0                               int TwoTimesIMinus1Plus1 = 2*(i-1)+1;
         .               .              .                  .            .            .                  .            .            .           
    13,739 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     3,747 ( 0.00%)   0            0              3,747 ( 0.00%) 126 ( 0.00%) 126 ( 0.00%)                      A(TwoTimesIMinus1, 0) = ThreeOneMinusUi2Ui;
    11,241 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     1,249 ( 0.00%)   0            0              2,498 ( 0.00%) 310 ( 0.00%) 308 ( 0.00%)                      A(TwoTimesIMinus1, 1) = 0;
    13,739 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     3,747 ( 0.00%)   0            0              3,747 ( 0.00%) 311 ( 0.00%) 310 ( 0.00%)                      A(TwoTimesIMinus1, 2) = ThreeOneMinusUiUi2;
    11,241 ( 0.00%)      0              0              1,249 ( 0.00%)   0            0              2,498 ( 0.00%) 419 ( 0.00%) 407 ( 0.00%)                      A(TwoTimesIMinus1, 3) = 0;
         .               .              .                  .            .            .                  .            .            .           
    11,241 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     1,249 ( 0.00%)   0            0              2,498 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 0) = 0;
    13,739 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     3,747 ( 0.00%)   0            0              3,747 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 1) = ThreeOneMinusUi2Ui;
    11,241 ( 0.00%)      0              0              1,249 ( 0.00%)   0            0              2,498 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 2) = 0;
    13,739 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)     3,747 ( 0.00%)   0            0              3,747 ( 0.00%)   0            0                               A(TwoTimesIMinus1Plus1, 3) = ThreeOneMinusUiUi2;
         .               .              .                  .            .            .                  .            .            .           
    36,221 ( 0.00%)    567 ( 0.00%)   567 ( 0.01%)    13,739 ( 0.00%)   0            0              6,245 ( 0.00%) 252 ( 0.00%) 215 ( 0.00%)                      B(TwoTimesIMinus1) = this->p(i+this->j_)[0] - OneMinusUi3 * Ax - Ui3 * Dx;
    36,221 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)    13,739 ( 0.00%)   0            0              6,245 ( 0.00%)   0            0                               B(TwoTimesIMinus1Plus1) = this->p(i+this->j_)[1] - OneMinusUi3 * Ay - Ui3 * Dy;
         .               .              .                  .            .            .                  .            .            .                           }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                           // solve it
         .               .              .                  .            .            .                  .            .            .                           //Eigen::VectorXd X = (A.transpose() * A).inverse() * A.transpose() * B;
         .               .              .                  .            .            .                  .            .            .                           // For some reason above code breaks with Eigen 3.2, need to split it
     3,969 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)         0            0            0              1,701 ( 0.00%)   0            0                           Eigen::MatrixXd M = (A.transpose() * A).inverse();
     1,701 ( 0.00%)    378 ( 0.00%)   189 ( 0.00%)         0            0            0                567 ( 0.00%)   0            0                           M *= A.transpose();
     2,268 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)         0            0            0                756 ( 0.00%)   0            0                           Eigen::VectorXd X = M * B;
         .               .              .                  .            .            .                  .            .            .           
     3,969 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)       189 ( 0.00%)   0            0                756 ( 0.00%)   0            0                           P1_ = Eigen::Vector2d(X(0),X(1));
     3,969 ( 0.00%)    378 ( 0.00%)   378 ( 0.00%)       189 ( 0.00%)   0            0                756 ( 0.00%)   0            0                           P2_ = Eigen::Vector2d(X(2),X(3));
     2,268 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)         0            0            0                756 ( 0.00%)   0            0                       }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // --- Compute an approximate uniform parameterization ---
         .               .              .                  .            .            .                  .            .            .           
   208,670 ( 0.00%)  9,478 ( 0.02%)   462 ( 0.00%)    81,578 ( 0.00%) 245 ( 0.00%) 245 ( 0.00%)    36,281 ( 0.00%)   0            0                       for(double u=0; u<1; u+=0.75*this->ds_/der(u).norm())
         .               .              .                  .            .            .                  .            .            .                       {
   117,208 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)    27,048 ( 0.00%)   0            0             18,032 ( 0.00%)   0            0                           sampling_ << this->pos(u);
         .               .              .                  .            .            .                  .            .            .                       }
     1,519 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)       434 ( 0.00%)   0            0                217 ( 0.00%)   0            0                           sampling_ << P3_;
         .               .              .                  .            .            .                  .            .            .                       // => sampling_.size() >= 2
     1,519 ( 0.00%)    217 ( 0.00%)   217 ( 0.00%)     1,085 ( 0.00%)   0            0                  0            0            0                   }
         .               .              .                  .            .            .                  .            .            .           
   240,636 ( 0.00%) 17,826 ( 0.03%)   418 ( 0.00%)    21,876 ( 0.00%)   0            0            131,256 ( 0.00%)   0            0                   Eigen::Vector2d eval(double s) const
         .               .              .                  .            .            .                  .            .            .                   {
   153,132 ( 0.00%)    872 ( 0.00%)   209 ( 0.00%)    43,752 ( 0.00%)   0            0             43,752 ( 0.00%)   0            0                       double u = this->u_(s);
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                       // i = iQ + iR with iQ \in N and iR \in [0,1)
   284,388 ( 0.00%)    263 ( 0.00%)   209 ( 0.00%)    43,752 ( 0.00%)   0            0             43,752 ( 0.00%)   0            0                       double i = u * (sampling_.size()-1);
   109,380 ( 0.00%)      0              0             21,876 ( 0.00%)   0            0             43,752 ( 0.00%)   0            0                       int iQ = std::floor(i);
   109,380 ( 0.00%)  4,255 ( 0.01%)   209 ( 0.00%)    43,752 ( 0.00%)   0            0             21,876 ( 0.00%)   0            0                       double iR = i - iQ;
    43,752 ( 0.00%)      0              0             21,876 ( 0.00%)   0            0                  0            0            0                       if(iQ<0)
         .               .              .                  .            .            .                  .            .            .                           iQ = 0;
   218,760 ( 0.00%)  4,278 ( 0.01%)   209 ( 0.00%)    43,752 ( 0.00%)   0            0             21,876 ( 0.00%)   0            0                       else if( (unsigned int) iQ >= sampling_.size())
         .               .              .                  .            .            .                  .            .            .                           iQ = static_cast<int>(sampling_.size()) - 1;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           
   240,636 ( 0.00%)    260 ( 0.00%)   209 ( 0.00%)    43,752 ( 0.00%)   0            0             21,876 ( 0.00%)   0            0                       if( (unsigned int) iQ == sampling_.size()-1)
         .               .              .                  .            .            .                  .            .            .                           return sampling_.back(); // = D_
         .               .              .                  .            .            .                  .            .            .                       else
   918,792 ( 0.01%) 10,196 ( 0.02%)   836 ( 0.01%)   153,132 ( 0.00%)   0            0            153,132 ( 0.01%)   0            0                           return (1-iR)*sampling_[iQ] + iR*sampling_[iQ+1];
   153,132 ( 0.00%)      0              0            131,256 ( 0.00%)   0            0                  0            0            0                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               private:
    90,160 ( 0.00%)  9,233 ( 0.01%)   434 ( 0.00%)     9,016 ( 0.00%)   0            0             45,080 ( 0.00%)   0            0                   Eigen::Vector2d pos(double u)
         .               .              .                  .            .            .                  .            .            .                   {
   748,328 ( 0.01%) 54,313 ( 0.09%) 1,519 ( 0.01%)   216,384 ( 0.01%)  14 ( 0.00%)  14 ( 0.00%)   108,192 ( 0.00%)   0            0                       return (1-u)*(1-u)*(1-u)*P0_ + 3*(1-u)*(1-u)*u*P1_ + 3*(1-u)*u*u*P2_ + u*u*u*P3_;
    54,096 ( 0.00%)  9,016 ( 0.01%)   217 ( 0.00%)    45,080 ( 0.00%)   0            0                  0            0            0                   }
         .               .              .                  .            .            .                  .            .            .           
    90,160 ( 0.00%)    245 ( 0.00%)   245 ( 0.00%)     9,016 ( 0.00%)   0            0             45,080 ( 0.00%)   0            0                   Eigen::Vector2d der(double u)
         .               .              .                  .            .            .                  .            .            .                   {
   730,296 ( 0.01%) 20,092 ( 0.03%) 1,302 ( 0.01%)   135,240 ( 0.00%)   0            0            126,224 ( 0.00%)   0            0                       return 3*( (1-u)*(1-u)*(P1_-P0_) + 2*(1-u)*u*(P2_-P1_) + u*u*(P3_-P2_) );
    54,096 ( 0.00%)      0              0             45,080 ( 0.00%)   0            0                  0            0            0                   }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .                   Eigen::Vector2d P0_, P1_, P2_, P3_;
         .               .              .                  .            .            .                  .            .            .                   std::vector<Eigen::Vector2d,Eigen::aligned_allocator<Eigen::Vector2d> > sampling_;
         .               .              .                  .            .            .                  .            .            .               public:
     4,340 ( 0.00%)    111 ( 0.00%)   106 ( 0.00%)     1,302 ( 0.00%)   0            0              1,302 ( 0.00%)   0            0                   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
         .               .              .                  .            .            .                  .            .            .               };
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               class QuarticBezierFitter: public Fitter
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .               public:
         .               .              .                  .            .            .                  .            .            .                   QuarticBezierFitter(const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds) :
         .               .              .                  .            .            .                  .            .            .                       Fitter(p,j,N, ds)
         .               .              .                  .            .            .                  .            .            .                   {
-- line 2001 ----------------------------------------
-- line 2116 ----------------------------------------
         .               .              .                  .            .            .                  .            .            .                   CUBIC_BEZIER_FITTER,
         .               .              .                  .            .            .                  .            .            .                   QUARTIC_BEZIER_FITTER,
         .               .              .                  .            .            .                  .            .            .                   CLOTHOID_FITTER
         .               .              .                  .            .            .                  .            .            .               };
         .               .              .                  .            .            .                  .            .            .               FitterType fitterType_;
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Create a new Fitter object (call the appropriate derived constructor)
         .               .              .                  .            .            .                  .            .            .               // It is caller's responsability to call "delete" to free the memory
     2,387 ( 0.00%)      0              0                  0            0            0              1,736 ( 0.00%)   0            0               static Fitter * fitter(FitterType /*type*/, const std::vector<Input,Eigen::aligned_allocator<Input> > & p, int j, int N, double ds)
         .               .              .                  .            .            .                  .            .            .               {
         .               .              .                  .            .            .                  .            .            .                   /*
         .               .              .                  .            .            .                  .            .            .                   switch(type)
         .               .              .                  .            .            .                  .            .            .                   {
         .               .              .                  .            .            .                  .            .            .                   case CUBIC_BEZIER_FITTER:
         .               .              .                  .            .            .                  .            .            .                       return new CubicBezierFitter(p, j, N, ds);
         .               .              .                  .            .            .                  .            .            .                   case QUARTIC_BEZIER_FITTER:
         .               .              .                  .            .            .                  .            .            .                       return new QuarticBezierFitter(p, j, N, ds);
         .               .              .                  .            .            .                  .            .            .                   }
         .               .              .                  .            .            .                  .            .            .                   */
     2,821 ( 0.00%)    434 ( 0.00%)   217 ( 0.00%)       868 ( 0.00%)   0            0                434 ( 0.00%)   0            0                   return new CubicBezierFitter(p, j, N, ds);
     1,085 ( 0.00%)      0              0                868 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .               // Sampling
         .               .              .                  .            .            .                  .            .            .               double ds_;
         .               .              .                  .            .            .                  .            .            .               double lastDs_;
       522 ( 0.00%)      3 ( 0.00%)     0                174 ( 0.00%)   0            0                174 ( 0.00%)   0            0               void setDirtyArclengths_()   const { dirtyArclengths_ = true; }
    10,554 ( 0.00%)    510 ( 0.00%)    76 ( 0.00%)         0            0            0              5,277 ( 0.00%)   0            0               void precomputeArclengths_() const
         .               .              .                  .            .            .                  .            .            .               {
     8,795 ( 0.00%)      0              0              3,518 ( 0.00%)  88 ( 0.00%)  73 ( 0.00%)         0            0            0                   if(!dirtyArclengths_)
     1,726 ( 0.00%)    307 ( 0.00%)    17 ( 0.00%)         0            0            0                  0            0            0                       return;
         .               .              .                  .            .            .                  .            .            .           
       132 ( 0.00%)      0              0                 33 ( 0.00%)   0            0                 66 ( 0.00%)   0            0                   int n = size();
        66 ( 0.00%)      0              0                 33 ( 0.00%)   0            0                  0            0            0                   assert(n>0);
         .               .              .                  .            .            .                  .            .            .           
       231 ( 0.00%)     33 ( 0.00%)    21 ( 0.00%)        66 ( 0.00%)   0            0                 33 ( 0.00%)   0            0                   arclengths_.resize(n);
       231 ( 0.00%)     33 ( 0.00%)    21 ( 0.00%)        33 ( 0.00%)   0            0                 66 ( 0.00%)  17 ( 0.00%)  13 ( 0.00%)          arclengths_[0] = 0;
    12,917 ( 0.00%)     33 ( 0.00%)    21 ( 0.00%)     9,630 ( 0.00%)   0            0                 33 ( 0.00%)   0            0                   for(int i=1; i<n; ++i)
   127,520 ( 0.00%)     33 ( 0.00%)    21 ( 0.00%)    35,068 ( 0.00%)   0            0             25,504 ( 0.00%) 238 ( 0.00%) 163 ( 0.00%)              arclengths_[i] = arclengths_[i-1] + vertices_[i-1].distanceTo(vertices_[i]);
         .               .              .                  .            .            .                  .            .            .           
        99 ( 0.00%)     33 ( 0.00%)    21 ( 0.00%)        33 ( 0.00%)   0            0                 33 ( 0.00%)   0            0                   dirtyArclengths_ = false;
     5,277 ( 0.00%)      0              0              5,277 ( 0.00%)   0            0                  0            0            0               }
         .               .              .                  .            .            .                  .            .            .           public:
         .               .              .                  .            .            .                  .            .            .               EIGEN_MAKE_ALIGNED_OPERATOR_NEW
         .               .              .                  .            .            .                  .            .            .           };
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           } // end namespace SculptCurve
         .               .              .                  .            .            .                  .            .            .           
         .               .              .                  .            .            .                  .            .            .           #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/VectorAnimationComplex/EdgeSample.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr         Dr                 D1mr         DLmr         Dw                 D1mw       DLmw       

-- line 17 ----------------------------------------
         .               .            .                  .            .            .                  .          .          .           #ifndef EDGESAMPLE_H
         .               .            .                  .            .            .                  .          .          .           #define EDGESAMPLE_H
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .           #include "Eigen.h"
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .           namespace VectorAnimationComplex
         .               .            .                  .            .            .                  .          .          .           {
         .               .            .                  .            .            .                  .          .          .           
17,763,662 ( 0.14%) 27,126 ( 0.04%) 747 ( 0.01%) 5,094,912 ( 0.15%)   0            0          5,075,332 ( 0.18%) 1 ( 0.00%) 0           class EdgeSample
         .               .            .                  .            .            .                  .          .          .           {
         .               .            .                  .            .            .                  .          .          .           public:
         .               .            .                  .            .            .                  .          .          .               // Access position
29,600,508 ( 0.23%)    886 ( 0.00%) 245 ( 0.00%) 8,457,288 ( 0.25%) 290 ( 0.00%) 211 ( 0.00%) 6,342,966 ( 0.22%) 0          0               inline double x() const { return d_[0]; }
29,600,508 ( 0.23%)  1,116 ( 0.00%) 266 ( 0.00%) 8,457,288 ( 0.25%) 401 ( 0.00%) 150 ( 0.00%) 6,342,966 ( 0.22%) 0          0               inline double y() const { return d_[1]; }
         .               .            .                  .            .            .                  .          .          .               inline Eigen::Vector2d pos() const { return Eigen::Vector2d(d_[0], d_[1]); }
   153,323 ( 0.00%) 17,870 ( 0.03%) 432 ( 0.00%)    45,095 ( 0.00%)   0            0             54,114 ( 0.00%) 0          0               inline void setX(double newX) { d_[0] = newX; }
   153,323 ( 0.00%)  8,935 ( 0.01%) 216 ( 0.00%)    45,095 ( 0.00%)   0            0             54,114 ( 0.00%) 0          0               inline void setY(double newY) { d_[1] = newY; }
         .               .            .                  .            .            .                  .          .          .               inline void setPos(double x, double y) { d_[0] = x; d_[1] = y; }
         .               .            .                  .            .            .                  .          .          .               inline void setPos(const Eigen::Vector2d& p) { d_[0] = p[0]; d_[1] = p[1]; }
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // Access width
   618,002 ( 0.00%) 17,048 ( 0.03%)  23 ( 0.00%)   176,572 ( 0.01%) 309 ( 0.00%)   0            132,429 ( 0.00%) 0          0               inline double width() const { return d_[2]; }
    24,021 ( 0.00%)     32 ( 0.00%)   8 ( 0.00%)     7,065 ( 0.00%)   0            0              8,478 ( 0.00%) 0          0               inline void setWidth(double newWidth) { d_[2] = newWidth; }
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // Constructor
   159,647 ( 0.00%) 16,318 ( 0.03%) 473 ( 0.00%)    28,173 ( 0.00%)   0            0             56,346 ( 0.00%) 0          0               EdgeSample(double x = 0, double y = 0, double w = 0): d_(x, y, w) {}
   190,022 ( 0.00%)  9,564 ( 0.02%) 234 ( 0.00%)    54,292 ( 0.00%)   0            0             54,292 ( 0.00%) 0          0               EdgeSample(const Eigen::Vector3d & d): d_(d) {}
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // Translate (keep width untouched)
         .               .            .                  .            .            .                  .          .          .               inline void translate(double x, double y) { d_[0] += x; d_[1] += y; }
         .               .            .                  .            .            .                  .          .          .               inline void translate(const Eigen::Vector2d& p) {d_[0] += p[0]; d_[1] += p[1]; }
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // Linear interpolation
   128,293 ( 0.00%)  1,715 ( 0.00%) 454 ( 0.00%)    11,663 ( 0.00%)   0            0             69,978 ( 0.00%) 3 ( 0.00%) 0               EdgeSample lerp(double u, const EdgeSample & other) const
         .               .            .                  .            .            .                  .          .          .               {
   373,216 ( 0.00%)  5,668 ( 0.01%) 674 ( 0.01%)    58,315 ( 0.00%)  74 ( 0.00%)  38 ( 0.00%)    69,978 ( 0.00%) 0          0                   return EdgeSample((1-u)*d_ + u*other.d_);
    69,978 ( 0.00%)      0            0             58,315 ( 0.00%)   0            0                  0          0          0               }
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // Distance, in R^2, between two samples
    95,826 ( 0.00%)    778 ( 0.00%) 136 ( 0.00%)         0            0            0             47,913 ( 0.00%) 0          0               double distanceTo(const EdgeSample & other) const
         .               .            .                  .            .            .                  .          .          .               {
   223,594 ( 0.00%)    729 ( 0.00%) 122 ( 0.00%)    79,855 ( 0.00%) 635 ( 0.00%) 241 ( 0.00%)    63,884 ( 0.00%) 0          0                   double dx = other.d_[0] - d_[0];
   223,594 ( 0.00%)      0            0             79,855 ( 0.00%) 146 ( 0.00%) 113 ( 0.00%)    63,884 ( 0.00%) 0          0                   double dy = other.d_[1] - d_[1];
   111,797 ( 0.00%)    730 ( 0.00%) 122 ( 0.00%)    31,942 ( 0.00%)   0            0             15,971 ( 0.00%) 0          0                   double res2 = dx*dx + dy*dy;
    63,884 ( 0.00%)      0            0             15,971 ( 0.00%)   0            0             15,971 ( 0.00%) 0          0                   return std::sqrt(res2);
    47,913 ( 0.00%)      0            0             31,942 ( 0.00%)   0            0                  0          0          0               }
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // Differential
         .               .            .                  .            .            .                  .          .          .               //
         .               .            .                  .            .            .                  .          .          .               // Note: adding two samples also adds their width! this is useful for
         .               .            .                  .            .            .                  .          .          .               // interpolation purposes, but if you want to translate a sample don't add
         .               .            .                  .            .            .                  .          .          .               // a new sample, instead use the translate() methods.
         .               .            .                  .            .            .                  .          .          .               //
     4,920 ( 0.00%)    615 ( 0.00%)  50 ( 0.00%)       492 ( 0.00%)   0            0              2,460 ( 0.00%) 0          0               EdgeSample operator-(const EdgeSample & other) const
         .               .            .                  .            .            .                  .          .          .               {
     7,872 ( 0.00%)    476 ( 0.00%)  23 ( 0.00%)     1,476 ( 0.00%)   0            0              1,476 ( 0.00%) 0          0                   return EdgeSample(d_ - other.d_);
     2,952 ( 0.00%)      0            0              2,460 ( 0.00%)   0            0                  0          0          0               }
    14,140 ( 0.00%)     18 ( 0.00%)  16 ( 0.00%)     1,414 ( 0.00%)   0            0              7,070 ( 0.00%) 0          0               EdgeSample operator+(const EdgeSample & other) const
         .               .            .                  .            .            .                  .          .          .               {
    22,624 ( 0.00%)     16 ( 0.00%)  14 ( 0.00%)     4,242 ( 0.00%)   0            0              4,242 ( 0.00%) 0          0                   return EdgeSample(d_ + other.d_);
     8,484 ( 0.00%)      0            0              7,070 ( 0.00%)   0            0                  0          0          0               }
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // For weighted sums
        40 ( 0.00%)      2 ( 0.00%)   2 ( 0.00%)         4 ( 0.00%)   0            0                 20 ( 0.00%) 0          0               EdgeSample operator*(double s) const
         .               .            .                  .            .            .                  .          .          .               {
        64 ( 0.00%)      0            0                  8 ( 0.00%)   0            0                 12 ( 0.00%) 0          0                   return EdgeSample(s * d_);
        24 ( 0.00%)      0            0                 20 ( 0.00%)   0            0                  0          0          0               }
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .               // Eigen alignement
    63,860 ( 0.00%)     99 ( 0.00%)  30 ( 0.00%)    19,158 ( 0.00%)   0            0             19,158 ( 0.00%) 0          0               EIGEN_MAKE_ALIGNED_OPERATOR_NEW
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .           private:
         .               .            .                  .            .            .                  .          .          .               // 2D position + width
         .               .            .                  .            .            .                  .          .          .               Eigen::Vector3d d_;
         .               .            .                  .            .            .                  .          .          .           };
         .               .            .                  .            .            .                  .          .          .           
         .               .            .                  .            .            .                  .          .          .           }
         .               .            .                  .            .            .                  .          .          .           
-- line 94 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/DenseCoeffsBase.h
--------------------------------------------------------------------------------
Ir                   I1mr            ILmr           Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 131 ----------------------------------------
          .               .              .                   .          .          .                   .          .          .                 * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
          .               .              .                   .          .          .                   .          .          .                 * function equivalent to \link operator[](Index) const \endlink.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index) const, coeffRef(Index), coeff(Index,Index) const
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE CoeffReturnType
106,406,001 ( 0.83%)  4,780 ( 0.01%)   472 ( 0.00%) 11,822,889 ( 0.35%) 0          0          59,114,445 ( 2.08%) 0          0               coeff(Index index) const
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
          .               .              .                   .          .          .                   .          .          .                                     THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS)
          .               .              .                   .          .          .                   .          .          .                 eigen_internal_assert(index >= 0 && index < size());
224,634,891 ( 1.74%)  6,323 ( 0.01%) 1,333 ( 0.01%) 23,645,778 ( 0.70%) 0          0          47,291,556 ( 1.66%) 0          0                 return internal::evaluator<Derived>(derived()).coeff(index);
 70,937,334 ( 0.55%)  2,937 ( 0.00%) 1,309 ( 0.01%) 59,114,445 ( 1.75%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the coefficient at given index.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index), operator()(Index,Index) const, x() const, y() const,
          .               .              .                   .          .          .                   .          .          .                 * z() const, w() const
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE CoeffReturnType
 59,114,445 ( 0.46%) 47,776 ( 0.08%) 1,802 ( 0.02%)          0          0          0          35,468,667 ( 1.25%) 1 ( 0.00%) 0               operator[](Index index) const
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
          .               .              .                   .          .          .                   .          .          .                                     THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD)
 82,760,223 ( 0.64%)  1,235 ( 0.00%)   860 ( 0.01%) 35,468,667 ( 1.05%) 0          0          11,822,889 ( 0.42%) 0          0                 eigen_assert(index >= 0 && index < size());
 59,114,445 ( 0.46%)  4,694 ( 0.01%) 1,123 ( 0.01%) 23,645,778 ( 0.70%) 0          0          11,822,889 ( 0.42%) 0          0                 return coeff(index);
 23,645,778 ( 0.18%)      0              0          23,645,778 ( 0.70%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the coefficient at given index.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * This is synonymous to operator[](Index) const.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index), operator()(Index,Index) const, x() const, y() const,
-- line 172 ----------------------------------------
-- line 332 ----------------------------------------
          .               .              .                   .          .          .                   .          .          .                 * parameters \a row and \a col are in range.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
          .               .              .                   .          .          .                   .          .          .                 * function equivalent to \link operator()(Index,Index) \endlink.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator()(Index,Index), coeff(Index, Index) const, coeffRef(Index)
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    115,192 ( 0.00%)    858 ( 0.00%)   838 ( 0.01%)     10,472 ( 0.00%) 0          0              62,832 ( 0.00%) 0          0               EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 eigen_internal_assert(row >= 0 && row < rows()
          .               .              .                   .          .          .                   .          .          .                                    && col >= 0 && col < cols());
    209,440 ( 0.00%)    669 ( 0.00%)   649 ( 0.01%)     31,416 ( 0.00%) 0          0              41,888 ( 0.00%) 0          0                 return internal::evaluator<Derived>(derived()).coeffRef(row,col);
     62,832 ( 0.00%)    669 ( 0.00%)   649 ( 0.01%)     52,360 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
          .               .              .                   .          .          .                   .          .          .               coeffRefByOuterInner(Index outer, Index inner)
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 return coeffRef(rowIndexByOuterInner(outer, inner),
          .               .              .                   .          .          .                   .          .          .                                 colIndexByOuterInner(outer, inner));
          .               .              .                   .          .          .                   .          .          .               }
-- line 353 ----------------------------------------
-- line 354 ----------------------------------------
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns a reference to the coefficient at given the given row and column.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index)
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
     73,304 ( 0.00%)    669 ( 0.00%)   647 ( 0.01%)          0          0          0              41,888 ( 0.00%) 0          0               operator()(Index row, Index col)
          .               .              .                   .          .          .                   .          .          .               {
    146,608 ( 0.00%)    480 ( 0.00%)   459 ( 0.00%)     62,832 ( 0.00%) 0          0              20,944 ( 0.00%) 0          0                 eigen_assert(row >= 0 && row < rows()
          .               .              .                   .          .          .                   .          .          .                     && col >= 0 && col < cols());
     62,832 ( 0.00%)    669 ( 0.00%)   648 ( 0.01%)     31,416 ( 0.00%) 0          0              10,472 ( 0.00%) 0          0                 return coeffRef(row, col);
     20,944 ( 0.00%)      0              0              20,944 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** Short version: don't use this function, use
          .               .              .                   .          .          .                   .          .          .                 * \link operator[](Index) \endlink instead.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * Long version: this function is similar to
          .               .              .                   .          .          .                   .          .          .                 * \link operator[](Index) \endlink, but without the assertion.
          .               .              .                   .          .          .                   .          .          .                 * Use this for limiting the performance cost of debugging code when doing
-- line 375 ----------------------------------------
-- line 379 ----------------------------------------
          .               .              .                   .          .          .                   .          .          .                 * If EIGEN_INTERNAL_DEBUGGING is defined, an assertion will be made, making this
          .               .              .                   .          .          .                   .          .          .                 * function equivalent to \link operator[](Index) \endlink.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index), coeff(Index) const, coeffRef(Index,Index)
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
  5,913,860 ( 0.05%)  4,803 ( 0.01%) 2,163 ( 0.02%)    591,386 ( 0.02%) 0          0           2,956,930 ( 0.10%) 0          0               coeffRef(Index index)
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(internal::evaluator<Derived>::Flags & LinearAccessBit,
          .               .              .                   .          .          .                   .          .          .                                     THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS)
          .               .              .                   .          .          .                   .          .          .                 eigen_internal_assert(index >= 0 && index < size());
 11,236,334 ( 0.09%)  3,232 ( 0.01%)   905 ( 0.01%)  1,182,772 ( 0.04%) 0          0           2,365,544 ( 0.08%) 0          0                 return internal::evaluator<Derived>(derived()).coeffRef(index);
  3,548,316 ( 0.03%)      0              0           2,956,930 ( 0.09%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns a reference to the coefficient at given index.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index) const, operator()(Index,Index), x(), y(), z(), w()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
  3,528,792 ( 0.03%) 41,013 ( 0.07%) 1,346 ( 0.01%)          0          0          0           1,764,396 ( 0.06%) 0          0               operator[](Index index)
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::IsVectorAtCompileTime,
          .               .              .                   .          .          .                   .          .          .                                     THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD)
  4,116,924 ( 0.03%)    449 ( 0.00%)   427 ( 0.00%)  1,764,396 ( 0.05%) 0          0             588,132 ( 0.02%) 0          0                 eigen_assert(index >= 0 && index < size());
  2,940,660 ( 0.02%) 10,863 ( 0.02%)   884 ( 0.01%)  1,176,264 ( 0.03%) 0          0             588,132 ( 0.02%) 0          0                 return coeffRef(index);
  1,176,264 ( 0.01%)    449 ( 0.00%)   427 ( 0.00%)  1,176,264 ( 0.03%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns a reference to the coefficient at given index.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * This is synonymous to operator[](Index).
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * This method is allowed only for vector expressions, and for matrix expressions having the LinearAccessBit.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa operator[](Index) const, operator()(Index,Index), x(), y(), z(), w()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
     19,524 ( 0.00%)    567 ( 0.00%)   189 ( 0.00%)          0          0          0               9,762 ( 0.00%) 0          0               operator()(Index index)
          .               .              .                   .          .          .                   .          .          .               {
     22,778 ( 0.00%)      0              0               9,762 ( 0.00%) 0          0               3,254 ( 0.00%) 0          0                 eigen_assert(index >= 0 && index < size());
     16,270 ( 0.00%)    328 ( 0.00%)   189 ( 0.00%)      6,508 ( 0.00%) 0          0               3,254 ( 0.00%) 0          0                 return coeffRef(index);
      6,508 ( 0.00%)      0              0               6,508 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](0).  */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
  1,132,780 ( 0.01%)  1,403 ( 0.00%)   713 ( 0.01%)    308,940 ( 0.01%) 0          0             308,940 ( 0.01%) 0          0               x() { return (*this)[0]; }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](1).  */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
    514,900 ( 0.00%)    443 ( 0.00%)   290 ( 0.00%)          0          0          0             205,960 ( 0.01%) 0          0               y()
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=2, OUT_OF_RANGE_ACCESS);
    411,920 ( 0.00%)      0              0             102,980 ( 0.00%) 0          0             102,980 ( 0.00%) 0          0                 return (*this)[1];
    205,960 ( 0.00%)      0              0             205,960 ( 0.01%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](2).  */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
      2,400 ( 0.00%)      0              0                   0          0          0                 960 ( 0.00%) 0          0               z()
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=3, OUT_OF_RANGE_ACCESS);
      1,920 ( 0.00%)    480 ( 0.00%)   463 ( 0.00%)        480 ( 0.00%) 0          0                 480 ( 0.00%) 0          0                 return (*this)[2];
        960 ( 0.00%)      0              0                 960 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** equivalent to operator[](3).  */
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
          .               .              .                   .          .          .                   .          .          .               EIGEN_STRONG_INLINE Scalar&
          .               .              .                   .          .          .                   .          .          .               w()
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 EIGEN_STATIC_ASSERT(Derived::SizeAtCompileTime==-1 || Derived::SizeAtCompileTime>=4, OUT_OF_RANGE_ACCESS);
-- line 461 ----------------------------------------
-- line 488 ----------------------------------------
          .               .              .                   .          .          .                   .          .          .               using Base::size;
          .               .              .                   .          .          .                   .          .          .               using Base::derived;
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive elements within a slice in the inner direction.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa outerStride(), rowStride(), colStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
     80,100 ( 0.00%)    445 ( 0.00%)   424 ( 0.00%)          0          0          0              32,040 ( 0.00%) 0          0               inline Index innerStride() const
          .               .              .                   .          .          .                   .          .          .               {
     80,100 ( 0.00%)      0              0              16,020 ( 0.00%) 0          0              32,040 ( 0.00%) 0          0                 return derived().innerStride();
     32,040 ( 0.00%)      0              0              32,040 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive inner slices (for example, between two consecutive columns
          .               .              .                   .          .          .                   .          .          .                 *          in a column-major matrix).
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), rowStride(), colStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
     80,100 ( 0.00%)    445 ( 0.00%)   424 ( 0.00%)          0          0          0              32,040 ( 0.00%) 0          0               inline Index outerStride() const
          .               .              .                   .          .          .                   .          .          .               {
     80,100 ( 0.00%)    445 ( 0.00%)   424 ( 0.00%)     16,020 ( 0.00%) 0          0              32,040 ( 0.00%) 0          0                 return derived().outerStride();
     32,040 ( 0.00%)      0              0              32,040 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               // FIXME shall we remove it ?
          .               .              .                   .          .          .                   .          .          .               inline Index stride() const
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
          .               .              .                   .          .          .                   .          .          .               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive rows.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), colStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
     80,100 ( 0.00%)    445 ( 0.00%)   424 ( 0.00%)          0          0          0              32,040 ( 0.00%) 0          0               inline Index rowStride() const
          .               .              .                   .          .          .                   .          .          .               {
     48,060 ( 0.00%)      0              0              16,020 ( 0.00%) 0          0              16,020 ( 0.00%) 0          0                 return Derived::IsRowMajor ? outerStride() : innerStride();
     32,040 ( 0.00%)      0              0              32,040 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive columns.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), rowStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
     80,100 ( 0.00%)    445 ( 0.00%)   424 ( 0.00%)          0          0          0              32,040 ( 0.00%) 0          0               inline Index colStride() const
          .               .              .                   .          .          .                   .          .          .               {
     48,060 ( 0.00%)      0              0              16,020 ( 0.00%) 0          0              16,020 ( 0.00%) 0          0                 return Derived::IsRowMajor ? innerStride() : outerStride();
     32,040 ( 0.00%)      0              0              32,040 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           };
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           /** \brief Base class providing direct read/write coefficient access to matrices and arrays.
          .               .              .                   .          .          .                   .          .          .             * \ingroup Core_Module
          .               .              .                   .          .          .                   .          .          .             * \tparam Derived Type of the derived class
          .               .              .                   .          .          .                   .          .          .             * \tparam #DirectWriteAccessors Constant indicating direct access
          .               .              .                   .          .          .                   .          .          .             *
          .               .              .                   .          .          .                   .          .          .             * This class defines functions to work with strides which can be used to access entries directly. This class
-- line 544 ----------------------------------------
-- line 562 ----------------------------------------
          .               .              .                   .          .          .                   .          .          .               using Base::size;
          .               .              .                   .          .          .                   .          .          .               using Base::derived;
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive elements within a slice in the inner direction.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa outerStride(), rowStride(), colStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
     17,130 ( 0.00%)      0              0                   0          0          0               6,852 ( 0.00%) 0          0               inline Index innerStride() const
          .               .              .                   .          .          .                   .          .          .               {
     17,130 ( 0.00%)      0              0               3,426 ( 0.00%) 0          0               6,852 ( 0.00%) 0          0                 return derived().innerStride();
      6,852 ( 0.00%)      0              0               6,852 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive inner slices (for example, between two consecutive columns
          .               .              .                   .          .          .                   .          .          .                 *          in a column-major matrix).
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), rowStride(), colStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
    258,545 ( 0.00%)  2,982 ( 0.00%) 1,297 ( 0.01%)          0          0          0             103,418 ( 0.00%) 0          0               inline Index outerStride() const
          .               .              .                   .          .          .                   .          .          .               {
    258,545 ( 0.00%)    756 ( 0.00%)   189 ( 0.00%)     51,709 ( 0.00%) 0          0             103,418 ( 0.00%) 0          0                 return derived().outerStride();
    103,418 ( 0.00%)      0              0             103,418 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               // FIXME shall we remove it ?
          .               .              .                   .          .          .                   .          .          .               inline Index stride() const
          .               .              .                   .          .          .                   .          .          .               {
          .               .              .                   .          .          .                   .          .          .                 return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
          .               .              .                   .          .          .                   .          .          .               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive rows.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), colStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
     17,130 ( 0.00%)    634 ( 0.00%)   613 ( 0.01%)          0          0          0               6,852 ( 0.00%) 0          0               inline Index rowStride() const
          .               .              .                   .          .          .                   .          .          .               {
     10,278 ( 0.00%)      0              0               3,426 ( 0.00%) 0          0               3,426 ( 0.00%) 0          0                 return Derived::IsRowMajor ? outerStride() : innerStride();
      6,852 ( 0.00%)      0              0               6,852 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .               /** \returns the pointer increment between two consecutive columns.
          .               .              .                   .          .          .                   .          .          .                 *
          .               .              .                   .          .          .                   .          .          .                 * \sa innerStride(), outerStride(), rowStride()
          .               .              .                   .          .          .                   .          .          .                 */
          .               .              .                   .          .          .                   .          .          .               EIGEN_DEVICE_FUNC
     17,130 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0          0          0               6,852 ( 0.00%) 0          0               inline Index colStride() const
          .               .              .                   .          .          .                   .          .          .               {
     10,278 ( 0.00%)      0              0               3,426 ( 0.00%) 0          0               3,426 ( 0.00%) 0          0                 return Derived::IsRowMajor ? innerStride() : outerStride();
      6,852 ( 0.00%)      0              0               6,852 ( 0.00%) 0          0                   0          0          0               }
          .               .              .                   .          .          .                   .          .          .           };
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           namespace internal {
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           template<int Alignment, typename Derived, bool JustReturnZero>
          .               .              .                   .          .          .                   .          .          .           struct first_aligned_impl
          .               .              .                   .          .          .                   .          .          .           {
      6,224 ( 0.00%)      0              0                   0          0          0               3,112 ( 0.00%) 0          0             static inline Index run(const Derived&)
      4,668 ( 0.00%)     50 ( 0.00%)    50 ( 0.00%)      3,112 ( 0.00%) 0          0                   0          0          0             { return 0; }
          .               .              .                   .          .          .                   .          .          .           };
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           template<int Alignment, typename Derived>
          .               .              .                   .          .          .                   .          .          .           struct first_aligned_impl<Alignment, Derived, false>
          .               .              .                   .          .          .                   .          .          .           {
          .               .              .                   .          .          .                   .          .          .             static inline Index run(const Derived& m)
          .               .              .                   .          .          .                   .          .          .             {
          .               .              .                   .          .          .                   .          .          .               return internal::first_aligned<Alignment>(m.data(), m.size());
-- line 627 ----------------------------------------
-- line 631 ----------------------------------------
          .               .              .                   .          .          .                   .          .          .           /** \internal \returns the index of the first element of the array stored by \a m that is properly aligned with respect to \a Alignment for vectorization.
          .               .              .                   .          .          .                   .          .          .             *
          .               .              .                   .          .          .                   .          .          .             * \tparam Alignment requested alignment in Bytes.
          .               .              .                   .          .          .                   .          .          .             *
          .               .              .                   .          .          .                   .          .          .             * There is also the variant first_aligned(const Scalar*, Integer) defined in Memory.h. See it for more
          .               .              .                   .          .          .                   .          .          .             * documentation.
          .               .              .                   .          .          .                   .          .          .             */
          .               .              .                   .          .          .                   .          .          .           template<int Alignment, typename Derived>
      6,224 ( 0.00%)      0              0                   0          0          0               3,112 ( 0.00%) 0          0           static inline Index first_aligned(const DenseBase<Derived>& m)
          .               .              .                   .          .          .                   .          .          .           {
          .               .              .                   .          .          .                   .          .          .             enum { ReturnZero = (int(evaluator<Derived>::Alignment) >= Alignment) || !(Derived::Flags & DirectAccessBit) };
      7,780 ( 0.00%)      0              0               1,556 ( 0.00%) 0          0               3,112 ( 0.00%) 0          0             return first_aligned_impl<Alignment, Derived, ReturnZero>::run(m.derived());
      3,112 ( 0.00%)      0              0               3,112 ( 0.00%) 0          0                   0          0          0           }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           template<typename Derived>
      6,224 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)          0          0          0               3,112 ( 0.00%) 0          0           static inline Index first_default_aligned(const DenseBase<Derived>& m)
          .               .              .                   .          .          .                   .          .          .           {
          .               .              .                   .          .          .                   .          .          .             typedef typename Derived::Scalar Scalar;
          .               .              .                   .          .          .                   .          .          .             typedef typename packet_traits<Scalar>::type DefaultPacketType;
      4,668 ( 0.00%)      0              0               1,556 ( 0.00%) 0          0               1,556 ( 0.00%) 0          0             return internal::first_aligned<int(unpacket_traits<DefaultPacketType>::alignment),Derived>(m);
      3,112 ( 0.00%)      0              0               3,112 ( 0.00%) 0          0                   0          0          0           }
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           template<typename Derived, bool HasDirectAccess = has_direct_access<Derived>::ret>
          .               .              .                   .          .          .                   .          .          .           struct inner_stride_at_compile_time
          .               .              .                   .          .          .                   .          .          .           {
          .               .              .                   .          .          .                   .          .          .             enum { ret = traits<Derived>::InnerStrideAtCompileTime };
          .               .              .                   .          .          .                   .          .          .           };
          .               .              .                   .          .          .                   .          .          .           
          .               .              .                   .          .          .                   .          .          .           template<typename Derived>
-- line 659 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/tanja/Documents/matf/vs/2023_Analysis_vpaint/vpaint/src/VAC/../Third/Eigen/src/Core/MatrixBase.h
--------------------------------------------------------------------------------
Ir                  I1mr            ILmr           Dr                 D1mr       DLmr       Dw                 D1mw         DLmw       

-- line 460 ----------------------------------------
         .               .              .                  .          .          .                  .            .          .               EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, sin, sine)
         .               .              .                  .          .          .                  .            .          .               EIGEN_MATRIX_FUNCTION(MatrixSquareRootReturnValue, sqrt, square root)
         .               .              .                  .          .          .                  .            .          .               EIGEN_MATRIX_FUNCTION(MatrixLogarithmReturnValue, log, logarithm)
         .               .              .                  .          .          .                  .            .          .               EIGEN_MATRIX_FUNCTION_1(MatrixPowerReturnValue,        pow, power to \c p, const RealScalar& p)
         .               .              .                  .          .          .                  .            .          .               EIGEN_MATRIX_FUNCTION_1(MatrixComplexPowerReturnValue, pow, power to \c p, const std::complex<RealScalar>& p)
         .               .              .                  .          .          .                  .            .          .           
         .               .              .                  .          .          .                  .            .          .             protected:
         .               .              .                  .          .          .                  .            .          .               EIGEN_DEFAULT_COPY_CONSTRUCTOR(MatrixBase)
25,323,309 ( 0.20%) 23,350 ( 0.04%) 2,306 ( 0.02%) 6,906,357 ( 0.20%) 0          0          6,906,357 ( 0.24%) 622 ( 0.00%) 2 ( 0.00%)      EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(MatrixBase)
         .               .              .                  .          .          .                  .            .          .           
         .               .              .                  .          .          .                  .            .          .             private:
         .               .              .                  .          .          .                  .            .          .               EIGEN_DEVICE_FUNC explicit MatrixBase(int);
         .               .              .                  .          .          .                  .            .          .               EIGEN_DEVICE_FUNC MatrixBase(int,int);
         .               .              .                  .          .          .                  .            .          .               template<typename OtherDerived> EIGEN_DEVICE_FUNC explicit MatrixBase(const MatrixBase<OtherDerived>&);
         .               .              .                  .          .          .                  .            .          .             protected:
         .               .              .                  .          .          .                  .            .          .               // mixing arrays and matrices is not legal
         .               .              .                  .          .          .                  .            .          .               template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )
-- line 476 ----------------------------------------
-- line 490 ----------------------------------------
         .               .              .                  .          .          .                  .            .          .             * \returns a reference to \c *this
         .               .              .                  .          .          .                  .            .          .             *
         .               .              .                  .          .          .                  .            .          .             * Example: \include MatrixBase_applyOnTheRight.cpp
         .               .              .                  .          .          .                  .            .          .             * Output: \verbinclude MatrixBase_applyOnTheRight.out
         .               .              .                  .          .          .                  .            .          .             */
         .               .              .                  .          .          .                  .            .          .           template<typename Derived>
         .               .              .                  .          .          .                  .            .          .           template<typename OtherDerived>
         .               .              .                  .          .          .                  .            .          .           inline Derived&
     1,323 ( 0.00%)      0              0                  0          0          0                756 ( 0.00%)   0          0           MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)
         .               .              .                  .          .          .                  .            .          .           {
     1,890 ( 0.00%)    189 ( 0.00%)   189 ( 0.00%)       378 ( 0.00%) 0          0                567 ( 0.00%)   0          0             other.derived().applyThisOnTheRight(derived());
       567 ( 0.00%)      0              0                189 ( 0.00%) 0          0                189 ( 0.00%)   0          0             return derived();
       567 ( 0.00%)      0              0                567 ( 0.00%) 0          0                  0            0          0           }
         .               .              .                  .          .          .                  .            .          .           
         .               .              .                  .          .          .                  .            .          .           /** replaces \c *this by \c *this * \a other. It is equivalent to MatrixBase::operator*=().
         .               .              .                  .          .          .                  .            .          .             *
         .               .              .                  .          .          .                  .            .          .             * Example: \include MatrixBase_applyOnTheRight.cpp
         .               .              .                  .          .          .                  .            .          .             * Output: \verbinclude MatrixBase_applyOnTheRight.out
         .               .              .                  .          .          .                  .            .          .             */
         .               .              .                  .          .          .                  .            .          .           template<typename Derived>
         .               .              .                  .          .          .                  .            .          .           template<typename OtherDerived>
-- line 510 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/./elf/dl-lookup.c
  ./malloc/./malloc/malloc.c
  ./math/../sysdeps/ieee754/dbl-64/e_hypot.c
  ./math/../sysdeps/ieee754/dbl-64/s_sin.c
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strchr-avx2.S
  ./string/../sysdeps/x86_64/strcmp.S

--------------------------------------------------------------------------------
Ir                     I1mr               ILmr             Dr                     D1mr             DLmr             Dw                     D1mw            DLmw            
--------------------------------------------------------------------------------
4,413,797,872 (34.24%) 2,845,978 ( 4.60%) 367,912 ( 3.52%) 1,335,541,980 (39.55%) 969,575 ( 0.39%) 953,063 ( 0.42%) 1,238,764,056 (43.55%) 54,535 ( 0.01%) 30,636 ( 0.01%)  events annotated

